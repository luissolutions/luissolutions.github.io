<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Budget Planner</title>
  <link rel="stylesheet" href="../assets/css/app-styles.css" />
  <style>
    .grid {
      display: grid;
    }

    .two {
      grid-template-columns: 1fr 1fr;
    }

    .three {
      grid-template-columns: 1fr 1fr 1fr;
    }

    .card {
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
    }

    .muted {
      opacity: .75;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      border: 1px solid #e3e3e3;
      padding: 6px 8px;
      text-align: right;
    }

    th.sticky {
      position: sticky;
      top: 0;
      background: #fafafa;
      z-index: 2;
    }

    td:first-child,
    th:first-child {
      text-align: left;
      position: sticky;
      left: 0;
      z-index: 1;
      background: #fff;
    }

    thead th:first-child {
      background: #fafafa;
    }

    .right {
      text-align: right;
    }

    .center {
      text-align: center;
    }

    .ok {
      color: #10893e;
    }

    .warn {
      color: #b71c1c;
    }

    input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      padding: 6px;
    }

    input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      padding: 6px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .toolbar>* {
      margin: 4px 0;
    }

    .btn {
      padding: 2px 10px;
      border-radius: 8px;
      cursor: pointer;
    }

    .btn.primary {
      background: #2563eb;
      border-color: #1d4ed8;
    }


    .totals {
      font-weight: 700;
    }

    .scroll-x {
      overflow-x: auto;
    }

    .small {
      font-size: .9rem;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
    }

    .light-under {
      background: lightgreen;
    }

    .light-over {
      background: red;
    }
  </style>
  <script type="module" src="./assets/js/login.js"></script>
</head>

<body>
  <header class="grid two">
    <div>
      <h1>Budget Planner</h1>
      <p class="muted">Plan monthly budgets for next year, enter actuals each month, and see variances live. Auto-saves
        to Firebase under <code>/budgetPlan/&lt;year&gt;</code>.</p>
    </div>
    <div class="card">
      <div class="toolbar">
        <label>Year:
          <select id="year"></select>
        </label>
        <button id="add-year" class="btn">+ Add Year</button>


        <label title="Gross income you expect for this year">
          Expected Yearly Income:
          <input id="incomeYear" type="number" min="0" step="0.01" style="width:12ch;" />
        </label>

        <button id="save" class="btn primary">Save now</button>
        <button id="export-csv" class="btn">Export CSV</button>
        <button id="reset-defaults" class="btn clear-button" style="display: none;">Reset to defaults</button>
        <button id="sync-from-tracker" class="btn">Sync from Financial Data</button>

      </div>
      <div id="yearTotals" style="margin-top:8px"></div>
    </div>
  </header>

  <main style="margin-top:16px; align-items:start;">
    <section class="card">
      <h2>Categories & Base Monthly Budgets</h2>
      <p class="small muted">Tip: adjust a category's <strong>Monthly Budget</strong> to change all months at once. In
        the big table, you can override specific months for a category.</p>
      <div id="cats" class="grid" style="gap:14px"></div>
    </section>
    <br>
    <section class="card scroll-x">
      <h2>Budget vs Actual (by Month)</h2>
      <table id="budget-table">
        <thead>
          <tr id="budget-header-row">
            <!-- header cells injected by JS -->
          </tr>
        </thead>
        <tbody></tbody>
        <tfoot></tfoot>
      </table>
    </section>
  </main>

  <footer class="muted" style="margin-top:16px">
    <p>â€¢ <strong>Budget cells</strong> (first line per category) are editable and act as per-month overrides.<br>
      â€¢ <strong>Actual cells</strong> (second line) are where you type what you actually spent.<br>
      â€¢ The right panel shows <strong>live totals</strong> and <strong>variance</strong> (green is under budget).
    </p>
    <section id="login-section">
      <form id="login-form">
        <label for="username">Email:</label>
        <input type="email" id="username" required>
        <br>
        <label for="password">Password:</label>
        <input type="password" id="password" required>
        <br>
        <button type="submit">Login</button>
      </form>
      <button id="logout" style="display: none;">Logout</button>
    </section>
  </footer>
</body>

<script type="module">
  import { auth, onAuthStateChanged, database, ref, get, set } from './assets/js/firebase-init.js';

  /* ======== Config ======== */
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  // Default baseline (uses next year by default)
  const DEFAULT_BASE = {
    year: new Date().getFullYear() + 1,
    incomeYear: 0,
    categories: [
      { name: 'Rent/Main bills', monthly: 830.00 },
      { name: 'Phone', monthly: 80.00 },
      { name: 'Vehicle gas', monthly: 140.00 },
      { name: 'Groceries', monthly: 140.00 },
      { name: 'Restaurants', monthly: 140.00 },
      { name: 'Entertainment', monthly: 50.00 },
      { name: 'Insurance', monthly: 170.00 },
    ],
    budgetOverrides: {},
    actuals: {}
  };

  /* ======== State ======== */
  let DATABASE_BASE_PATH = 'public';
  let STATE = structuredClone(DEFAULT_BASE);
  let DOM_READY = false;
  let AUTH_READY = false;

  // Firebase RTDB forbidden key chars: . # $ [ ] /
  const FORBIDDEN = /[.#$/[\]]/g;
  const safeKey = (s) => String(s ?? '').replace(FORBIDDEN, '_');

  // Build a map of safeKey -> displayName for the categories in STATE
  const buildNameMap = (state) =>
    Object.fromEntries((state.categories || []).map(c => [safeKey(c.name), c.name]));


  /* ======== Financial Tracker integration (read-only) ======== */
  // Path of your Financial Tracker data (unchanged on that side)
  const FIN_TRACKER_PATH = () => `${DATABASE_BASE_PATH}/budget`;

  // How to handle entries with MULTIPLE tags:
  // - "split": split the amount evenly across tags (prevents double counting)
  // - "duplicate": count full amount into each tag (can inflate totals)
  const MULTITAG_MODE = "split";

  // Where to put untagged expenses (null/empty tags)
  const UNTITLED_CATEGORY = "Uncategorized";

  /** Parse ISO or parseable date -> {y, m} or null */
  function ymFromDate(dateStr) {
    const d = new Date(dateStr);
    if (Number.isNaN(d.getTime())) return null;
    return { y: d.getFullYear(), m: d.getMonth() }; // 0..11
  }

  /** Ensure a category exists in STATE (exact match by name) */
  function ensureCategory(catName) {
    if (!catName) return;
    if (!STATE.categories.some(c => c.name === catName)) {
      STATE.categories.push({ name: catName, monthly: 0 });
    }
  }



  // Convert STATE -> object with sanitized keys for DB
  function encodeForDB(state) {
    const out = structuredClone(state);
    const nameMap = buildNameMap(state);
    out._nameMap = nameMap;

    // Sanitize actuals: actuals[month][safeCat] = value
    const encActuals = {};
    for (const m of Object.keys(out.actuals || {})) {
      const monthObj = out.actuals[m] || {};
      const encMonth = {};
      for (const [catName, val] of Object.entries(monthObj)) {
        encMonth[safeKey(catName)] = val;
      }
      encActuals[m] = encMonth;
    }
    out.actuals = encActuals;

    // Sanitize budgetOverrides: "<safeCat>::<mIndex>" = value
    const encOverrides = {};
    for (const [k, val] of Object.entries(out.budgetOverrides || {})) {
      // k looks like "<catName>::<mIndex>"
      const idx = k.lastIndexOf('::');
      if (idx > -1) {
        const cat = k.slice(0, idx);
        const mi = k.slice(idx + 2);
        encOverrides[`${safeKey(cat)}::${mi}`] = val;
      } else {
        // fallback: whole key sanitized
        encOverrides[safeKey(k)] = val;
      }
    }
    out.budgetOverrides = encOverrides;

    return out;
  }

  // Convert DB object with sanitized keys -> STATE (display names as keys)
  function decodeFromDB(obj, targetYear) {
    if (!obj) return null;
    const nameMap = obj._nameMap || {};
    const revName = (safe) => nameMap[safe] || safe; // best effort

    const out = structuredClone(obj);
    // force the year we asked for
    out.year = Number(targetYear);

    // De-sanitize actuals
    const decActuals = {};
    for (const m of Object.keys(out.actuals || {})) {
      const monthObj = out.actuals[m] || {};
      const decMonth = {};
      for (const [safeCat, val] of Object.entries(monthObj)) {
        decMonth[revName(safeCat)] = val;
      }
      decActuals[m] = decMonth;
    }
    out.actuals = decActuals;

    // De-sanitize overrides
    const decOverrides = {};
    for (const [k, val] of Object.entries(out.budgetOverrides || {})) {
      const idx = k.lastIndexOf('::');
      if (idx > -1) {
        const safeCat = k.slice(0, idx);
        const mi = k.slice(idx + 2);
        decOverrides[`${revName(safeCat)}::${mi}`] = val;
      } else {
        decOverrides[revName(k)] = val;
      }
    }
    out.budgetOverrides = decOverrides;

    // Clean helper
    delete out._nameMap;
    return out;
  }

  function ensureShapes() {
    if (!Array.isArray(STATE.categories)) STATE.categories = [];
    if (!STATE.budgetOverrides) STATE.budgetOverrides = {};
    if (!STATE.actuals) STATE.actuals = {};
    if (typeof STATE.incomeYear !== 'number') STATE.incomeYear = 0; // ðŸ‘ˆ NEW
  }

  async function loadFromDB() {
    const yearSel = document.getElementById('year');
    const wantYear = Number(yearSel?.value || DEFAULT_BASE.year);

    const snap = await get(ref(database, `${DATABASE_BASE_PATH}/budgetPlan/${wantYear}`));
    if (snap.exists()) {
      STATE = decodeFromDB(snap.val(), wantYear);
    } else {
      STATE = structuredClone(DEFAULT_BASE);
      STATE.year = wantYear;
    }
    ensureShapes();
  }

  async function saveToDB() {
    try {
      const toWrite = encodeForDB(STATE);
      await set(ref(database, `${DATABASE_BASE_PATH}/budgetPlan/${STATE.year}`), toWrite);
    } catch (e) {
      console.error('Save failed', e);
    }
  }

  /* ======== Utilities ======== */
  const fmt = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });
  const toNum = v => Math.max(0, Number(v) || 0);

  function planForMonth(catName, mIndex) {
    const key = `${catName}::${mIndex}`;
    const ov = STATE.budgetOverrides[key];
    if (ov != null) return toNum(ov);
    const cat = STATE.categories.find(c => c.name === catName);
    return toNum(cat?.monthly);
  }

  function actualForMonth(catName, mIndex) {
    const mKey = months[mIndex];
    return toNum(STATE.actuals?.[mKey]?.[catName]);
  }

  function setActual(catName, mIndex, val) {
    const mKey = months[mIndex];
    if (!STATE.actuals[mKey]) STATE.actuals[mKey] = {};
    STATE.actuals[mKey][catName] = toNum(val);
  }

  function setBudgetMonthly(catName, monthly) {
    const cat = STATE.categories.find(c => c.name === catName);
    if (cat) cat.monthly = toNum(monthly);
  }

  function setBudgetOverride(catName, mIndex, val) {
    const key = `${catName}::${mIndex}`;
    if (val === '' || val == null) delete STATE.budgetOverrides[key];
    else STATE.budgetOverrides[key] = toNum(val);
  }

  function totals() {
    const perMonth = months.map((_, mi) => {
      let budget = 0, actual = 0;
      for (const c of STATE.categories) {
        budget += planForMonth(c.name, mi);
        actual += actualForMonth(c.name, mi);
      }
      return { budget, actual, variance: actual - budget };
    });
    const yearBudget = perMonth.reduce((s, m) => s + m.budget, 0);
    const yearActual = perMonth.reduce((s, m) => s + m.actual, 0);
    return { perMonth, yearBudget, yearActual, yearVariance: yearActual - yearBudget };
  }

  function renderHeader() {
    const hdr = document.getElementById('budget-header-row');
    if (!hdr) return;
    hdr.innerHTML = '<th class="sticky">Category</th>' + months.map(m => `<th class="sticky">${m}</th>`).join('');
  }

  function renderCategoriesEditor() {
    const wrap = document.getElementById('cats');
    if (!wrap) return;
    wrap.innerHTML = '';

    STATE.categories.forEach((c, idx) => {
      const row = document.createElement('div');
      row.className = 'grid two';
      row.innerHTML = `
        <div>
          <label class="small">Category</label>
          <div>
            <input type="text" value="${c.name}" />
            <button type="button" class="btn clear-button small del-cat" title="Delete category">X</button>
          </div>
        </div>
        <div>
          <label class="small">Monthly Budget</label>
          <input type="number" min="0" step="0.01" value="${c.monthly}" />
        </div>
      `;
      const [nameEl, monthlyEl] = row.querySelectorAll('input');

      nameEl.addEventListener('blur', () => {
        const newName = nameEl.value.trim() || `Category ${idx + 1}`;
        if (newName !== c.name) {
          // migrate overrides + actuals keys
          for (let mi = 0; mi < months.length; mi++) {
            const oldKey = `${c.name}::${mi}`;
            const newKey = `${newName}::${mi}`;
            if (STATE.budgetOverrides[oldKey] != null) {
              STATE.budgetOverrides[newKey] = STATE.budgetOverrides[oldKey];
              delete STATE.budgetOverrides[oldKey];
            }
            const mKey = months[mi];
            if (STATE.actuals[mKey]?.[c.name] != null) {
              STATE.actuals[mKey][newName] = STATE.actuals[mKey][c.name];
              delete STATE.actuals[mKey][c.name];
            }
          }
          c.name = newName;
          saveToDB();
          renderAll();
        }
      });

      monthlyEl.addEventListener('input', () => {
        setBudgetMonthly(c.name, monthlyEl.value);
        renderBudgetTable();
        renderMonthTotals();
        renderYearTotals();
      });

      const delBtn = row.querySelector('.del-cat');
      delBtn.addEventListener('click', () => deleteCategory(c.name));

      wrap.appendChild(row);
    });

    const add = document.createElement('button');
    add.className = 'btn';
    add.textContent = '+ Add Category';
    add.addEventListener('click', () => {
      STATE.categories.push({ name: `Category ${STATE.categories.length + 1}`, monthly: 0 });
      renderAll();
      saveToDB();
    });
    wrap.appendChild(add);
  }

  function renderBudgetTable() {
    const tbody = document.querySelector('#budget-table tbody');
    if (!tbody) return;
    tbody.innerHTML = '';

    STATE.categories.forEach((c, idx) => {
      // ===== Budget row =====
      const tr = document.createElement('tr');
      tr.dataset.idx = idx;
      tr.dataset.kind = 'budget';

      const { budget, actual } = categoryTotals(c.name); // NEW

      const nameTd = document.createElement('td');
      nameTd.textContent = `${c.name} (${fmt.format(budget)})`; // NEW: show total budget
      tr.appendChild(nameTd);

      months.forEach((m, mi) => {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'number'; input.min = '0'; input.step = '0.01';
        input.value = planForMonth(c.name, mi);
        input.title = 'Budget (override this month). Leave blank to use category monthly.';
        input.addEventListener('input', () => {
          const v = input.value;
          if (v === '') setBudgetOverride(c.name, mi, '');
          else setBudgetOverride(c.name, mi, v);
          // Keep totals fresh
          updateCategoryLabelByIndex(idx);
          // Re-color the actual cell for this month (budget changed)
          const actualCell = tbody.querySelector(`tr[data-idx="${idx}"][data-kind="actual"] td[data-mi="${mi}"]`);
          if (actualCell) setActualCellColor(actualCell, c.name, mi);
          renderMonthTotals();
          renderYearTotals();
        });
        td.appendChild(input);
        tr.appendChild(td);
      });

      // ===== Actuals row =====
      const tr2 = document.createElement('tr');
      tr2.dataset.idx = idx;
      tr2.dataset.kind = 'actual';

      const name2 = document.createElement('td');
      name2.innerHTML = `<span class="muted">Actual â€” ${c.name} (${fmt.format(actual)})</span>`; // NEW: show total actual
      tr2.appendChild(name2);

      months.forEach((m, mi) => {
        const td = document.createElement('td');
        td.setAttribute('data-mi', mi); // NEW: quick lookup later

        const input = document.createElement('input');
        input.type = 'number'; input.min = '0'; input.step = '0.01';
        const v = actualForMonth(c.name, mi);
        input.value = v ? v : '';
        input.placeholder = '0.00';
        input.addEventListener('input', () => {
          setActual(c.name, mi, input.value);
          // re-color this cell
          setActualCellColor(td, c.name, mi);
          // refresh just the labels (no full table re-render)
          updateCategoryLabelByIndex(idx);
          renderMonthTotals();
          renderYearTotals();
        });

        td.appendChild(input);
        // initial color on first render
        setActualCellColor(td, c.name, mi); // NEW
        tr2.appendChild(td);
      });

      tbody.appendChild(tr);
      tbody.appendChild(tr2);
    });
  }

  function renderMonthTotals() {
    const tfoot = document.querySelector('#budget-table tfoot');
    if (!tfoot) return;
    tfoot.innerHTML = '';
    const { perMonth } = totals();

    const trBudget = document.createElement('tr');
    trBudget.className = 'totals';
    trBudget.innerHTML = `<td>Monthly Budget Total</td>` + perMonth.map(m => `<td>${fmt.format(m.budget)}</td>`).join('');

    const trActual = document.createElement('tr');
    trActual.className = 'totals';
    trActual.innerHTML = `<td>Monthly Actual Total</td>` + perMonth.map(m => `<td>${fmt.format(m.actual)}</td>`).join('');

    const trVar = document.createElement('tr');
    trVar.className = 'totals';
    trVar.innerHTML = `<td>Variance (Actual - Budget)</td>` + perMonth.map(m => {
      const cls = m.variance <= 0 ? 'ok' : 'warn';
      return `<td class="${cls}">${fmt.format(m.variance)}</td>`;
    }).join('');

    tfoot.appendChild(trBudget);
    tfoot.appendChild(trActual);
    tfoot.appendChild(trVar);
  }

  function renderYearTotals() {
    const box = document.getElementById('yearTotals');
    if (!box) return;

    const { yearBudget, yearActual, yearVariance } = totals();
    const yearIncome = Math.max(0, Number(STATE.incomeYear) || 0);
    const netVsBudget = yearIncome - yearBudget; // plan-level net
    const netVsActual = yearIncome - yearActual; // actual net so far

    box.innerHTML = `
    <div><span class="pill">Year:</span> <strong>${STATE.year}</strong></div>
    <div>Expected Income: <strong>${fmt.format(yearIncome)}</strong></div>
    <hr>
    <div>Budgeted Expenses: <strong>${fmt.format(yearBudget)}</strong></div>
    <div>Actual Expenses: <strong>${fmt.format(yearActual)}</strong></div>
    <div>Expense Variance (Actual âˆ’ Budget):
      <strong class="${yearVariance <= 0 ? 'ok' : 'warn'}">${fmt.format(yearVariance)}</strong>
    </div>
    <hr>
    <div>Net (Income âˆ’ Budget):
      <strong class="${netVsBudget >= 0 ? 'ok' : 'warn'}">${fmt.format(netVsBudget)}</strong>
    </div>
    <div>Net (Income âˆ’ Actual):
      <strong class="${netVsActual >= 0 ? 'ok' : 'warn'}">${fmt.format(netVsActual)}</strong>
    </div>
  `;
  }

  function exportCSV() {
    const { perMonth, yearBudget, yearActual, yearVariance } = totals();
    const yearIncome = Math.max(0, Number(STATE.incomeYear) || 0);
    const netVsBudget = yearIncome - yearBudget;
    const netVsActual = yearIncome - yearActual;

    const header = ['Category', ...months.map(m => `${m} Budget`), ...months.map(m => `${m} Actual`)];
    const rows = [header];

    for (const c of STATE.categories) {
      const bRow = [c.name];
      for (let mi = 0; mi < 12; mi++) bRow.push(planForMonth(c.name, mi));
      for (let mi = 0; mi < 12; mi++) bRow.push(actualForMonth(c.name, mi));
      rows.push(bRow);
    }

    rows.push(['Totals (Budget)', ...perMonth.map(m => m.budget), ...Array(12).fill('')]);
    rows.push(['Totals (Actual)', ...perMonth.map(m => m.actual), ...Array(12).fill('')]);
    rows.push(['Year Income', yearIncome]);
    rows.push(['Year Net (Income âˆ’ Budget)', netVsBudget]);
    rows.push(['Year Net (Income âˆ’ Actual)', netVsActual]);
    rows.push(['Year Expense Variance (Actual âˆ’ Budget)', yearVariance]);

    const csv = rows.map(r => r.map(csvEscape).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `budget_${STATE.year}.csv`; a.click();
    URL.revokeObjectURL(url);
  }

  const csvEscape = (v) => {
    const s = String(v ?? '');
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
  };

  function categoryTotals(catName) {
    let budget = 0, actual = 0;
    for (let mi = 0; mi < 12; mi++) {
      budget += planForMonth(catName, mi);
      actual += actualForMonth(catName, mi);
    }
    return { budget, actual };
  }

  function setActualCellColor(td, catName, mi) {
    const a = toNum(STATE.actuals?.[months[mi]]?.[catName]);
    const b = planForMonth(catName, mi);
    td.classList.remove('light-under', 'light-over');
    if (td.querySelector('input')?.value === '') return; // empty = no color
    td.classList.add(a <= b ? 'light-under' : 'light-over');
  }

  // Update the two left labels for a given category row by index
  function updateCategoryLabelByIndex(idx) {
    const tbody = document.querySelector('#budget-table tbody');
    if (!tbody) return;
    const cat = STATE.categories[idx];
    if (!cat) return;
    const { budget, actual } = categoryTotals(cat.name);

    const budgetRow = tbody.querySelector(`tr[data-idx="${idx}"][data-kind="budget"] td:first-child`);
    const actualRow = tbody.querySelector(`tr[data-idx="${idx}"][data-kind="actual"] td:first-child`);

    if (budgetRow) budgetRow.textContent = `${cat.name} (${fmt.format(budget)})`;
    if (actualRow) actualRow.innerHTML = `<span class="muted">Actual â€” ${cat.name} (${fmt.format(actual)})</span>`;
  }

  /* ======== Helpers ======== */
  const debounce = (fn, ms = 400) => {
    let t;
    return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  };

  /** Get all numeric years that exist in DB under /budgetPlan */
  async function fetchAvailableYears() {
    const baseRef = ref(database, `${DATABASE_BASE_PATH}/budgetPlan`);
    const snap = await get(baseRef);
    const out = [];
    if (snap.exists()) {
      for (const key of Object.keys(snap.val() || {})) {
        const n = Number(key);
        if (!Number.isNaN(n)) out.push(n);
      }
    }
    // Oldest -> newest for dropdown
    out.sort((a, b) => a - b);
    return out;
  }

  /** Populate the <select id="year"> with existing years; optionally select a specific year */
  async function populateYearSelect(selectYear = null) {
    const yearEl = document.getElementById('year');
    if (!yearEl) return;

    const years = await fetchAvailableYears();

    // Build options
    yearEl.innerHTML = '';
    if (years.length === 0) {
      // Nothing exists yet â€” leave empty and nudge user to Add Year
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = '(no years yet â€” click "Add Year")';
      yearEl.appendChild(opt);
      yearEl.disabled = true;
      return;
    }

    yearEl.disabled = false;
    years.forEach(y => {
      const opt = document.createElement('option');
      opt.value = String(y);
      opt.textContent = String(y);
      yearEl.appendChild(opt);
    });

    // Choose a year:
    const desired = selectYear != null ? Number(selectYear) : (
      // If STATE.year is in list, keep it; else pick the latest available.
      years.includes(Number(STATE?.year)) ? Number(STATE.year) : years[years.length - 1]
    );

    yearEl.value = String(desired);
    STATE.year = desired;  // keep STATE in sync
  }

  /** Create a new year in DB.
   *  - By default, clone current categories & monthly budgets (no actuals, no overrides, income=0).
   *  - If no current state yet, use DEFAULT_BASE.
   */
  async function addYearFlow() {
    const suggested = new Date().getFullYear();
    const input = prompt(`Enter the year to add (e.g., ${suggested}):`, String(suggested));
    const y = Number(input);
    if (!y || Number.isNaN(y)) return;

    const existing = await fetchAvailableYears();
    if (existing.includes(y)) {
      alert(`Year ${y} already exists.`);
      await populateYearSelect(y);
      await loadFromDB();
      renderAll();
      return;
    }

    // Use current categories if we have any; otherwise DEFAULT_BASE
    const base = Array.isArray(STATE?.categories) && STATE.categories.length
      ? {
        year: y,
        incomeYear: 0,
        categories: STATE.categories.map(c => ({ name: c.name, monthly: Number(c.monthly) || 0 })),
        budgetOverrides: {},
        actuals: {}
      }
      : (() => {
        const b = structuredClone(DEFAULT_BASE);
        b.year = y;
        b.incomeYear = 0;
        b.budgetOverrides = {};
        b.actuals = {};
        return b;
      })();

    // Save new year
    await set(ref(database, `${DATABASE_BASE_PATH}/budgetPlan/${y}`), encodeForDB(base));

    // Refresh picker and UI onto the newly-created year
    await populateYearSelect(y);
    await loadFromDB();
    renderAll();
    alert(`Year ${y} added.`);
  }


  async function syncFromFinancialTracker() {
    // 1) Read raw tracker data
    const snap = await get(ref(database, FIN_TRACKER_PATH()));
    if (!snap.exists()) {
      alert('No financial data found at: ' + FIN_TRACKER_PATH());
      return;
    }
    const raw = snap.val(); // structure: { "Jan-3": { details: [ ... ] }, ... }

    // 2) Filter entries for the selected year and flatten
    const wantYear = Number(STATE.year);
    const entries = [];
    for (const bucket of Object.values(raw)) {
      const details = Array.isArray(bucket?.details) ? bucket.details : [];
      for (const d of details) {
        if (!d?.date) continue;
        const ym = ymFromDate(d.date);
        if (!ym || ym.y !== wantYear) continue;
        entries.push({
          monthIndex: ym.m,
          type: String(d.type || ''),
          amount: Number(d.amount) || 0,
          tags: Array.isArray(d.tags) ? d.tags.filter(t => String(t).trim()) : []
        });
      }
    }

    // 3) Aggregate income + expenses-by-tag-per-month
    let incomeYearSum = 0;
    const monthTagSums = Array.from({ length: 12 }, () => new Map()); // [m] Map<tag, sum>

    for (const e of entries) {
      const t = e.type.toLowerCase();
      if (t === 'income') {
        incomeYearSum += e.amount;
        continue;
      }
      if (t === 'expenses' || t === 'expense') {
        let tags = e.tags.length ? e.tags.map(s => String(s).trim()) : [UNTITLED_CATEGORY];
        // Split or duplicate across tags
        const share = (MULTITAG_MODE === 'split' && tags.length > 0) ? (e.amount / tags.length) : e.amount;

        const mMap = monthTagSums[e.monthIndex];
        for (const tag of tags) {
          const prev = mMap.get(tag) || 0;
          mMap.set(tag, prev + (MULTITAG_MODE === 'split' ? share : e.amount));
        }
      }
    }

    // 4) Ensure categories exist for all seen tags
    const seenTags = new Set();
    monthTagSums.forEach(mMap => mMap.forEach((_, tag) => seenTags.add(tag)));
    seenTags.forEach(tag => ensureCategory(tag));

    // 5) Write into STATE.actuals[Month][Category] using tag names as categories
    for (let mi = 0; mi < 12; mi++) {
      const mKey = months[mi];
      STATE.actuals[mKey] ??= {};
      const mMap = monthTagSums[mi];
      // Preserve any categories not present in the financial data; overwrite those that are
      mMap.forEach((sum, tag) => {
        STATE.actuals[mKey][tag] = Math.max(0, Number(sum) || 0);
      });
    }

    // 6) Update income
    STATE.incomeYear = Math.max(0, Number(incomeYearSum) || 0);

    // 7) Refresh UI + persist
    renderAll();
    await saveToDB();
    alert('Budget actuals and income synced from Financial Tracker tags.');
  }

  function deleteCategory(catName) {
    if (!catName) return;
    if (!confirm(`Delete category "${catName}" and all its data? This cannot be undone.`)) return;

    // 1) Remove from category list
    STATE.categories = STATE.categories.filter(c => c.name !== catName);

    // 2) Remove budget overrides for all months (catName::0..11)
    for (let mi = 0; mi < 12; mi++) {
      delete STATE.budgetOverrides[`${catName}::${mi}`];
    }
    // Safety: if any stray keys exist (old names), remove by prefix too
    for (const k of Object.keys(STATE.budgetOverrides)) {
      if (k.startsWith(`${catName}::`)) delete STATE.budgetOverrides[k];
    }

    // 3) Remove actuals for every month
    for (const mKey of months) {
      if (STATE.actuals?.[mKey]) {
        delete STATE.actuals[mKey][catName];
        // Optional cleanup: remove empty month objects
        if (Object.keys(STATE.actuals[mKey]).length === 0) {
          // keep the object to preserve shape; skip if you prefer deletion:
          // delete STATE.actuals[mKey];
        }
      }
    }

    // 4) Re-render + save
    renderAll();
    saveToDB();
  }

  /* ======== Rendering ======== */
  function renderAll() {
    const yearEl = document.getElementById('year');
    if (yearEl) yearEl.value = STATE.year;

    // keep income input synced with state
    const incEl = document.getElementById('incomeYear');
    if (incEl) incEl.value = STATE.incomeYear ?? 0;

    renderHeader();
    renderCategoriesEditor();
    renderBudgetTable();
    renderMonthTotals();
    renderYearTotals();
  }

  /* ======== Init / Event wiring ======== */
  function maybeInit() {
    if (!(DOM_READY && AUTH_READY)) return;

    const incomeEl = document.getElementById('incomeYear');
    if (incomeEl && !incomeEl._wired) {
      incomeEl.addEventListener('input', debounce(() => {
        STATE.incomeYear = Math.max(0, Number(incomeEl.value) || 0);
        renderYearTotals();
        saveToDB();
      }, 250));
      incomeEl._wired = true;
    }

    // buttons (save/reset/export)
    document.addEventListener('click', async (e) => {
      if (e.target.matches('#add-year')) {
        try {
          await addYearFlow();
        } catch (err) {
          console.error(err);
          alert('Failed to add year. See console for details.');
        }
      }

      if (e.target.matches('#save')) saveToDB();
      if (e.target.matches('#export-csv')) exportCSV();

      if (e.target.matches('#reset-defaults')) {
        if (!confirm('Reset this year to default baseline?')) return;
        const keepYear = STATE.year;
        const keepIncome = STATE.incomeYear;
        STATE = structuredClone(DEFAULT_BASE);
        STATE.year = keepYear;
        STATE.incomeYear = keepIncome;
        ensureShapes();
        renderAll();
        saveToDB();
      }

      if (e.target.matches('#sync-from-tracker')) {
        try {
          await syncFromFinancialTracker();
        } catch (err) {
          console.error(err);
          alert('Sync failed. See console for details.');
        }
      }
    });

    // year select
    const yearSelEl = document.getElementById('year');
    if (yearSelEl && !yearSelEl._wired) {
      yearSelEl.addEventListener('change', async (e) => {
        STATE.year = Number(e.target.value);
        await loadFromDB();
        renderAll();
      });
      yearSelEl._wired = true;
    }

    // initial load after both DOM + Auth are ready
    (async () => {
      await populateYearSelect(); // fill dropdown with what's in DB
      // If there are no years, user must click "Add Year"; otherwise load the selected year
      const selectedValue = document.getElementById('year')?.value;
      if (selectedValue) {
        await loadFromDB();
        renderAll();
      }
    })();

    window.addEventListener('beforeunload', () => saveToDB());
  }

  document.addEventListener('DOMContentLoaded', () => {
    DOM_READY = true;
    maybeInit();
  });

  onAuthStateChanged(auth, async (user) => {
    DATABASE_BASE_PATH = user ? `${user.uid}` : 'public';
    AUTH_READY = true;
    maybeInit();
  });
</script>

</html>