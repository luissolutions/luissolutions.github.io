<!DOCTYPE html>
<html lang="en">

<head>
  <title>Financial Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="./assets/img/financial_logo.png">
  <link rel="stylesheet" href="../assets/css/app-styles.css" id="stylesheet">
  <script type="module" src="./assets/js/login.js" defer></script>
  <style>
    .transaction-row select,
    .transaction-row button {
      padding-bottom: 3px;
      padding-top: 0;
      margin-bottom: 0;
    }

    .visuals canvas {
      height: auto;
      width: 60%;
      margin: 0 auto;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
  <header>
    <h1>Online Financial Tracker</h1>
    <section id="login-section">
      <form id="login-form">
        <label for="username">Email:</label>
        <input type="email" id="username" required>
        <br>
        <label for="password">Password:</label>
        <input type="password" id="password" required>
        <br>
        <button type="submit">Login</button>
      </form>
      <button id="logout" style="display: none;">Logout</button>
    </section>
  </header>

  <main id="top">

    <section id="charts" style="margin: 12px 0;">

      <div>
        <label for="yearSelect">Select Year: </label>
        <select id="yearSelect"></select>
      </div>

      <section id="all-transactions">
        <div>
          <input type="text" id="global-search" placeholder="Search Transactions:" oninput="filterGlobalEntries()">
        </div>
        <div class="table">
          <table id="transactions-table">
            <thead>
              <tr>
                <th>Date</th>
                <th>Name</th>
                <th>Type</th>
                <th>Amount</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <!-- Transactions will be dynamically inserted here -->
            </tbody>
          </table>
        </div>
      </section>

      <p id="filtered-total">Filtered Total: $0.00</p>

      <section id="yearly-budget-calculator">
        <h2>Totals For Months</h2>
        <div class="visuals">
          <canvas id="monthlyBar"></canvas>
        </div>
        <div class="table">
          <table id="months-container">
            <thead>
              <tr>
                <th>Month</th>
                <th>Income</th>
                <th>Expenses</th>
                <th>Balance</th>
                <th>Add Income</th>
                <th>Add Expense</th>
              </tr>
            </thead>
            <tbody>
              <!-- Months will be populated here by JavaScript -->
            </tbody>
          </table>
        </div>

      </section>

      <section>
        <h2>Totals For Year:</h2>
        <table id="yearly-totals-table">
          <thead>
            <tr>
              <th>Total Transactions</th>
              <th>Total Income</th>
              <th>Total Expenses</th>
              <th>Total Balance</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td id="total-transactions">0</td>
              <td id="total-income">0</td>
              <td id="total-expenses">0</td>
              <td id="yearly-balance">0</td>
            </tr>
          </tbody>
        </table>

        <h2>Overall Totals:</h2>
        <table id="overall-totals-table">
          <thead>
            <tr>
              <th>Overall Income</th>
              <th>Overall Expenses</th>
              <th>Overall Balance</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td id="overall-income">0</td>
              <td id="overall-expenses">0</td>
              <td id="overall-balance">0</td>
            </tr>
          </tbody>
        </table>
        <div class="visuals">
          <canvas id="yearPie" height="120"></canvas>
        </div>
      </section>

    </section>

    <section>
      <div id="detailsModal">
        <div class="modal">
          <span id="closeModal">&times;</span>
          <h2><span id="date-selected"></span></h2>
          <div id="modalContent"></div>
        </div>
      </div>
    </section>

    <section id="daily-tracker">
      <h2>Daily Financial Tracker:</h2>
      <div id="year-grid" class="year-grid"></div>
    </section>

    <button id="export-details">Export Data (Backup)</button>
    <button id="trigger-import">Import JSON (Overwrite)</button>
    <input type="file" id="load-data" accept=".json" style="display:none">
    <button class="clear-button" id="clear-details">Delete Data</button>

    <p class="no-print"><a href="#top">Back to Top</a></p>

  </main>

  <script type="module">
    import { auth, onAuthStateChanged, database, ref, onValue, set, get, update } from './assets/js/firebase-init.js';

    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    let currentYear = new Date().getFullYear();
    let yearlyDetails = initializeYearlyDetails();
    let DATABASE_BASE_PATH = 'public';

    onAuthStateChanged(auth, (user) => {
      DATABASE_BASE_PATH = user ? `${user.uid}` : 'public';
      initApp();
    });

    function initApp() {
      setupEventListeners();
      fetchSavedData().then(savedData => {
        populateYearDropdown(savedData);
        fetchOverallTotals(savedData);
        yearlyDetails = aggregateMonthlyData(savedData, currentYear);
        populateMonths();
        calculateYearlyTotals();
        generateYearGrid();
        displayAllTransactions();
        renderCharts();
        handleYearChange();
      });
    }

    function initializeYearlyDetails() {
      return months.reduce((acc, month) => {
        acc[month] = { details: [] };
        return acc;
      }, {});
    }

    function setupEventListeners() {
      document.getElementById('export-details')?.addEventListener('click', exportDetailsToJSON);

      const triggerImportBtn = document.getElementById('trigger-import');
      if (triggerImportBtn) {
        triggerImportBtn.addEventListener('click', () => {
          document.getElementById('load-data').click();
        });
      }

      document.getElementById('load-data')?.addEventListener('change', importJSONReplaceExisting);
      document.getElementById('clear-details')?.addEventListener('click', clearDetails); document.getElementById('yearSelect').addEventListener('change', handleYearChange);
      document.getElementById('closeModal').onclick = closeModal;
      window.onclick = event => {
        if (event.target === document.getElementById('detailsModal')) {
          closeModal();
        }
      };
    }

    // === Charts: state & helpers ===
    let monthlyBarChart = null;
    let yearPieChart = null;

    function getMonthlyIncomeExpenses() {
      const income = Array(12).fill(0);
      const expenses = Array(12).fill(0);

      months.forEach((m, idx) => {
        const monthData = yearlyDetails[m] || { details: [] };
        monthData.details.forEach(d => {
          if (d.type === 'Income') income[idx] += d.amount || 0;
          if (d.type === 'Expenses') expenses[idx] += d.amount || 0;
        });
      });

      return { income, expenses };
    }

    function getYearTotals() {
      let totalIncome = 0, totalExpenses = 0;
      months.forEach(m => {
        const md = yearlyDetails[m] || { details: [] };
        md.details.forEach(d => {
          if (d.type === 'Income') totalIncome += d.amount || 0;
          if (d.type === 'Expenses') totalExpenses += d.amount || 0;
        });
      });
      return { totalIncome, totalExpenses };
    }

    function renderCharts() {
      // data
      const { income, expenses } = getMonthlyIncomeExpenses();
      const { totalIncome, totalExpenses } = getYearTotals();

      // labels like Jan..Dec
      const labels = months;

      // --- Monthly stacked bar ---
      const barCtx = document.getElementById('monthlyBar');
      if (monthlyBarChart) monthlyBarChart.destroy();
      monthlyBarChart = new Chart(barCtx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'Income',
              data: income
            },
            {
              label: 'Expenses',
              data: expenses
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: `Income vs Expenses by Month — ${currentYear}`
            },
            tooltip: { mode: 'index', intersect: false },
            legend: { position: 'top' }
          },
          scales: {
            x: { stacked: true },
            y: { stacked: true, beginAtZero: true }
          }
        }
      });

      // --- Year pie ---
      const pieCtx = document.getElementById('yearPie');
      if (yearPieChart) yearPieChart.destroy();
      yearPieChart = new Chart(pieCtx, {
        type: 'pie',
        data: {
          labels: ['Income', 'Expenses'],
          datasets: [
            {
              data: [totalIncome, totalExpenses]
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: `Income vs Expenses — ${currentYear}`
            },
            legend: { position: 'right' }
          }
        }
      });
    }

    function handleYearChange() {
      currentYear = parseInt(document.getElementById('yearSelect').value, 10);
      fetchSavedData().then(savedData => {
        yearlyDetails = aggregateMonthlyData(savedData, currentYear);
        populateMonths();
        calculateYearlyTotals();
        generateYearGrid();
        displayAllTransactions();
        renderCharts();
      });
    }

    function populateYearDropdown(savedData) {
      const yearSelect = document.getElementById('yearSelect');
      const years = getYearsFromData(savedData);
      if (years.length === 0) years.push(currentYear);
      years.sort((a, b) => a - b);
      yearSelect.innerHTML = years.map(y =>
        `<option value="${y}" ${y === currentYear ? 'selected' : ''}>${y}</option>`
      ).join('');
    }

    function getYearsFromData(data) {
      const years = new Set();
      Object.values(data).forEach(dayData => {
        if (dayData.details) {
          dayData.details.forEach(detail => {
            const year = new Date(detail.date).getFullYear();
            years.add(year);
          });
        }
      });
      return Array.from(years);
    }

    function aggregateMonthlyData(data, year) {
      const result = initializeYearlyDetails();
      const alias = { September: 'Sep', Sept: 'Sep', March: 'Mar', April: 'Apr', June: 'Jun', July: 'Jul' };

      Object.entries(data).forEach(([key, value]) => {
        let [month, day] = key.split('-');
        month = (alias[month] || month);       // normalize common variants
        const details = (value.details || []).filter(d => new Date(d.date).getFullYear() === year);

        if (!result[month]) result[month] = { details: [] };  // guard
        details.forEach(detail => result[month].details.push(detail));
      });
      return result;
    }

    function createButton(className, textContent, dataMonth, onClickCallback) {
      const button = document.createElement('button');
      button.className = className;
      button.textContent = textContent;
      if (dataMonth) button.setAttribute('data-month', dataMonth);
      button.addEventListener('click', onClickCallback);
      return button;
    }

    function populateMonths() {
      const monthsContainer = document.querySelector('#months-container tbody');
      monthsContainer.innerHTML = '';

      months.forEach(month => {
        const monthData = yearlyDetails[month];
        const income = calculateTotal(monthData.details, 'Income');
        const expenses = calculateTotal(monthData.details, 'Expenses');
        const balance = income - expenses;

        const row = monthsContainer.insertRow();
        row.innerHTML = `
            <td>${month}</td>
            <td>${income.toFixed(2)}</td>
            <td>${expenses.toFixed(2)}</td>
            <td>${balance.toFixed(2)}</td>
            <td></td>
            <td></td>
          `;

        row.cells[4].appendChild(createButton('add-income', 'Add Income', month, () => addEntry('Income', month)));
        row.cells[5].appendChild(createButton('add-expense', 'Add Expense', month, () => addEntry('Expenses', month)));
      });
    }

    function calculateTotal(details, type) {
      return details.filter(detail => detail.type === type).reduce((acc, detail) => acc + detail.amount, 0);
    }

    function addEntry(type, selectedMonth) {
      const name = prompt(`Enter a name for this ${type}:`);
      if (!name) return;

      const amount = parseFloat(prompt(`Enter ${type} amount:`));
      if (isNaN(amount)) return;

      let inputYear = parseInt(prompt(`Enter year (default is ${currentYear}):`), 10);
      if (isNaN(inputYear)) inputYear = currentYear;

      let inputDate = prompt(`Enter day of month for ${type} (1-31, default is today):`);
      let day = parseInt(inputDate, 10);
      if (isNaN(day) || day < 1 || day > 31) {
        console.warn("⚠️ Invalid day provided. Defaulting to today.");
        day = new Date().getDate();
      }

      if (isNaN(day) || day < 1 || day > 31) {
        console.warn("⚠️ Invalid day provided. Defaulting to today.");
        day = new Date().getDate();
      }

      const monthIndex = months.indexOf(selectedMonth);

      if (monthIndex === -1) {
        console.error("❌ Error: Invalid month selected.");
        alert("Invalid month selection. Please try again.");
        return;
      }

      if (!yearlyDetails[selectedMonth]) {
        console.warn(`⚠️ Creating new entry for month: ${selectedMonth}`);
        yearlyDetails[selectedMonth] = { details: [] };
      }

      let entryDate = new Date(inputYear, monthIndex, day);
      if (isNaN(entryDate.getTime())) {
        console.warn("⚠️ Invalid date detected. Defaulting to today.");
        entryDate = new Date();
      }

      const dateKey = `${selectedMonth}-${day}`;
      const newEntry = {
        name,
        type,
        amount,
        date: entryDate.toISOString()
      };

      yearlyDetails[selectedMonth].details.push(newEntry);

      fetchSavedData().then(savedData => {
        if (!savedData[dateKey]) {
          console.warn(`⚠️ No existing data for ${dateKey}, creating new entry.`);
          savedData[dateKey] = { details: [] };
        }
        savedData[dateKey].details.push(newEntry);
        saveData(savedData);
        initApp();
      });
    }

    function calculateYearlyTotals() {
      let totalIncome = 0, totalExpenses = 0, totalTransactions = 0;

      months.forEach(month => {
        if (yearlyDetails[month]) {
          totalIncome += calculateTotal(yearlyDetails[month].details, 'Income');
          totalExpenses += calculateTotal(yearlyDetails[month].details, 'Expenses');
          totalTransactions += yearlyDetails[month].details.length;
        }
      });

      document.getElementById('total-income').textContent = totalIncome.toFixed(2);
      document.getElementById('total-expenses').textContent = totalExpenses.toFixed(2);
      document.getElementById('yearly-balance').textContent = (totalIncome - totalExpenses).toFixed(2);

      document.getElementById('total-transactions').textContent = totalTransactions;
    }

    function fetchOverallTotals(savedData) {
      let overallIncome = 0, overallExpenses = 0;

      Object.values(savedData).forEach(dayData => {
        if (dayData.details) {
          overallIncome += calculateTotal(dayData.details, 'Income');
          overallExpenses += calculateTotal(dayData.details, 'Expenses');
        }
      });

      document.getElementById('overall-income').textContent = overallIncome.toFixed(2);
      document.getElementById('overall-expenses').textContent = overallExpenses.toFixed(2);
      document.getElementById('overall-balance').textContent = (overallIncome - overallExpenses).toFixed(2);
    }

    function generateYearGrid() {
      const yearGrid = document.getElementById('year-grid');
      yearGrid.innerHTML = '';

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const startOfYear = new Date(currentYear, 0, 1);
      const endOfYear = new Date(currentYear, 11, 31);

      fetchSavedData().then(savedData => {
        for (let day = startOfYear; day <= endOfYear; day.setDate(day.getDate() + 1)) {
          const dayFormatted = day.toISOString().split('T')[0];
          const monthName = months[day.getMonth()];
          const dayOfMonth = day.getDate();
          const dateKey = `${monthName}-${dayOfMonth}`;

          const details = (savedData[dateKey]?.details || []).filter(entry =>
            new Date(entry.date).getFullYear() === currentYear
          );

          let income = calculateTotal(details, 'Income');
          let expenses = calculateTotal(details, 'Expenses');

          if (day.getDate() === 1) {
            const monthLabel = document.createElement('div');
            monthLabel.textContent = monthName;
            monthLabel.style.gridColumn = "1 / -1";
            yearGrid.appendChild(monthLabel);
          }

          const dayBlock = document.createElement('div');
          dayBlock.className = 'day-block';
          dayBlock.textContent = dayOfMonth;
          dayBlock.setAttribute('data-date', dateKey);

          if (day.toDateString() === today.toDateString()) dayBlock.classList.add('today');

          if (details.length > 0) {
            if (expenses > income) {
              dayBlock.classList.add('expenses-higher');
            } else {
              dayBlock.classList.add('has-data');
            }
          }

          dayBlock.addEventListener('click', () => displayDayDetails(dateKey));
          yearGrid.appendChild(dayBlock);
        }
      });
    }

    function displayDayDetails(dateKey) {
      fetchSavedData().then(savedData => {
        const details = savedData[dateKey] || { details: [] };
        const modalContentElement = document.getElementById('modalContent');
        modalContentElement.innerHTML = '';

        const [month, day] = dateKey.split('-');
        const formattedDate = `${month} ${day}, ${currentYear}`;

        document.getElementById('date-selected').textContent = formattedDate;

        if (details.details.length > 0) {
          const filteredDetails = details.details.filter(detail => new Date(detail.date).getFullYear() === currentYear);

          const table = document.createElement('table');
          table.innerHTML = `
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Type</th>
                  <th>Amount</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody></tbody><br>
            `;

          const tbody = table.querySelector('tbody');

          filteredDetails.forEach((detail, index) => {
            const row = document.createElement('tr');

            row.innerHTML = `
                <td contenteditable="true" data-key="name">${detail.name}</td>
                <td>${detail.type}</td>
                <td contenteditable="true" data-key="amount">${detail.amount}</td>
                <td><button class="clear-button" onclick="deleteEntry('${dateKey}', ${index})">Delete</button></td>
              `;

            row.querySelectorAll('[contenteditable="true"]').forEach(cell => {
              cell.addEventListener('blur', (event) => {
                updateEntry(dateKey, index, event.target.dataset.key, event.target.innerText);
              });
            });

            tbody.appendChild(row);
          });

          modalContentElement.appendChild(table);
        } else {
          modalContentElement.innerHTML = "<p>No details available for this date.</p>";
        }

        modalContentElement.appendChild(createButton('', 'Add Income', null, () => addEntryFromModal(dateKey, 'Income')));
        modalContentElement.appendChild(createButton('', 'Add Expense', null, () => addEntryFromModal(dateKey, 'Expenses')));

        document.getElementById('detailsModal').style.display = 'block';
      });
    }

    function addEntryFromModal(dateKey, type) {
      const name = prompt(`Enter a name for this ${type}:`);
      if (!name) return;

      const amount = parseFloat(prompt(`Enter ${type} amount:`));
      if (isNaN(amount)) return;

      const [month, day] = dateKey.split('-');
      let inputYear = parseInt(prompt(`Enter year (default is ${currentYear}):`), 10);
      if (isNaN(inputYear)) inputYear = currentYear;

      const newEntry = {
        name,
        type,
        amount,
        date: new Date(inputYear, months.indexOf(month), day).toISOString()
      };

      fetchSavedData().then(savedData => {
        if (!savedData[dateKey]) savedData[dateKey] = { details: [] };
        savedData[dateKey].details.push(newEntry);
        saveData(savedData);
        initApp();
        displayDayDetails(dateKey);
      });
    }

    window.deleteEntry = async function deleteEntry(dateKey, entryIndex) {
      if (!confirm("Are you sure you want to delete this entry?")) return;

      try {
        let savedData = await fetchSavedData();

        if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
          const filteredEntries = savedData[dateKey].details.filter(detail =>
            new Date(detail.date).getFullYear() === currentYear
          );

          if (filteredEntries.length > entryIndex) {
            const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
            if (globalIndex !== -1) {
              savedData[dateKey].details.splice(globalIndex, 1);
            }

            if (savedData[dateKey].details.length === 0) {
              delete savedData[dateKey];
            }

            await saveData(savedData);
            console.log(`✅ Successfully deleted entry from ${dateKey} (${currentYear})`);

            initApp();
            displayDayDetails(dateKey);
          } else {
            console.warn("⚠️ No entry found for deletion in the current year.");
          }
        } else {
          console.warn("⚠️ No entry found for deletion or index out of bounds.");
        }
      } catch (error) {
        console.error("❌ Error fetching or updating saved data:", error);
      }
    };

    async function updateEntry(dateKey, entryIndex, field, newValue) {
      let savedData = await fetchSavedData();

      if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
        const filteredEntries = savedData[dateKey].details.filter(detail =>
          new Date(detail.date).getFullYear() === currentYear
        );

        if (filteredEntries.length > entryIndex) {
          const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
          if (globalIndex !== -1) {
            if (field === "amount") {
              newValue = parseFloat(newValue);
              if (isNaN(newValue)) return;
            }

            savedData[dateKey].details[globalIndex][field] = newValue;

            await saveData(savedData);
          }
        }
      }
    }

    async function loadJSONData(event) {
      const file = event.target.files[0];
      if (file && file.type === "application/json") {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          mergeAndUpdateData(data);
          event.target.value = '';
        } catch (error) {
          console.error("Error reading or parsing file", error);
          alert("Failed to load data. Please ensure the file is a valid JSON format.");
        }
      } else {
        alert("Please select a JSON file.");
      }
    }

    function mergeAndUpdateData(newData) {
      fetchSavedData().then(savedData => {
        Object.keys(newData).forEach(key => {
          if (!savedData[key]) savedData[key] = { details: [] };
          savedData[key].details = [...savedData[key].details, ...newData[key].details];
        });
        saveData(savedData);
      });
    }

    function clearDetails() {
      if (confirm("Are you sure you want to clear all data? This cannot be undone.")) {
        set(ref(database, `${DATABASE_BASE_PATH}/budget`), {});
        alert("All data has been cleared.");
        initApp();
      }
    }

    async function fetchSavedData() {
      try {
        const snapshot = await get(ref(database, `${DATABASE_BASE_PATH}/budget`));
        return snapshot.exists() ? snapshot.val() : {};
      } catch (error) {
        console.error("❌ Error fetching saved data:", error);
        return {};
      }
    }

    function saveData(data) {
      set(ref(database, `${DATABASE_BASE_PATH}/budget`), data);
    }

    function closeModal() {
      document.getElementById('detailsModal').style.display = "none";
    }

    function displayAllTransactions() {
      fetchSavedData().then(savedData => {
        const tbody = document.querySelector('#transactions-table tbody');
        tbody.innerHTML = '';

        const searchBox = document.getElementById('global-search');
        const searchValue = (searchBox ? searchBox.value : '').toLowerCase();

        const filteredForTotals = []; // use this for filtered total

        const rows = [];

        Object.entries(savedData).forEach(([dateKey, data]) => {
          const details = (data.details || []).filter(d =>
            new Date(d.date).getFullYear() === currentYear
          );

          details.forEach((detail, index) => {
            const [monthName, dayStr] = dateKey.split('-');
            const monthIndex = months.indexOf(monthName);
            const dateObject = new Date(currentYear, monthIndex, parseInt(dayStr, 10));

            const name = (detail.name || '').toLowerCase();
            const type = (detail.type || '').toLowerCase();
            const amountStr = (detail.amount ?? 0).toString().toLowerCase();

            const matches =
              dateKey.toLowerCase().includes(searchValue) ||
              name.includes(searchValue) ||
              type.includes(searchValue) ||
              amountStr.includes(searchValue);

            if (matches) {
              rows.push({
                dateKey,
                dateObject,
                index,
                detail
              });
              filteredForTotals.push(detail);
            }
          });
        });

        rows.sort((a, b) => a.dateObject - b.dateObject);

        rows.forEach(({ dateKey, index, detail }) => {
          const tr = document.createElement('tr');
          tr.classList.add('transaction-row');

          // Date
          const tdDate = document.createElement('td');
          tdDate.textContent = dateKey;

          // Name (editable)
          const tdName = document.createElement('td');
          tdName.contentEditable = 'true';
          tdName.dataset.key = 'name';
          tdName.textContent = detail.name || 'Unknown';
          tdName.addEventListener('blur', e => {
            updateTransactionEntry(dateKey, index, 'name', e.target.innerText);
          });

          // Type (dropdown)
          const tdType = document.createElement('td');
          tdType.appendChild(
            createTypeSelect(detail.type || 'Expenses', async newVal => {
              await updateTransactionEntry(dateKey, index, 'type', newVal);
              handleYearChange(); // keep totals/tiles in sync
            })
          );

          // Amount (editable)
          const tdAmount = document.createElement('td');
          tdAmount.contentEditable = 'true';
          tdAmount.dataset.key = 'amount';
          tdAmount.textContent = (detail.amount ?? 0).toFixed(2);
          tdAmount.addEventListener('blur', e => {
            let v = parseFloat(e.target.innerText.replace(/[^\d.-]/g, ''));
            if (isNaN(v)) {
              e.target.textContent = (detail.amount ?? 0).toFixed(2);
              return;
            }
            e.target.textContent = v.toFixed(2);
            updateTransactionEntry(dateKey, index, 'amount', v);
          });

          // Actions (Delete)
          const tdActions = document.createElement('td');
          const delBtn = document.createElement('button');
          delBtn.className = 'clear-button';
          delBtn.textContent = 'x';
          delBtn.addEventListener('click', () => {
            deleteTransactionEntry(dateKey, index);
          });
          tdActions.appendChild(delBtn);

          tr.appendChild(tdDate);
          tr.appendChild(tdName);
          tr.appendChild(tdType);
          tr.appendChild(tdAmount);
          tr.appendChild(tdActions);
          tbody.appendChild(tr);
        });

        updateFilteredTotal(filteredForTotals);
      });
    }

    window.filterGlobalEntries = function filterGlobalEntries() {
      displayAllTransactions();
    };

    async function updateTransactionEntry(dateKey, entryIndex, field, newValue) {
      let savedData = await fetchSavedData();

      if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
        const filteredEntries = savedData[dateKey].details.filter(detail =>
          new Date(detail.date).getFullYear() === currentYear
        );

        if (filteredEntries.length > entryIndex) {
          const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
          if (globalIndex !== -1) {
            if (field === "amount") {
              newValue = parseFloat(newValue);
              if (isNaN(newValue)) return;
            }

            savedData[dateKey].details[globalIndex][field] = newValue;

            await saveData(savedData);

            const fresh = await fetchSavedData();
            fetchOverallTotals(fresh);
            handleYearChange();
          }
        }
      }
    }

    function updateFilteredTotal(filteredData) {
      let totalIncome = 0;
      let totalExpenses = 0;

      filteredData.forEach(detail => {
        if (detail.type === 'Income') {
          totalIncome += detail.amount;
        } else if (detail.type === 'Expenses') {
          totalExpenses += detail.amount;
        }
      });

      const filteredTotal = totalExpenses - totalIncome;
      document.getElementById('filtered-total').textContent = `Filtered Total: $${filteredTotal.toFixed(2)}`;
    }

    function createTypeSelect(currentType, onChange) {
      const sel = document.createElement('select');
      ['Income', 'Expenses'].forEach(optVal => {
        const opt = document.createElement('option');
        opt.value = optVal;
        opt.textContent = optVal;
        if ((currentType || '').toLowerCase() === optVal.toLowerCase()) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', e => onChange(e.target.value));
      return sel;
    }

    window.deleteTransactionEntry = async function deleteTransactionEntry(dateKey, entryIndex) {
      if (!confirm("Are you sure you want to delete this entry?")) return;

      try {
        let savedData = await fetchSavedData();

        if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
          // keep behavior consistent with updateTransactionEntry: map "filtered index" -> global index
          const filteredEntries = savedData[dateKey].details.filter(detail =>
            new Date(detail.date).getFullYear() === currentYear
          );

          if (filteredEntries.length > entryIndex) {
            const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
            if (globalIndex !== -1) {
              savedData[dateKey].details.splice(globalIndex, 1);
            }

            // remove empty day bucket
            if (savedData[dateKey].details.length === 0) {
              delete savedData[dateKey];
            }

            await saveData(savedData);

            // refresh UI: totals, grid, and table
            handleYearChange();
            displayAllTransactions();
          } else {
            console.warn("⚠️ No entry found for deletion in the current year.");
          }
        } else {
          console.warn("⚠️ No entry found for deletion or index out of bounds.");
        }
      } catch (error) {
        console.error("❌ Error deleting entry:", error);
      }
    };


    function exportDetailsToJSON() {
      fetchSavedData().then(savedData => {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(savedData, null, 2));
        const a = document.createElement('a');
        a.setAttribute("href", dataStr);
        a.setAttribute("download", `financial_tracker_backup_${new Date().toISOString().slice(0, 10)}.json`);
        document.body.appendChild(a);
        a.click();
        a.remove();
      });
    }

    /**
     * Import a JSON file and REPLACE existing data at `${DATABASE_BASE_PATH}/budget`.
     * Shows strong warnings and double confirmation.
     */
    async function importJSONReplaceExisting(event) {
      const file = event.target.files?.[0];
      // reset the input right away so user can pick the same file again if needed
      event.target.value = '';

      if (!file) return;

      // ⚠️ Strong warning first
      const warned = confirm(
        "⚠️ WARNING: Importing will REPLACE all current data.\n\n" +
        "Please export a BACKUP first (use the Export button).\n\n" +
        "Click OK to continue to file validation, or Cancel to stop."
      );
      if (!warned) return;

      // Read + parse
      let parsed;
      try {
        const text = await file.text();
        parsed = JSON.parse(text);
      } catch (err) {
        console.error("Failed to read/parse JSON:", err);
        alert("❌ Failed to read or parse the JSON file. Make sure it's valid JSON.");
        return;
      }

      // Basic validation (lightweight & defensive)
      const isObj = parsed && typeof parsed === 'object' && !Array.isArray(parsed);
      if (!isObj) {
        alert("❌ Invalid format: root must be an object of { 'Mon-1': { details: [...] }, ... }");
        return;
      }

      // Optional: sanity check counts for UX feedback
      let dayBuckets = 0, entries = 0;
      try {
        Object.values(parsed).forEach(v => {
          dayBuckets++;
          const arr = (v && Array.isArray(v.details)) ? v.details : [];
          entries += arr.length;
        });
      } catch (_) {
        // not fatal
      }

      // Final confirmation before overwrite
      const confirmReplace = confirm(
        `This will OVERWRITE existing data at "Budget".\n\n` +
        `About to import ~${dayBuckets} day buckets and ~${entries} entries.\n\n` +
        "Are you sure? Click OK to replace, or Cancel to abort."
      );
      if (!confirmReplace) return;

      try {
        await set(ref(database, `${DATABASE_BASE_PATH}/budget`), parsed);
        alert("✅ Import complete. Data has been replaced.");
        initApp(); // refresh everything
      } catch (err) {
        console.error("Error writing imported data:", err);
        alert("❌ Failed to write imported data. See console for details.");
      }
    }

  </script>
</body>

</html>