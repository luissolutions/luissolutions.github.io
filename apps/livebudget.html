<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Budget Planner</title>
  <link rel="stylesheet" href="../assets/css/app-styles.css" />
  <style>
    .grid {
      display: grid;
      grid-row: max-content;
    }

    .muted {
      opacity: .75;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      border: 1px solid #e3e3e3;
      padding: 6px 8px;
      text-align: right;
    }

    th.sticky {
      position: sticky;
      top: 0;
      background: #fafafa;
      z-index: 2;
    }

    td:first-child,
    th:first-child {
      text-align: left;
      position: sticky;
      left: 0;
      z-index: 1;
      background: #fff;
    }

    thead th:first-child {
      background: #fafafa;
    }

    .ok {
      color: #10893e;
    }

    .warn {
      color: #b71c1c;
    }

    input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      padding: 6px;
    }

    input[type="text"] {
      width: 100%;
      box-sizing: border-box;
      padding: 6px;
    }


    .small {
      font-size: .9rem;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
    }

    .light-under {
      background: lightblue;
    }

    .light-over {
      background: lightcoral;
    }
  </style>
  <script type="module" src="./assets/js/login.js"></script>
</head>

<body>
  <header>
    <div>
      <h1>Budget Planner</h1>
      <p class="muted">Plan monthly budgets for next year, enter actuals each month, and see variances live.</p>
    </div>
    <section id="login-section">
      <form id="login-form">
        <label for="username">Email:</label>
        <input type="email" id="username" required>
        <br>
        <label for="password">Password:</label>
        <input type="password" id="password" required>
        <br>
        <button type="submit">Login</button>
      </form>
      <button id="logout" style="display: none;">Logout</button>
    </section>
  </header>

  <main>
    <section>
      <div>

        <label title="Gross income you expect for this year">
          Expected Yearly Income:
          <input id="incomeYear" type="number" min="0" step="0.01" style="width:12ch;" />
        </label>

        <button id="save">Save now</button>
        <button id="export-csv">Export CSV</button>
        <button id="reset-defaults" style="display: none;">Reset to defaults</button>
        <button id="sync-from-tracker">Sync from Financial Data</button>
        <br>
        <label>Year:
          <select id="year"></select>
        </label>
        <button id="add-year">+ Add Year</button>

      </div>
      <div id="yearTotals"></div>
    </section>
    <section class="card">
      <h2>Categories & Base Monthly Budgets</h2>
      <p>Tip: adjust a category's <strong>Monthly Budget</strong> to change all months at once. In
        the big table, you can override specific months for a category.</p>
      <div id="cats" class="grid table" style="gap:14px"></div>
    </section>
    <br>
    <section class="table">
      <h2>Budget vs Actual (by Month)</h2>
      <table id="budget-table">
        <thead>
          <tr id="budget-header-row">
            <!-- header cells injected by JS -->
          </tr>
        </thead>
        <tbody></tbody>
        <tfoot></tfoot>
      </table>
    </section>
  </main>

  <footer>
    <p>• <strong>Budget cells</strong> (first line per category) are editable and act as per-month overrides.<br>
      • <strong>Actual cells</strong> (second line) are where you type what you actually spent.<br>
      • The right panel shows <strong>live totals</strong> and <strong>variance</strong> (green is under budget).
    </p>
  </footer>
</body>

<script type="module">
  import { auth, onAuthStateChanged, database, ref, get, set } from './assets/js/firebase-init.js';

  /* ============ Config & Constants ============ */
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  const DEFAULT_BASE = {
    year: new Date().getUTCFullYear() + 1,
    incomeYear: 0,
    categories: [
      { name: 'Rent/Main bills', monthly: 830.00 },
      { name: 'Phone', monthly: 80.00 },
      { name: 'Vehicle gas', monthly: 140.00 },
      { name: 'Groceries', monthly: 140.00 },
      { name: 'Restaurants', monthly: 140.00 },
      { name: 'Entertainment', monthly: 50.00 },
      { name: 'Insurance', monthly: 170.00 },
    ],
    budgetOverrides: {},
    actuals: {}
  };

  // Optional: where the Financial Tracker lives (only used by sync function)
  const FIN_TRACKER_PATH = (basePath) => `${basePath}/budget`;
  const MULTITAG_MODE = "split";
  const UNTITLED_CATEGORY = "Uncategorized";

  // Firebase RTDB forbidden chars in keys
  const FORBIDDEN = /[.#$/[\]]/g;
  const safeKey = (s) => String(s ?? '').replace(FORBIDDEN, '_');

  /* ============ State ============ */
  let DATABASE_BASE_PATH = 'public';
  let STATE = structuredClone(DEFAULT_BASE);
  let DOM_READY = false;
  let AUTH_READY = false;

  /* ============ Helpers ============ */
  const fmt = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });
  const yearPrefKey = () => `${DATABASE_BASE_PATH}:budget:lastYear`;

  function monthsElapsedForYear(y) {
    const now = new Date();
    const currY = now.getUTCFullYear();
    if (y < currY) return 12;
    if (y > currY) return 0;
    return now.getUTCMonth() + 1;
  }

  function hasActual(catName, mi) {
    const mKey = months[mi];
    const v = STATE.actuals?.[mKey]?.[catName];
    return v !== undefined && v !== null && String(v) !== '';
  }

  function avgBudgetForCategory(catName) {
    let sum = 0;
    for (let mi = 0; mi < 12; mi++) sum += planForMonth(catName, mi);
    return sum / 12;
  }

  function avgActualForCategory(catName) {
    const limit = monthsElapsedForYear(Number(STATE.year)); // 0..12
    let sum = 0, count = 0;

    for (let mi = 0; mi < limit; mi++) {
      sum += toMoney(actualForMonth(catName, mi)); // missing -> 0
      count++;
    }

    for (let mi = limit; mi < 12; mi++) {
      if (hasActual(catName, mi)) {
        sum += toMoney(actualForMonth(catName, mi));
        count++;
      }
    }

    return count ? (sum / count) : null;
  }

  function saveLastYear(y) {
    try { localStorage.setItem(yearPrefKey(), String(y)); } catch { }
  }

  function loadLastYear() {
    try {
      const v = localStorage.getItem(yearPrefKey());
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    } catch { return null; }
  }

  // Footer avg denominator: elapsed months + future months that have ANY actual value (across any category)
  function countMonthsForTotalsAvg() {
    const limit = monthsElapsedForYear(Number(STATE.year));
    let extra = 0;
    for (let mi = limit; mi < 12; mi++) {
      if (STATE.categories.some(c => hasActual(c.name, mi))) extra++;
    }
    return limit + extra;
  }

  // robust money parser: strips commas, spaces, currency signs, etc. and rounds to 2dp
  function toMoney(v) {
    const n = Number(String(v ?? '').replace(/[^0-9.\-]/g, ''));
    if (!Number.isFinite(n)) return 0;
    if (Math.abs(n) > 1e9) return 0;
    return Math.round(n * 100) / 100;
  }

  const buildNameMap = (state) =>
    Object.fromEntries((state.categories || []).map(c => [safeKey(c.name), c.name]));

  function ensureShapes() {
    if (!Array.isArray(STATE.categories)) STATE.categories = [];
    STATE.budgetOverrides ||= {};
    STATE.actuals ||= {};
    if (typeof STATE.incomeYear !== 'number') STATE.incomeYear = 0;
  }

  // UTC month/year from ISO
  function ymFromISO(iso) {
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return null;
    return { y: d.getUTCFullYear(), m: d.getUTCMonth() }; // 0..11
  }

  function ensureCategory(catName) {
    if (!catName) return;
    if (!STATE.categories.some(c => c.name === catName)) {
      STATE.categories.push({ name: catName, monthly: 0 });
    }
  }

  /* ============ Encode/Decode for DB (sanitized keys) ============ */
  function encodeForDB(state) {
    const out = structuredClone(state);
    const nameMap = buildNameMap(state);
    out._nameMap = nameMap;

    // actuals: actuals[month][safeCat] = value
    const encActuals = {};
    for (const m of Object.keys(out.actuals || {})) {
      const monthObj = out.actuals[m] || {};
      const encMonth = {};
      for (const [catName, val] of Object.entries(monthObj)) {
        encMonth[safeKey(catName)] = toMoney(val);
      }
      encActuals[m] = encMonth;
    }
    out.actuals = encActuals;

    // overrides: "<safeCat>::<mIndex>" = value
    const encOverrides = {};
    for (const [k, val] of Object.entries(out.budgetOverrides || {})) {
      const idx = k.lastIndexOf('::');
      if (idx > -1) {
        const cat = k.slice(0, idx);
        const mi = k.slice(idx + 2);
        encOverrides[`${safeKey(cat)}::${mi}`] = toMoney(val);
      } else {
        encOverrides[safeKey(k)] = toMoney(val);
      }
    }
    out.budgetOverrides = encOverrides;

    return out;
  }

  function decodeFromDB(obj, targetYear) {
    if (!obj) return null;
    const nameMap = obj._nameMap || {};
    const revName = (safe) => nameMap[safe] || safe;

    const out = structuredClone(obj);
    out.year = Number(targetYear);

    // actuals
    const decActuals = {};
    for (const m of Object.keys(out.actuals || {})) {
      const monthObj = out.actuals[m] || {};
      const decMonth = {};
      for (const [safeCat, val] of Object.entries(monthObj)) {
        decMonth[revName(safeCat)] = toMoney(val);
      }
      decActuals[m] = decMonth;
    }
    out.actuals = decActuals;

    // overrides
    const decOverrides = {};
    for (const [k, val] of Object.entries(out.budgetOverrides || {})) {
      const idx = k.lastIndexOf('::');
      if (idx > -1) {
        const safeCat = k.slice(0, idx);
        const mi = k.slice(idx + 2);
        decOverrides[`${revName(safeCat)}::${mi}`] = toMoney(val);
      } else {
        decOverrides[revName(k)] = toMoney(val);
      }
    }
    out.budgetOverrides = decOverrides;

    delete out._nameMap;
    return out;
  }

  async function loadFromDB() {
    const yearSel = document.getElementById('year');
    const wantYear = Number(yearSel?.value || DEFAULT_BASE.year);
    const snap = await get(ref(database, `${DATABASE_BASE_PATH}/budgetPlan/${wantYear}`));
    if (snap.exists()) {
      STATE = decodeFromDB(snap.val(), wantYear);
    } else {
      STATE = structuredClone(DEFAULT_BASE);
      STATE.year = wantYear;
    }
    ensureShapes();
  }

  async function saveToDB() {
    try {
      const toWrite = encodeForDB(STATE);
      await set(ref(database, `${DATABASE_BASE_PATH}/budgetPlan/${STATE.year}`), toWrite);
    } catch (e) {
      console.error('Save failed', e);
    }
  }

  /* ============ Budget Math ============ */
  function planForMonth(catName, mIndex) {
    const key = `${catName}::${mIndex}`;
    const ov = STATE.budgetOverrides[key];
    if (ov != null) return toMoney(ov);
    const cat = STATE.categories.find(c => c.name === catName);
    return toMoney(cat?.monthly);
  }

  function actualForMonth(catName, mIndex) {
    const mKey = months[mIndex];
    return toMoney(STATE.actuals?.[mKey]?.[catName]);
  }

  function setActual(catName, mIndex, val) {
    const mKey = months[mIndex];
    STATE.actuals[mKey] ||= {};
    STATE.actuals[mKey][catName] = toMoney(val);
  }

  function setBudgetMonthly(catName, monthly) {
    const cat = STATE.categories.find(c => c.name === catName);
    if (cat) cat.monthly = toMoney(monthly);
  }

  function setBudgetOverride(catName, mIndex, val) {
    const key = `${catName}::${mIndex}`;
    if (val === '' || val == null) delete STATE.budgetOverrides[key];
    else STATE.budgetOverrides[key] = toMoney(val);
  }

  function categoryTotals(catName) {
    let budget = 0, actual = 0;
    for (let mi = 0; mi < 12; mi++) {
      budget += planForMonth(catName, mi);
      actual += actualForMonth(catName, mi);
    }
    return { budget, actual };
  }

  function totals() {
    const perMonth = months.map((_, mi) => {
      let budget = 0, actual = 0;
      for (const c of STATE.categories) {
        budget += planForMonth(c.name, mi);
        actual += actualForMonth(c.name, mi);
      }
      return { budget, actual, variance: actual - budget };
    });
    const yearBudget = perMonth.reduce((s, m) => s + m.budget, 0);
    const yearActual = perMonth.reduce((s, m) => s + m.actual, 0);
    return { perMonth, yearBudget, yearActual, yearVariance: yearActual - yearBudget };
  }

  /* ============ UI Rendering ============ */
  function renderHeader() {
    const hdr = document.getElementById('budget-header-row');
    if (!hdr) return;
    hdr.innerHTML =
      '<th class="sticky">Category</th>' +
      months.map(m => `<th class="sticky">${m}</th>`).join('') +
      `<th class="sticky">Avg</th>`;
  }

  function setActualCellColor(td, catName, mi) {
    const a = actualForMonth(catName, mi);
    const b = planForMonth(catName, mi);
    td.classList.remove('light-under', 'light-over');
    if (td.querySelector('input')?.value === '') return;
    td.classList.add(a <= b ? 'light-under' : 'light-over');
  }

  // NEW: color the Avg (Actual) cell vs Avg (Budget)
  function setAvgActualCellColor(td, catName) {
    const a = avgActualForCategory(catName);
    const b = avgBudgetForCategory(catName);
    td.classList.remove('ok', 'warn');
    if (a == null) return;
    td.classList.add(a <= b ? 'ok' : 'warn');
  }

  function updateCategoryLabelByIndex(idx) {
    const tbody = document.querySelector('#budget-table tbody');
    if (!tbody) return;
    const cat = STATE.categories[idx];
    if (!cat) return;
    const { budget, actual } = categoryTotals(cat.name);

    const budgetRow = tbody.querySelector(`tr[data-idx="${idx}"][data-kind="budget"] td:first-child`);
    const actualRow = tbody.querySelector(`tr[data-idx="${idx}"][data-kind="actual"] td:first-child`);

    if (budgetRow) budgetRow.textContent = `${cat.name} (${fmt.format(budget)})`;
    if (actualRow) actualRow.innerHTML = `<span class="muted">Actual — ${cat.name} (${fmt.format(actual)})</span>`;
  }

  function renderCategoriesEditor() {
    const wrap = document.getElementById('cats');
    if (!wrap) return;
    wrap.innerHTML = '';

    STATE.categories.forEach((c, idx) => {
      const row = document.createElement('div');
      row.className = 'grid';
      row.innerHTML = `
        <div>
          <label class="small">Category</label>
          <div><input type="text" value="${c.name}" /></div>
        </div>
        <div>
          <label class="small">Monthly Budget</label>
          <input type="number" min="0" step="0.01" value="${c.monthly}" />
        </div>
        <button type="button" class="btn clear-button small del-cat" title="Delete category">X</button>
      `;

      const [nameEl, monthlyEl] = row.querySelectorAll('input');

      nameEl.addEventListener('blur', () => {
        const newName = nameEl.value.trim() || `Category ${idx + 1}`;
        if (newName !== c.name) {
          for (let mi = 0; mi < months.length; mi++) {
            const oldKey = `${c.name}::${mi}`;
            const newKey = `${newName}::${mi}`;
            if (STATE.budgetOverrides[oldKey] != null) {
              STATE.budgetOverrides[newKey] = STATE.budgetOverrides[oldKey];
              delete STATE.budgetOverrides[oldKey];
            }
            const mKey = months[mi];
            if (STATE.actuals[mKey]?.[c.name] != null) {
              STATE.actuals[mKey][newName] = STATE.actuals[mKey][c.name];
              delete STATE.actuals[mKey][c.name];
            }
          }
          c.name = newName;
          saveToDB();
          renderAll();
        }
      });

      monthlyEl.addEventListener('input', () => {
        setBudgetMonthly(c.name, monthlyEl.value);
        renderBudgetTable();
        renderMonthTotals();
        renderYearTotals();
      });

      const delBtn = row.querySelector('.del-cat');
      delBtn.addEventListener('click', () => deleteCategory(c.name));

      wrap.appendChild(row);
    });

    const add = document.createElement('button');
    add.className = 'btn';
    add.textContent = '+ Add Category';
    add.addEventListener('click', () => {
      STATE.categories.push({ name: `Category ${STATE.categories.length + 1}`, monthly: 0 });
      renderAll();
      saveToDB();
    });
    wrap.appendChild(add);
  }

  function renderBudgetTable() {
    const tbody = document.querySelector('#budget-table tbody');
    if (!tbody) return;
    tbody.innerHTML = '';

    STATE.categories.forEach((c, idx) => {
      const { budget, actual } = categoryTotals(c.name);

      // ===== Budget row =====
      const tr = document.createElement('tr');
      tr.dataset.idx = idx;
      tr.dataset.kind = 'budget';

      const nameTd = document.createElement('td');
      nameTd.textContent = `${c.name} (${fmt.format(budget)})`;
      tr.appendChild(nameTd);

      months.forEach((m, mi) => {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'number'; input.min = '0'; input.step = '0.01';
        input.value = planForMonth(c.name, mi);
        input.title = 'Budget (override this month). Leave blank to use category monthly.';
        input.addEventListener('input', () => {
          const v = input.value;
          if (v === '') setBudgetOverride(c.name, mi, '');
          else setBudgetOverride(c.name, mi, v);
          updateCategoryLabelByIndex(idx);
          const actualCell = tbody.querySelector(`tr[data-idx="${idx}"][data-kind="actual"] td[data-mi="${mi}"]`);
          if (actualCell) setActualCellColor(actualCell, c.name, mi);
          renderMonthTotals();
          renderYearTotals();
          avgBudTd.textContent = fmt.format(avgBudgetForCategory(c.name));
          const avgActTdRef = tbody.querySelector(`tr[data-idx="${idx}"][data-kind="actual"] td:last-child`);
          if (avgActTdRef) setAvgActualCellColor(avgActTdRef, c.name);
        });
        td.appendChild(input);
        tr.appendChild(td);
      });

      // Budget Avg cell
      const avgBudTd = document.createElement('td');
      avgBudTd.textContent = fmt.format(avgBudgetForCategory(c.name));
      tr.appendChild(avgBudTd);

      // ===== Actuals row =====
      const tr2 = document.createElement('tr');
      tr2.dataset.idx = idx;
      tr2.dataset.kind = 'actual';

      const name2 = document.createElement('td');
      name2.innerHTML = `<span class="muted">Actual — ${c.name} (${fmt.format(actual)})</span>`;
      tr2.appendChild(name2);

      months.forEach((m, mi) => {
        const td = document.createElement('td');
        td.setAttribute('data-mi', mi);
        const input = document.createElement('input');
        input.type = 'number'; input.min = '0'; input.step = '0.01';
        const mKey = months[mi];
        const hasVal =
          STATE.actuals?.[mKey] &&
          Object.prototype.hasOwnProperty.call(STATE.actuals[mKey], c.name);
        input.value = hasVal ? STATE.actuals[mKey][c.name] : '';
        input.placeholder = '0.00';
        input.addEventListener('input', () => {
          const val = input.value;
          const mKey = months[mi];
          if (val === '') {
            if (STATE.actuals?.[mKey]) delete STATE.actuals[mKey][c.name];
          } else {
            setActual(c.name, mi, val);
          }
          setActualCellColor(td, c.name, mi);
          updateCategoryLabelByIndex(idx);
          renderMonthTotals();
          renderYearTotals();
          const a = avgActualForCategory(c.name);
          avgActTd.textContent = (a == null) ? '—' : fmt.format(a);
          setAvgActualCellColor(avgActTd, c.name);
        });
        td.appendChild(input);
        setActualCellColor(td, c.name, mi);
        tr2.appendChild(td);
      });

      const avgActTd = document.createElement('td');
      const initialAvgActual = avgActualForCategory(c.name);
      avgActTd.textContent = (initialAvgActual == null) ? '—' : fmt.format(initialAvgActual);
      setAvgActualCellColor(avgActTd, c.name);
      tr2.appendChild(avgActTd);

      tbody.appendChild(tr);
      tbody.appendChild(tr2);
    });
  }

  function renderMonthTotals() {
    const tfoot = document.querySelector('#budget-table tfoot');
    if (!tfoot) return;
    tfoot.innerHTML = '';
    const { perMonth, yearBudget, yearActual } = totals();

    const monthsCount = countMonthsForTotalsAvg();

    const trBudget = document.createElement('tr');
    trBudget.className = 'totals';
    trBudget.innerHTML =
      `<td>Monthly Budget Total</td>` +
      perMonth.map(m => `<td>${fmt.format(m.budget)}</td>`).join('') +
      `<td>${monthsCount ? fmt.format(yearBudget / monthsCount) : '—'}</td>`;

    const trActual = document.createElement('tr');
    trActual.className = 'totals';
    trActual.innerHTML =
      `<td>Monthly Actual Total</td>` +
      perMonth.map(m => `<td>${fmt.format(m.actual)}</td>`).join('') +
      `<td>${monthsCount ? fmt.format(yearActual / monthsCount) : '—'}</td>`;

    const trVar = document.createElement('tr');
    trVar.className = 'totals';
    const yearVariance = yearActual - yearBudget;
    trVar.innerHTML =
      `<td>Variance (Actual - Budget)</td>` +
      perMonth.map(m => {
        const cls = m.variance <= 0 ? 'ok' : 'warn';
        return `<td class="${cls}">${fmt.format(m.variance)}</td>`;
      }).join('') +
      `<td class="${(yearVariance <= 0 ? 'ok' : 'warn')}">` +
      `${monthsCount ? fmt.format(yearVariance / monthsCount) : '—'}</td>`;

    tfoot.appendChild(trBudget);
    tfoot.appendChild(trActual);
    tfoot.appendChild(trVar);
  }

  function renderYearTotals() {
    const box = document.getElementById('yearTotals');
    if (!box) return;

    const { yearBudget, yearActual, yearVariance } = totals();
    const yearIncome = Math.max(0, toMoney(STATE.incomeYear));
    const netVsBudget = yearIncome - yearBudget;
    const netVsActual = yearIncome - yearActual;

    box.innerHTML = `
      <div>Expected Income: <strong>${fmt.format(yearIncome)}</strong></div>
      <hr>
      <div>Budgeted Expenses: <strong>${fmt.format(yearBudget)}</strong></div>
      <div>Actual Expenses: <strong>${fmt.format(yearActual)}</strong></div>
      <div>Expense Variance (Actual − Budget):
        <strong class="${(yearActual - yearBudget) <= 0 ? 'ok' : 'warn'}">${fmt.format(yearActual - yearBudget)}</strong>
      </div>
      <hr>
      <div>Net (Income − Budget):
        <strong class="${netVsBudget >= 0 ? 'ok' : 'warn'}">${fmt.format(netVsBudget)}</strong>
      </div>
      <div>Net (Income − Actual):
        <strong class="${netVsActual >= 0 ? 'ok' : 'warn'}">${fmt.format(netVsActual)}</strong>
      </div>
    `;
  }

  function renderAll() {
    const yearEl = document.getElementById('year');
    if (yearEl) yearEl.value = STATE.year;

    const incEl = document.getElementById('incomeYear');
    if (incEl) incEl.value = STATE.incomeYear ?? 0;

    renderHeader();
    renderCategoriesEditor();
    renderBudgetTable();
    renderMonthTotals();
    renderYearTotals();
  }

  /* ============ Year management ============ */
  async function fetchAvailableYears() {
    const baseRef = ref(database, `${DATABASE_BASE_PATH}/budgetPlan`);
    const snap = await get(baseRef);
    const out = [];
    if (snap.exists()) {
      for (const key of Object.keys(snap.val() || {})) {
        const n = Number(key);
        if (!Number.isNaN(n)) out.push(n);
      }
    }
    out.sort((a, b) => a - b);
    return out;
  }

  async function populateYearSelect(selectYear = null) {
    const yearEl = document.getElementById('year');
    if (!yearEl) return;
    const years = await fetchAvailableYears();

    yearEl.innerHTML = '';
    if (years.length === 0) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = '(no years yet — click "Add Year")';
      yearEl.appendChild(opt);
      yearEl.disabled = true;
      return;
    }

    yearEl.disabled = false;
    years.forEach(y => {
      const opt = document.createElement('option');
      opt.value = String(y);
      opt.textContent = String(y);
      yearEl.appendChild(opt);
    });

    const saved = loadLastYear();
    const desired = (selectYear != null && years.includes(Number(selectYear))) ? Number(selectYear)
      : (saved != null && years.includes(saved)) ? saved
        : (years.includes(Number(STATE?.year)) ? Number(STATE.year)
          : years[years.length - 1]);

    yearEl.value = String(desired);
    STATE.year = desired;
  }

  async function addYearFlow() {
    const suggested = new Date().getUTCFullYear();
    const input = prompt(`Enter the year to add (e.g., ${suggested}):`, String(suggested));
    const y = Number(input);
    if (!y || Number.isNaN(y)) return;

    const existing = await fetchAvailableYears();
    if (existing.includes(y)) {
      alert(`Year ${y} already exists.`);
      await populateYearSelect(y);
      await loadFromDB();
      renderAll();
      return;
    }

    const base = Array.isArray(STATE?.categories) && STATE.categories.length
      ? {
        year: y,
        incomeYear: 0,
        categories: STATE.categories.map(c => ({ name: c.name, monthly: toMoney(c.monthly) })),
        budgetOverrides: {},
        actuals: {}
      }
      : (() => {
        const b = structuredClone(DEFAULT_BASE);
        b.year = y;
        b.incomeYear = 0;
        b.budgetOverrides = {};
        b.actuals = {};
        return b;
      })();

    await set(ref(database, `${DATABASE_BASE_PATH}/budgetPlan/${y}`), encodeForDB(base));
    await populateYearSelect(y);
    await loadFromDB();
    renderAll();
    alert(`Year ${y} added.`);
  }

  /* ============ Sync from Financial Tracker (UTC) ============ */
  async function syncFromFinancialTracker() {
    const snap = await get(ref(database, FIN_TRACKER_PATH(DATABASE_BASE_PATH)));
    if (!snap.exists()) {
      alert('No financial data found at: ' + FIN_TRACKER_PATH(DATABASE_BASE_PATH));
      return;
    }
    const raw = snap.val();
    const wantYear = Number(STATE.year);

    // Aggregate
    let incomeYearSum = 0;
    const monthTagSums = Array.from({ length: 12 }, () => new Map());

    for (const bucket of Object.values(raw)) {
      const details = Array.isArray(bucket?.details) ? bucket.details : [];
      for (const d of details) {
        if (!d?.date) continue;
        const ym = ymFromISO(d.date); // UTC
        if (!ym || ym.y !== wantYear) continue;

        const amount = toMoney(d.amount);
        const type = String(d.type || '').toLowerCase();
        const tags = Array.isArray(d.tags) ? d.tags.filter(t => String(t).trim()) : [];

        if (type === 'income') {
          incomeYearSum += amount;
        } else if (type === 'expenses' || type === 'expense') {
          const tagList = (tags.length ? tags : [UNTITLED_CATEGORY]).map(t => String(t).trim());
          const share = (MULTITAG_MODE === 'split' && tagList.length > 0) ? (amount / tagList.length) : amount;
          const mMap = monthTagSums[ym.m];
          for (const tag of tagList) {
            const prev = mMap.get(tag) || 0;
            mMap.set(tag, prev + (MULTITAG_MODE === 'split' ? share : amount));
          }
        }
      }
    }

    // Ensure categories exist for all tags
    const seen = new Set();
    monthTagSums.forEach(mMap => mMap.forEach((_, tag) => seen.add(tag)));
    for (const t of seen) ensureCategory(t);

    // Write actuals into STATE (overwrite per found tag/month; leave others intact)
    for (let mi = 0; mi < 12; mi++) {
      const mKey = months[mi];
      STATE.actuals[mKey] ||= {};
      const mMap = monthTagSums[mi];
      mMap.forEach((sum, tag) => {
        STATE.actuals[mKey][tag] = toMoney(sum);
      });
    }

    STATE.incomeYear = toMoney(incomeYearSum);
    renderAll();
    await saveToDB();
    alert('Actuals & income synced from Financial Tracker (UTC).');
  }

  /* ============ Export CSV (optional) ============ */
  function exportCSV() {
    const { perMonth, yearBudget, yearActual, yearVariance } = totals();
    const monthsCount = countMonthsForTotalsAvg();

    // ----- Header: add Avg columns so counts match -----
    const header = [
      'Category',
      ...months.map(m => `${m} Budget`),
      'Avg Budget',
      ...months.map(m => `${m} Actual`),
      'Avg Actual'
    ];

    const rows = [header];

    // ----- Category rows (12 budget + 1 avg + 12 actual + 1 avg) -----
    for (const c of STATE.categories) {
      const row = [c.name];

      // Budgets
      for (let mi = 0; mi < 12; mi++) row.push(planForMonth(c.name, mi));
      row.push(avgBudgetForCategory(c.name));

      // Actuals
      for (let mi = 0; mi < 12; mi++) row.push(actualForMonth(c.name, mi));
      row.push(avgActualForCategory(c.name) ?? '');

      rows.push(row);
    }

    // Helper to pad a row to header length
    const padToHeader = (arr) => {
      while (arr.length < header.length) arr.push('');
      return arr;
    };

    // ----- Totals rows (match header length exactly) -----
    const budgetTotals = ['Totals (Budget)'];
    perMonth.forEach(m => budgetTotals.push(m.budget));
    budgetTotals.push(monthsCount ? (yearBudget / monthsCount) : ''); // Avg Budget
    for (let i = 0; i < 12; i++) budgetTotals.push('');               // Actual columns
    budgetTotals.push('');                                            // Avg Actual
    rows.push(padToHeader(budgetTotals));

    const actualTotals = ['Totals (Actual)'];
    perMonth.forEach(m => actualTotals.push(m.actual));
    actualTotals.push(monthsCount ? (yearActual / monthsCount) : ''); // Avg Actual (we’ll place in the Actual avg slot)
    for (let i = 0; i < 12; i++) actualTotals.push('');               // Actual months will be placed later
    actualTotals.push('');                                            // temp
    // Rebuild to align correctly: budget side blank, actual side filled
    const actualRow = ['Totals (Actual)'];
    // Budget months blank
    for (let i = 0; i < 12; i++) actualRow.push('');
    // Avg Budget blank
    actualRow.push('');
    // Actual months
    perMonth.forEach(m => actualRow.push(m.actual));
    // Avg Actual
    actualRow.push(monthsCount ? (yearActual / monthsCount) : '');
    rows.push(padToHeader(actualRow));

    const varianceRow = ['Variance (Actual - Budget)'];
    perMonth.forEach(m => varianceRow.push(m.variance));
    varianceRow.push(monthsCount ? ((yearActual - yearBudget) / monthsCount) : ''); // Avg variance in Budget avg slot
    // Keep Actual side blank to avoid double-reporting
    for (let i = 0; i < 12; i++) varianceRow.push('');
    varianceRow.push('');
    rows.push(padToHeader(varianceRow));

    // ----- Optional: a short metrics block after a blank line -----
    rows.push([]);
    rows.push(['Metric', 'Value']);
    rows.push(['Year Income', Math.max(0, toMoney(STATE.incomeYear))]);
    rows.push(['Year Net (Income − Budget)', Math.max(0, toMoney(STATE.incomeYear)) - yearBudget]);
    rows.push(['Year Net (Income − Actual)', Math.max(0, toMoney(STATE.incomeYear)) - yearActual]);
    rows.push(['Year Expense Variance (Actual − Budget)', yearVariance]);

    // ----- Serialize -----
    const csvEscape = (v) => {
      const s = String(v ?? '');
      return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
    };
    const csv = rows.map(r => r.map(csvEscape).join(',')).join('\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `budget_${STATE.year}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  const csvEscape = (v) => {
    const s = String(v ?? '');
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
  };

  function deleteCategory(catName) {
    if (!catName) return;
    if (!confirm(`Delete category "${catName}" and all its data? This cannot be undone.`)) return;

    STATE.categories = STATE.categories.filter(c => c.name !== catName);

    for (let mi = 0; mi < 12; mi++) {
      delete STATE.budgetOverrides[`${catName}::${mi}`];
    }
    for (const mKey of months) {
      if (STATE.actuals?.[mKey]) {
        delete STATE.actuals[mKey][catName];
      }
    }

    renderAll();
    saveToDB();
  }

  /* ============ Wiring & Init (with guards) ============ */
  function debounce(fn, ms = 400) {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }

  async function fetchAvailableYearsAndMaybeInit() {
    await populateYearSelect();
    const selectedValue = document.getElementById('year')?.value;
    if (selectedValue) {
      await loadFromDB();
      renderAll();
    }
  }

  function maybeInit() {
    if (!(DOM_READY && AUTH_READY)) return;

    const incomeEl = document.getElementById('incomeYear');
    if (incomeEl && !incomeEl._wired) {
      incomeEl.addEventListener('input', debounce(() => {
        STATE.incomeYear = Math.max(0, toMoney(incomeEl.value));
        renderYearTotals();
        saveToDB();
      }, 250));
      incomeEl._wired = true;
    }

    // buttons
    document.addEventListener('click', async (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;

      if (t.matches('#add-year')) {
        try { await addYearFlow(); } catch (err) { console.error(err); alert('Failed to add year.'); }
      }
      if (t.matches('#save')) saveToDB();
      if (t.matches('#export-csv')) exportCSV();
      if (t.matches('#reset-defaults')) {
        if (!confirm('Reset this year to default baseline?')) return;
        const keepYear = STATE.year;
        const keepIncome = STATE.incomeYear;
        STATE = structuredClone(DEFAULT_BASE);
        STATE.year = keepYear;
        STATE.incomeYear = keepIncome;
        ensureShapes();
        renderAll();
        saveToDB();
      }
      if (t.matches('#sync-from-tracker')) {
        try { await syncFromFinancialTracker(); }
        catch (err) { console.error(err); alert('Sync failed. See console for details.'); }
      }
    });

    const yearSelEl = document.getElementById('year');
    if (yearSelEl && !yearSelEl._wired) {
      yearSelEl.addEventListener('change', async (e) => {
        STATE.year = Number(e.target.value);
        saveLastYear(STATE.year);
        await loadFromDB();
        renderAll();
      });
      yearSelEl._wired = true;
    }

    (async () => { await fetchAvailableYearsAndMaybeInit(); })();

    window.addEventListener('beforeunload', () => saveToDB());
  }

  document.addEventListener('DOMContentLoaded', () => {
    DOM_READY = true;
    maybeInit();

    const headerTitle = document.querySelector('header h1');
    const loginSection = document.getElementById('login-section');

    headerTitle.addEventListener('dblclick', () => {
      loginSection.style.display =
        loginSection.style.display === 'none' || getComputedStyle(loginSection).display === 'none'
          ? 'block'
          : 'none';
    });
  });

  onAuthStateChanged(auth, async (user) => {
    DATABASE_BASE_PATH = user ? `${user.uid}` : 'public';
    AUTH_READY = true;
    maybeInit();
  });
</script>

</html>