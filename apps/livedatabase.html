<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Firebase Database Viewer</title>

    <link rel="stylesheet" href="../assets/css/app-styles.css" id="stylesheet">
    <script type="module" src="./assets/js/login.js"></script>

    <style>
        /* Explorer UI */
        .panel {
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 12px;
            margin: 12px 0;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .tree-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 8px;
            user-select: none;
        }

        .tree-item:hover {
            background: rgba(0, 0, 0, .05);
        }

        .tree-item.active {
            background: rgba(167, 196, 255, .35);
        }

        .tree-kv {
            font-size: 0.92rem;
            opacity: .85;
            margin-left: auto;
            max-width: 45%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .twisty {
            width: 18px;
            text-align: center;
            cursor: pointer;
            opacity: .75;
            flex: 0 0 auto;
        }

        .child-indent {
            margin-left: 16px;
            border-left: 1px dashed #ddd;
            padding-left: 10px;
            margin-top: 2px;
        }

        .badge {
            font-size: .8rem;
            padding: 2px 8px;
            border: 1px solid #ddd;
            border-radius: 999px;
            opacity: .85;
        }

        .muted {
            opacity: .8;
        }

        /* Image mover */
        #move-image-section select {
            min-width: 360px;
        }

        #move-image-section ul {
            list-style-type: none;
            padding: 0;
        }

        #move-image-section li {
            border-bottom: 1px solid #ddd;
            padding: 6px 0;
        }

        /* Timeline */
        #visit-timeline ul {
            list-style-type: none;
            padding: 0;
        }

        #visit-timeline li {
            border-bottom: 1px solid #ddd;
            padding: 8px 0;
        }

        #timeline-filters {
            margin-bottom: 10px;
        }

        #timeline-filters label {
            margin-right: 5px;
        }

        #timeline-filters input,
        #timeline-filters select {
            margin-right: 10px;
            padding: 3px 5px;
        }

        /* Layout */
        #db-explorer {
            display: flex;
            gap: 12px;
            align-items: stretch;
            min-height: 520px;
        }

        #treeShell {
            flex: 0 0 380px;
            max-width: 460px;
            padding: 0;
            overflow: hidden;
        }

        #detailShell {
            flex: 1;
            padding: 0;
            overflow: hidden;
        }

        .shell-head {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        .shell-body {
            padding: 10px;
            overflow: auto;
            max-height: 520px;
        }

        textarea {
            width: 100%;
            min-height: 180px;
            padding: 8px;
        }

        @media (max-width: 900px) {
            #db-explorer {
                flex-direction: column;
            }

            #treeShell {
                flex: 1;
                max-width: none;
            }
        }

        .small-muted {
            font-size: 0.9rem;
            opacity: 0.75;
        }

        .file-list {
            margin: 8px 0 0;
            padding-left: 18px;
        }

        .file-list li {
            margin: 2px 0;
        }

        .kv {
            display: flex;
            gap: 8px;
            margin: 4px 0;
        }

        .kv b {
            min-width: 120px;
        }
    </style>
</head>

<body>
    <header>
        <h1>Firebase Data</h1>

        <section id="login-section">
            <form id="login-form">
                <label for="username">Email:</label>
                <input type="email" id="username" required>
                <br>
                <label for="password">Password:</label>
                <input type="password" id="password" required>
                <br>
                <button type="submit">Login</button>
            </form>
            <button id="logout" style="display:none;">Logout</button>
        </section>
    </header>

    <main>

        <!-- ✅ Database Explorer (replaces the old recursive table dump) -->
        <section id="db-explorer" class="panel">
            <!-- LEFT: Tree -->
            <div id="treeShell" class="panel">
                <div class="shell-head">
                    <div class="row">
                        <input id="nodePathInput" type="text" placeholder="/public" style="flex:1; padding:6px 8px;">
                        <button id="goPathBtn" class="btn">Go</button>
                    </div>
                    <div class="row" style="margin-top:8px;">
                        <input id="treeSearchInput" type="text" placeholder="Search keys/values…"
                            style="flex:1; padding:6px 8px;">
                        <button id="collapseAllBtn" class="btn">Collapse</button>
                    </div>
                    <div id="breadcrumbs" class="muted" style="margin-top:8px; font-size:0.9rem;"></div>
                </div>
                <div id="treeContainer" class="shell-body">Loading…</div>
            </div>

            <!-- RIGHT: Detail -->
            <div id="detailShell" class="panel">
                <div class="shell-head row" style="justify-content:space-between;">
                    <div style="flex:1;">
                        <div style="font-weight:700;" id="selectedTitle">Select a node</div>
                        <div class="muted mono" style="font-size:0.9rem;" id="selectedPath">—</div>
                    </div>
                    <button id="copyPathBtn" class="btn">Copy Path</button>
                </div>

                <div class="shell-body">
                    <div id="selectedMeta" class="muted" style="margin-bottom:10px;"></div>

                    <div id="valueEditorWrap" style="display:none;">
                        <label style="display:block; margin-bottom:6px;">Value</label>
                        <textarea id="valueEditor" class="mono"></textarea>
                        <div class="row" style="margin-top:8px;">
                            <button id="saveNodeBtn" class="btn primary">Save</button>
                            <button id="deleteNodeBtn" class="btn" style="border:1px solid #f3b3b3;">Delete</button>
                        </div>
                        <div class="muted" style="font-size:0.85rem; margin-top:8px;">
                            Tip: Objects/arrays should be valid JSON.
                        </div>
                    </div>

                    <div id="childListWrap" style="display:none; margin-top:12px;">
                        <div style="font-weight:700; margin-bottom:6px;">Children</div>
                        <div id="childList"></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="move-image-section" class="panel">
            <h2>Image Mover</h2>

            <div class="row" style="align-items:flex-end;">
                <div style="flex:1; min-width:320px;">
                    <label><strong>1) From Folder</strong></label>
                    <select id="fromFolderDropdown">
                        <option value="">-- Select a folder --</option>
                    </select>
                </div>

                <div style="flex:1; min-width:320px;">
                    <label><strong>2) To Folder</strong></label>
                    <select id="toFolderDropdown">
                        <option value="">-- Select a folder --</option>
                    </select>
                </div>
            </div>

            <div class="row" style="margin-top:10px;">
                <label style="display:flex; align-items:center; gap:8px;">
                    <input type="radio" name="moveMode" value="move" checked>
                    Move
                </label>

                <label style="display:flex; align-items:center; gap:8px;">
                    <input type="radio" name="moveMode" value="copy">
                    Copy
                </label>

                <label style="display:flex; align-items:center; gap:8px; margin-left:auto;">
                    <input type="checkbox" id="dryRunCheckbox">
                    Dry run (preview only)
                </label>
            </div>

            <div class="row" style="margin-top:10px;">
                <button id="moveImageButton" class="btn primary" disabled>Choose folders…</button>
                <button id="swapFoldersBtn" class="btn" disabled>Swap</button>
            </div>

            <div class="row" style="margin-top:12px; gap:12px; align-items:stretch;">
                <div class="panel" style="flex:1; min-width:320px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <strong>From Preview</strong>
                        <span id="fromSummary" class="muted">—</span>
                    </div>
                    <div id="fromPreview" class="muted" style="margin-top:8px;">Waiting for selection…</div>
                </div>

                <div class="panel" style="flex:1; min-width:320px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <strong>To Preview</strong>
                        <span id="toSummary" class="muted">—</span>
                    </div>
                    <div id="toPreview" class="muted" style="margin-top:8px;">Waiting for selection…</div>
                </div>
            </div>

            <div id="progress-container" style="display:none; margin-top:12px;">
                <label><strong>Progress</strong></label>
                <progress id="progress-bar" value="0" max="100" style="width: 100%;"></progress>
                <div class="row" style="margin-top:6px;">
                    <span id="progress-text">0%</span>
                    <span id="progress-detail" class="muted" style="margin-left:auto;">—</span>
                </div>
            </div>
        </section>

        <!-- Visit timeline (kept from your original) -->
        <section class="panel">
            <h2>Visit Timeline</h2>
            <div id="timeline-filters">
                <label for="ipFilter">Filter by IP:</label>
                <input type="text" id="ipFilter" placeholder="Enter IP to filter">

                <label for="sortOrder">Sort by:</label>
                <select id="sortOrder">
                    <option value="desc" selected>Newest First</option>
                    <option value="asc">Oldest First</option>
                </select>

                <button id="applyFiltersBtn" class="btn">Apply Filters</button>
            </div>

            <div id="visit-timeline">Loading visit timeline...</div>
        </section>

    </main>

    <script type="module">
        import {
            auth, onAuthStateChanged, getDatabase, ref, get, onValue, update,
            listAll, getBytes, uploadBytes, deleteObject, storageRef, storage
        } from './assets/js/firebase-init.js';

        // -------------------------------------------------------------------
        // Globals
        // -------------------------------------------------------------------
        let DATABASE_BASE_PATH = 'public';

        // -------------------------------------------------------------------
        // Explorer Elements
        // -------------------------------------------------------------------
        const treeContainer = document.getElementById('treeContainer');
        const nodePathInput = document.getElementById('nodePathInput');
        const goPathBtn = document.getElementById('goPathBtn');
        const treeSearchInput = document.getElementById('treeSearchInput');
        const collapseAllBtn = document.getElementById('collapseAllBtn');

        const breadcrumbsEl = document.getElementById('breadcrumbs');
        const selectedTitle = document.getElementById('selectedTitle');
        const selectedPathEl = document.getElementById('selectedPath');
        const selectedMeta = document.getElementById('selectedMeta');
        const copyPathBtn = document.getElementById('copyPathBtn');

        const valueEditorWrap = document.getElementById('valueEditorWrap');
        const valueEditor = document.getElementById('valueEditor');
        const saveNodeBtn = document.getElementById('saveNodeBtn');
        const deleteNodeBtn = document.getElementById('deleteNodeBtn');

        const childListWrap = document.getElementById('childListWrap');
        const childList = document.getElementById('childList');

        // Explorer state
        let currentRootPath = '/';
        let selectedNodePath = null;
        let expandedPaths = new Set();
        let rootCache = undefined;
        let searchTerm = '';

        // -------------------------------------------------------------------
        // Helper functions
        // -------------------------------------------------------------------
        function normalizePath(p) {
            if (!p) return '/';
            p = String(p).trim();
            if (!p.startsWith('/')) p = '/' + p;
            p = p.replace(/\/+/g, '/');
            if (p.length > 1) p = p.replace(/\/$/, '');
            return p || '/';
        }

        function joinPath(a, b) {
            return normalizePath(`${a}/${b}`);
        }

        function splitPath(p) {
            p = normalizePath(p);
            if (p === '/') return [];
            return p.slice(1).split('/');
        }

        function safeType(v) {
            if (v === null) return 'null';
            if (Array.isArray(v)) return 'array';
            return typeof v;
        }

        function previewValue(v) {
            const t = safeType(v);
            if (t === 'object') return '{…}';
            if (t === 'array') return `[${v.length}]`;
            if (t === 'string') {
                const s = v;
                return s.length > 42 ? JSON.stringify(s.slice(0, 42) + '…') : JSON.stringify(s);
            }
            return String(v);
        }

        function renderBreadcrumbs(path) {
            const parts = splitPath(path);
            let curr = '/';

            const links = [`<span class="mono" style="cursor:pointer;" data-bc="/">/</span>`];
            for (const part of parts) {
                curr = joinPath(curr, part);
                links.push(`<span style="opacity:.6;">/</span><span class="mono" style="cursor:pointer;" data-bc="${curr}">${part}</span>`);
            }

            breadcrumbsEl.innerHTML = links.join(' ');
            breadcrumbsEl.querySelectorAll('[data-bc]').forEach(el => {
                el.onclick = () => loadRoot(el.getAttribute('data-bc'));
            });
        }

        function matchesSearch(key, value) {
            if (!searchTerm) return true;
            const s = searchTerm.toLowerCase();
            const k = String(key).toLowerCase();
            const v = (value && typeof value === 'object') ? '' : String(value ?? '').toLowerCase();
            return k.includes(s) || v.includes(s);
        }

        // Keep parents if any child matches
        function filterObject(obj) {
            if (!searchTerm) return obj;
            if (obj === null || typeof obj !== 'object') return obj;

            const t = safeType(obj);

            if (t === 'array') {
                const out = [];
                obj.forEach((v, idx) => {
                    if (matchesSearch(idx, v)) out.push(v);
                    else if (v && typeof v === 'object') {
                        const nested = filterObject(v);
                        const hasKeys = nested && typeof nested === 'object' && (Array.isArray(nested) ? nested.length : Object.keys(nested).length);
                        if (hasKeys) out.push(nested);
                    }
                });
                return out;
            }

            const out = {};
            for (const [k, v] of Object.entries(obj)) {
                if (matchesSearch(k, v)) out[k] = v;
                else if (v && typeof v === 'object') {
                    const nested = filterObject(v);
                    const hasKeys = nested && typeof nested === 'object' && (Array.isArray(nested) ? nested.length : Object.keys(nested).length);
                    if (hasKeys) out[k] = nested;
                }
            }
            return out;
        }

        function getValueAtPath(rootObj, rootPath, targetPath) {
            const rootParts = splitPath(rootPath);
            const targetParts = splitPath(targetPath);

            for (let i = 0; i < rootParts.length; i++) {
                if (targetParts[i] !== rootParts[i]) return undefined;
            }

            let node = rootObj;
            for (let i = rootParts.length; i < targetParts.length; i++) {
                if (node == null) return undefined;
                const k = targetParts[i];
                node = Array.isArray(node) ? node[Number(k)] : node[k];
            }
            return node;
        }

        function toMs(v) {
            if (!v) return 0;

            // numeric ms
            if (typeof v === 'number' && isFinite(v)) return v;

            // numeric string
            if (typeof v === 'string' && /^\d+$/.test(v)) return Number(v);

            // ISO string
            const t = Date.parse(v);
            return Number.isFinite(t) ? t : 0;
        }

        function taskScore(key, task) {
            // Prefer explicit updated times first, then startTime, then key-as-timestamp
            return Math.max(
                toMs(task?.meta?.updatedAt),
                toMs(task?.updatedAt),
                toMs(task?.meta?.createdAt),
                toMs(task?.createdAt),
                toMs(task?.startTime),
                toMs(key) // many of your keys ARE timestamps
            );
        }

        function pickNewestByProject(all, projectId) {
            let best = null;

            for (const [key, data] of Object.entries(all || {})) {
                if (!data || typeof data !== 'object') continue;
                if (String(data.project ?? '') !== String(projectId ?? '')) continue;

                const score = taskScore(key, data);
                if (!best || score > best.score) best = { key, data, score };
            }

            return best ? { key: best.key, data: best.data } : null;
        }

        // -------------------------------------------------------------------
        // Explorer rendering
        // -------------------------------------------------------------------
        async function loadRoot(path) {
            currentRootPath = normalizePath(path);
            nodePathInput.value = currentRootPath;
            renderBreadcrumbs(currentRootPath);

            const snap = await get(ref(getDatabase(), currentRootPath));
            rootCache = snap.val();

            expandedPaths = new Set([currentRootPath]);
            selectedNodePath = currentRootPath;

            renderTree();
            renderSelection();
        }

        function renderTree() {
            treeContainer.innerHTML = '';
            if (rootCache === undefined) {
                treeContainer.textContent = 'No data at this path.';
                return;
            }

            const filtered = filterObject(rootCache);

            const rootName = currentRootPath === '/' ? '/' : currentRootPath.split('/').pop();
            const rootNode = renderTreeNode({
                key: rootName,
                value: filtered,
                fullPath: currentRootPath,
                isRoot: true
            });

            treeContainer.appendChild(rootNode);
        }

        function renderTreeNode({ key, value, fullPath, isRoot = false }) {
            const t = safeType(value);
            const isBranch = (t === 'object' || t === 'array');

            const wrap = document.createElement('div');

            const row = document.createElement('div');
            row.className = 'tree-item' + (selectedNodePath === fullPath ? ' active' : '');
            row.dataset.path = fullPath;

            const twisty = document.createElement('div');
            twisty.className = 'twisty';
            twisty.textContent = isBranch ? (expandedPaths.has(fullPath) ? '▾' : '▸') : '•';

            const name = document.createElement('div');
            name.className = 'mono';
            name.textContent = isRoot ? (fullPath === '/' ? '/' : fullPath) : String(key);

            const badge = document.createElement('span');
            badge.className = 'badge';
            badge.textContent = t;

            const pv = document.createElement('div');
            pv.className = 'tree-kv mono';
            pv.textContent = isBranch ? '' : previewValue(value);

            row.onclick = () => {
                selectedNodePath = fullPath;
                renderTree();
                renderSelection();
            };

            twisty.onclick = (e) => {
                e.stopPropagation();
                if (!isBranch) return;
                if (expandedPaths.has(fullPath)) expandedPaths.delete(fullPath);
                else expandedPaths.add(fullPath);
                renderTree();
            };

            row.appendChild(twisty);
            row.appendChild(name);
            row.appendChild(badge);
            row.appendChild(pv);

            wrap.appendChild(row);

            if (isBranch && expandedPaths.has(fullPath)) {
                const childrenWrap = document.createElement('div');
                childrenWrap.className = 'child-indent';

                if (t === 'array') {
                    value.forEach((v, idx) => {
                        const childPath = joinPath(fullPath, idx);
                        childrenWrap.appendChild(renderTreeNode({ key: idx, value: v, fullPath: childPath }));
                    });
                } else {
                    Object.entries(value).forEach(([k, v]) => {
                        const childPath = joinPath(fullPath, k);
                        childrenWrap.appendChild(renderTreeNode({ key: k, value: v, fullPath: childPath }));
                    });
                }

                wrap.appendChild(childrenWrap);
            }

            return wrap;
        }

        function renderSelection() {
            if (!selectedNodePath) return;

            const value = getValueAtPath(rootCache, currentRootPath, selectedNodePath);
            const t = safeType(value);

            selectedTitle.textContent = selectedNodePath.split('/').pop() || '/';
            selectedPathEl.textContent = selectedNodePath;

            selectedMeta.innerHTML = `
        <div>Type: <span class="badge">${t}</span></div>
        <div style="margin-top:6px;">Preview: <span class="mono">${previewValue(value)}</span></div>
      `;

            // Children quick list
            childListWrap.style.display = (t === 'object' || t === 'array') ? 'block' : 'none';
            childList.innerHTML = '';

            if (t === 'array') {
                value.forEach((v, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'btn';
                    btn.style.margin = '4px 6px 0 0';
                    btn.textContent = `[${idx}] ${previewValue(v)}`;
                    btn.onclick = () => {
                        selectedNodePath = joinPath(selectedNodePath, idx);
                        expandedPaths.add(selectedNodePath);
                        renderTree();
                        renderSelection();
                    };
                    childList.appendChild(btn);
                });
            } else if (t === 'object') {
                Object.entries(value).forEach(([k, v]) => {
                    const btn = document.createElement('button');
                    btn.className = 'btn';
                    btn.style.margin = '4px 6px 0 0';
                    btn.textContent = `${k}: ${previewValue(v)}`;
                    btn.onclick = () => {
                        selectedNodePath = joinPath(selectedNodePath, k);
                        expandedPaths.add(selectedNodePath);
                        renderTree();
                        renderSelection();
                    };
                    childList.appendChild(btn);
                });
            }

            // Editor
            valueEditorWrap.style.display = 'block';
            if (t === 'object' || t === 'array') valueEditor.value = JSON.stringify(value, null, 2);
            else valueEditor.value = value ?? '';
        }

        copyPathBtn.onclick = async () => {
            if (!selectedNodePath) return;
            await navigator.clipboard.writeText(selectedNodePath);
        };

        saveNodeBtn.onclick = async () => {
            if (!selectedNodePath) return;

            let newVal = valueEditor.value;
            const trimmed = String(newVal).trim();

            // Parse JSON if it looks like JSON
            if (
                (trimmed.startsWith('{') && trimmed.endsWith('}')) ||
                (trimmed.startsWith('[') && trimmed.endsWith(']'))
            ) {
                try { newVal = JSON.parse(trimmed); }
                catch { alert('Invalid JSON.'); return; }
            }

            await update(ref(getDatabase()), { [selectedNodePath]: newVal });
            await loadRoot(currentRootPath);
        };

        deleteNodeBtn.onclick = async () => {
            if (!selectedNodePath) return;
            if (!confirm(`Delete ${selectedNodePath}?`)) return;
            await update(ref(getDatabase()), { [selectedNodePath]: null });
            await loadRoot(currentRootPath);
        };

        goPathBtn.onclick = () => loadRoot(nodePathInput.value);

        nodePathInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') loadRoot(nodePathInput.value);
        });

        treeSearchInput.oninput = () => {
            searchTerm = treeSearchInput.value.trim();
            renderTree();
        };

        collapseAllBtn.onclick = () => {
            expandedPaths = new Set([currentRootPath]);
            renderTree();
        };

        // -------------------------------------------------------------------
        // Image Mover (improved UX + correct progress across recursion)
        // -------------------------------------------------------------------
        const fromDropdown = document.getElementById('fromFolderDropdown');
        const toDropdown = document.getElementById('toFolderDropdown');
        const moveButton = document.getElementById('moveImageButton');
        const swapBtn = document.getElementById('swapFoldersBtn');

        const fromPreview = document.getElementById('fromPreview');
        const toPreview = document.getElementById('toPreview');
        const fromSummary = document.getElementById('fromSummary');
        const toSummary = document.getElementById('toSummary');

        const dryRunCheckbox = document.getElementById('dryRunCheckbox');

        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const progressDetail = document.getElementById('progress-detail');

        function getMoveMode() {
            return document.querySelector('input[name="moveMode"]:checked')?.value || 'move';
        }

        function setMoveButtonsState() {
            const fromFolder = fromDropdown.value.trim();
            const toFolder = toDropdown.value.trim();
            const ok = fromFolder && toFolder && fromFolder !== toFolder && !isSubfolderMove(fromFolder, toFolder);

            moveButton.disabled = !ok;
            moveButton.textContent = ok ? (dryRunCheckbox.checked ? 'Preview Changes' : (getMoveMode() === 'copy' ? 'Copy Files' : 'Move Files')) : 'Choose folders…';
            swapBtn.disabled = !(fromFolder && toFolder);
        }

        function isSubfolderMove(fromFolder, toFolder) {
            // Prevent moving into itself or into a child folder (creates loops/confusion)
            const a = fromFolder.replace(/\/+$/, '');
            const b = toFolder.replace(/\/+$/, '');
            return b === a || b.startsWith(a + '/');
        }

        function formatBytes(bytes) {
            if (!Number.isFinite(bytes)) return '—';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let i = 0, v = bytes;
            while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
            return `${v.toFixed(i === 0 ? 0 : 2)} ${units[i]}`;
        }

        async function getAllFolders(startRef, base = '') {
            const folders = [];
            async function recurse(currentRef, pathSoFar) {
                const result = await listAll(currentRef);
                for (const prefix of result.prefixes) {
                    const folderPath = pathSoFar ? `${pathSoFar}/${prefix.name}` : prefix.name;
                    folders.push(folderPath);
                    await recurse(prefix, folderPath);
                }
            }
            await recurse(startRef, base);
            return folders;
        }

        async function populateFolderDropdowns() {
            const startRef = storageRef(storage, '');

            try {
                const folders = await getAllFolders(startRef);

                // same “startTime label” logic you had
                const folderData = await Promise.all(
                    folders.map(async (folder) => {
                        const match = folder.match(/^(.*?)\/images\/(.+)$/);
                        if (!match) return { folder, startTime: null };

                        const [_, dbPath, projectId] = match;
                        const dbRef = ref(getDatabase(), dbPath);

                        try {
                            const snap = await get(dbRef);
                            const data = snap.val();
                            const entry = Object.values(data || {}).find((v) => v && typeof v === 'object' && v.project === projectId);
                            return { folder, startTime: entry?.startTime || null };
                        } catch {
                            return { folder, startTime: null };
                        }
                    })
                );

                folderData.sort((a, b) => {
                    if (a.startTime && b.startTime) return new Date(b.startTime) - new Date(a.startTime);
                    if (a.startTime) return -1;
                    if (b.startTime) return 1;
                    return 0;
                });

                [fromDropdown, toDropdown].forEach(dropdown => {
                    dropdown.innerHTML = '<option value="">-- Select a folder --</option>';
                    folderData.forEach(({ folder, startTime }) => {
                        const label = startTime ? `${new Date(startTime).toLocaleDateString()} - ${folder}` : folder;
                        dropdown.appendChild(new Option(label, folder));
                    });
                });
            } catch (err) {
                console.error("Failed to get folders or task info:", err);
            }
        }

        function parseFolderToDbPathAndProject(folderPath) {
            const m = folderPath.match(/^(.*?)\/images\/(.+)$/);
            if (!m) return { dbPath: null, projectId: null };
            return { dbPath: m[1], projectId: m[2] };
        }

        async function fetchAllTasks(dbPath) {
            if (!dbPath) return {};
            const snap = await get(ref(getDatabase(), dbPath));
            return snap.val() || {};
        }

        function pickBestFallbackTaskEntry(entries) {
            let best = null;
            let bestTime = -Infinity;

            for (const [key, data] of Object.entries(entries)) {
                if (!data || typeof data !== 'object') continue;
                const tCandidates = [data.updatedAt, data.createdAt, data.startTime].filter(Boolean);
                const t = tCandidates.length ? new Date(tCandidates[0]).getTime() : 0;
                if (t > bestTime) { best = [key, data]; bestTime = t; }
            }
            return best || Object.entries(entries)[0] || null;
        }

        async function getSourceTask(dbPath, projectId) {
            const all = await fetchAllTasks(dbPath);

            // ✅ pick newest among ALL matches (not first)
            const bestMatch = pickNewestByProject(all, projectId);
            if (bestMatch) return bestMatch;

            // fallback if nothing matches project
            const fallback = pickBestFallbackTaskEntry(all);
            return fallback ? { key: fallback[0], data: fallback[1] } : null;
        }

        async function getDestinationTaskOrNull(dbPath, projectId) {
            const all = await fetchAllTasks(dbPath);

            // ✅ pick newest among ALL matches (not first)
            return pickNewestByProject(all, projectId);
        }

        async function getDestinationTaskOrNull(dbPath, projectId) {
            const all = await fetchAllTasks(dbPath);
            for (const [k, v] of Object.entries(all)) {
                if (v && typeof v === 'object' && v.project === projectId) return { key: k, data: v };
            }
            return null;
        }

        function buildMissingFieldsPatch(sourceData, destData) {
            const patch = {};
            for (const [k, v] of Object.entries(sourceData || {})) {
                if (!destData || !(k in destData) || destData[k] === undefined) patch[k] = v;
            }
            return patch;
        }

        async function copyInfoDataRegardlessOfIds(fromFolder, toFolder) {
            const { dbPath: fromDbPath, projectId: fromProjectId } = parseFolderToDbPathAndProject(fromFolder);
            const { dbPath: toDbPath, projectId: toProjectId } = parseFolderToDbPathAndProject(toFolder);

            if (!fromDbPath || !toDbPath) return;

            const source = await getSourceTask(fromDbPath, fromProjectId);
            if (!source?.data) return;

            const copiedData = { ...source.data };
            if (toProjectId) copiedData.project = toProjectId;

            const dest = await getDestinationTaskOrNull(toDbPath, toProjectId);

            if (dest) {
                const patch = buildMissingFieldsPatch(copiedData, dest.data);
                if (Object.keys(patch).length === 0) return;

                await update(ref(getDatabase()), {
                    [`${toDbPath}/${dest.key}`]: { ...dest.data, ...patch }
                });
            } else {
                const newKey = Date.now().toString();
                await update(ref(getDatabase()), {
                    [`${toDbPath}/${newKey}`]: copiedData
                });
            }
        }

        // --- Preview helpers (files + task info) ---
        async function summarizeFolder(folderPath) {
            const baseRef = storageRef(storage, folderPath);
            const files = [];
            let totalBytes = 0;
            let fileCount = 0;

            async function walk(r) {
                const res = await listAll(r);

                for (const item of res.items) {
                    fileCount++;
                    files.push(item.fullPath);
                    // getBytes to count size is expensive; instead count “unknown” unless you really want it
                    // If you want true size, you'd call getMetadata(item). That’s extra cost too.
                }
                for (const p of res.prefixes) await walk(p);
            }

            await walk(baseRef);

            // Just show first 8 files
            const previewFiles = files.slice(0, 8).map(p => p.replace(folderPath, '').replace(/^\/+/, ''));

            return { fileCount, totalBytes, previewFiles };
        }

        async function getTaskPreview(folderPath) {
            const { dbPath, projectId } = parseFolderToDbPathAndProject(folderPath);
            if (!dbPath) return null;

            const all = await fetchAllTasks(dbPath);
            const match = Object.entries(all).find(([, v]) => v && typeof v === 'object' && v.project === projectId);
            if (!match) return null;

            const [key, task] = match;
            return {
                key,
                project: task.project,
                startTime: task.startTime,
                customerName: task.customerName,
                name: task.name,
                siteName: task.siteName
            };
        }

        function renderFolderPreview(containerEl, summaryEl, folderPath, folderSummary, taskPreview) {
            if (!folderPath) {
                containerEl.textContent = 'Waiting for selection…';
                summaryEl.textContent = '—';
                return;
            }

            summaryEl.textContent = `${folderSummary.fileCount} files`;

            const parts = [];
            parts.push(`<div class="kv"><b>Folder</b><span class="mono">${folderPath}</span></div>`);
            parts.push(`<div class="kv"><b>Files</b><span>${folderSummary.fileCount}</span></div>`);

            if (taskPreview) {
                parts.push(`<hr style="border:none;border-top:1px solid #eee;margin:10px 0;">`);
                parts.push(`<div style="font-weight:700; margin-bottom:6px;">Matched Task</div>`);
                parts.push(`<div class="kv"><b>Key</b><span class="mono">${taskPreview.key}</span></div>`);
                if (taskPreview.project) parts.push(`<div class="kv"><b>Project</b><span>${taskPreview.project}</span></div>`);
                if (taskPreview.customerName) parts.push(`<div class="kv"><b>Customer</b><span>${taskPreview.customerName}</span></div>`);
                if (taskPreview.siteName) parts.push(`<div class="kv"><b>Site</b><span>${taskPreview.siteName}</span></div>`);
                if (taskPreview.startTime) parts.push(`<div class="kv"><b>Start</b><span>${new Date(taskPreview.startTime).toLocaleString()}</span></div>`);
            } else {
                parts.push(`<div class="small-muted" style="margin-top:8px;">No matching task found for <span class="mono">/images/${folderPath.split('/images/')[1] || ''}</span></div>`);
            }

            if (folderSummary.previewFiles.length) {
                parts.push(`<hr style="border:none;border-top:1px solid #eee;margin:10px 0;">`);
                parts.push(`<div style="font-weight:700; margin-bottom:6px;">Sample Files</div>`);
                parts.push(`<ul class="file-list">` + folderSummary.previewFiles.map(f => `<li class="mono">${f}</li>`).join('') + `</ul>`);
            }

            containerEl.innerHTML = parts.join('');
        }

        async function refreshPreviews() {
            const fromFolder = fromDropdown.value.trim();
            const toFolder = toDropdown.value.trim();

            setMoveButtonsState();

            if (fromFolder) {
                fromPreview.textContent = 'Loading…';
                const [sum, task] = await Promise.all([summarizeFolder(fromFolder), getTaskPreview(fromFolder)]);
                renderFolderPreview(fromPreview, fromSummary, fromFolder, sum, task);
            } else {
                renderFolderPreview(fromPreview, fromSummary, '', { fileCount: 0, previewFiles: [] }, null);
            }

            if (toFolder) {
                toPreview.textContent = 'Loading…';
                const [sum, task] = await Promise.all([summarizeFolder(toFolder), getTaskPreview(toFolder)]);
                renderFolderPreview(toPreview, toSummary, toFolder, sum, task);
            } else {
                renderFolderPreview(toPreview, toSummary, '', { fileCount: 0, previewFiles: [] }, null);
            }
        }

        // --- Accurate progress across recursion ---
        async function countFilesRecursively(folderRef) {
            let count = 0;
            const res = await listAll(folderRef);
            count += res.items.length;
            for (const p of res.prefixes) count += await countFilesRecursively(p);
            return count;
        }

        async function moveAllFilesRecursively(folderRef, fromFolder, toFolder, copyInstead, progress) {
            const listResult = await listAll(folderRef);

            for (const item of listResult.items) {
                const buffer = await getBytes(item);
                const relativePath = item.fullPath.replace(fromFolder, '').replace(/^\/+/, '');
                const toRef = storageRef(storage, `${toFolder}/${relativePath}`);
                await uploadBytes(toRef, buffer);
                if (!copyInstead) await deleteObject(item);

                progress.moved++;
                const percent = Math.round((progress.moved / progress.total) * 100);
                progressBar.value = percent;
                progressText.textContent = `${percent}%`;
                progressDetail.textContent = `${progress.moved}/${progress.total} files`;
            }

            for (const prefix of listResult.prefixes) {
                await moveAllFilesRecursively(prefix, fromFolder, toFolder, copyInstead, progress);
            }
        }

        // --- Events ---
        fromDropdown.addEventListener('change', refreshPreviews);
        toDropdown.addEventListener('change', refreshPreviews);
        dryRunCheckbox.addEventListener('change', () => { setMoveButtonsState(); });

        document.querySelectorAll('input[name="moveMode"]').forEach(r => {
            r.addEventListener('change', () => { setMoveButtonsState(); });
        });

        swapBtn.addEventListener('click', () => {
            const a = fromDropdown.value;
            const b = toDropdown.value;
            fromDropdown.value = b;
            toDropdown.value = a;
            refreshPreviews();
        });

        moveButton.addEventListener('click', async () => {
            const fromFolder = fromDropdown.value.trim();
            const toFolder = toDropdown.value.trim();
            const mode = getMoveMode();
            const copyInstead = (mode === 'copy');
            const dryRun = dryRunCheckbox.checked;

            if (!fromFolder || !toFolder || fromFolder === toFolder) {
                alert("Select two different folders.");
                return;
            }
            if (isSubfolderMove(fromFolder, toFolder)) {
                alert("You can’t move/copy a folder into itself (or into a subfolder).");
                return;
            }

            // Dry run just prints summary
            if (dryRun) {
                const total = await countFilesRecursively(storageRef(storage, fromFolder));
                alert(`Dry run:\n${mode.toUpperCase()} ${total} files\nFrom: ${fromFolder}\nTo: ${toFolder}\n\n(No changes made)`);
                return;
            }

            progressContainer.style.display = 'block';
            progressBar.value = 0;
            progressText.textContent = '0%';
            progressDetail.textContent = 'Counting…';

            try {
                const baseRef = storageRef(storage, fromFolder);
                const total = await countFilesRecursively(baseRef);

                const progress = { total: Math.max(1, total), moved: 0 };
                progressDetail.textContent = `0/${progress.total} files`;

                await moveAllFilesRecursively(baseRef, fromFolder, toFolder, copyInstead, progress);
                await copyInfoDataRegardlessOfIds(fromFolder, toFolder);

                alert(`Successfully ${copyInstead ? 'copied' : 'moved'} ${progress.total} files.`);
                await populateFolderDropdowns();
                await refreshPreviews();
            } catch (err) {
                console.error("Move/Copy Error:", err);
                alert("Error moving/copying files.");
            } finally {
                progressContainer.style.display = 'none';
            }
        });

        // call once after auth / folders are populated
        // populateFolderDropdowns() is already called in your onAuthStateChanged
        // so do a preview refresh after that finishes

        // -------------------------------------------------------------------
        // Init / events
        // -------------------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            fromDropdown.addEventListener('change', () => displayTaskInfoForFolder(fromDropdown.value.trim(), 'folder-data-list-from'));
            toDropdown.addEventListener('change', () => displayTaskInfoForFolder(toDropdown.value.trim(), 'folder-data-list-to'));

            document.getElementById('applyFiltersBtn').onclick = applyTimelineFilters;
            document.getElementById('ipFilter').oninput = applyTimelineFilters;

            loadVisitTimeline();
        });

        onAuthStateChanged(auth, async (user) => {
            DATABASE_BASE_PATH = user ? user.uid : 'public';
            loadRoot(`/${DATABASE_BASE_PATH}`);
            await populateFolderDropdowns();
            refreshPreviews();
        });

    </script>

</body>

</html>