<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Financial Tracker</title>
  <link rel="icon" href="./assets/img/financial_logo.png">
  <link rel="stylesheet" href="../assets/css/app-styles.css" id="stylesheet">
  <script type="module" src="./assets/js/login.js" defer></script>
  <script src="./assets/js/search.js" defer></script>

  <style>
    html {
      scroll-behavior: smooth;
    }

    @media (prefers-reduced-motion: reduce) {
      html {
        scroll-behavior: auto;
      }
    }

    .modal {
      margin-top: 80px;
    }

    .transaction-row select,
    .transaction-row button {
      padding-bottom: 3px;
      padding-top: 0;
      margin-bottom: 0;
    }

    .visuals canvas {
      height: auto;
      width: 80%;
      margin: 0 auto;
    }

    .transaction-row td[data-key="tags"],
    #modalContent td[data-key="tags"] {
      white-space: pre-wrap;
    }

    .tag-bar {
      margin: 8px 0 12px;
    }

    .tag-chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #ccc;
      cursor: pointer;
      user-select: none;
    }

    .to-top {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 44px;
      height: 44px;
      border-radius: 999px;
      background: lightblue;
      text-decoration: none;
      display: grid;
      place-items: center;
      font-size: 22px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, .2);
      z-index: 99;
      opacity: 0.7;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
  <header>
    <h1>Online Financial Tracker</h1>
    <section id="login-section">
      <form id="login-form">
        <label for="username">Email:</label>
        <input type="email" id="username" required>
        <br>
        <label for="password">Password:</label>
        <input type="password" id="password" required>
        <br>
        <button type="submit">Login</button>
      </form>
      <button id="logout" style="display: none;">Logout</button>
    </section>
  </header>

  <main id="top">

    <div>
      <label for="yearSelect">Select Year: </label>
      <select id="yearSelect"></select>
    </div>

    <div id="tag-bar" class="tag-bar" aria-label="Tag filters"></div>

    <section id="all-transactions">
      <div>
        <input type="text" id="global-search" placeholder="Search Transactions:" oninput="filterGlobalEntries()"
          disabled title="Load ./assets/js/search.js to enable advanced search">
      </div>
      <div class="table">
        <table id="transactions-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Name</th>
              <th>Type</th>
              <th>Amount</th>
              <th>Tags</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            <!-- Transactions will be dynamically inserted here -->
          </tbody>
        </table>
      </div>
    </section>

    <p id="filtered-total">Filtered Total: $0.00</p>

    <section id="yearly-budget-calculator">
      <h2>Totals For Months</h2>
      <div class="visuals">
        <canvas id="monthlyBar"></canvas>
      </div>
      <div class="table">
        <table id="months-container">
          <thead>
            <tr>
              <th>Month</th>
              <th>Income</th>
              <th>Expenses</th>
              <th>Balance</th>
              <th>Add Income</th>
              <th>Add Expense</th>
            </tr>
          </thead>
          <tbody>
            <!-- Months will be populated here by JavaScript -->
          </tbody>
        </table>
      </div>

    </section>

    <section>
      <h2>Totals For Year:</h2>
      <table id="yearly-totals-table">
        <thead>
          <tr>
            <th>Total Transactions</th>
            <th>Total Income</th>
            <th>Total Expenses</th>
            <th>Total Balance</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td id="total-transactions">0</td>
            <td id="total-income">0</td>
            <td id="total-expenses">0</td>
            <td id="yearly-balance">0</td>
          </tr>
        </tbody>
      </table>

      <h2>Overall Totals:</h2>
      <table id="overall-totals-table">
        <thead>
          <tr>
            <th>Overall Income</th>
            <th>Overall Expenses</th>
            <th>Overall Balance</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td id="overall-income">0</td>
            <td id="overall-expenses">0</td>
            <td id="overall-balance">0</td>
          </tr>
        </tbody>
      </table>

      <br>

      <div class="visuals">
        <div class="pie-controls">
          <label>Breakdown:
            <select id="pie-breakdown">
              <option value="months" selected>Months</option>
              <option value="tags">Tags</option>
              <option value="years">Years</option>
            </select>
          </label>
          <label>Metric:
            <select id="pie-metric">
              <option value="expenses" selected>Expenses</option>
              <option value="income">Income</option>
            </select>
          </label>
        </div>

        <canvas id="yearPie" height="120"></canvas>
      </div>
    </section>

    <section>
      <div id="detailsModal">
        <div class="modal">
          <span id="closeModal">&times;</span>
          <h2><span id="date-selected"></span></h2>
          <div id="modalContent"></div>
        </div>
      </div>
    </section>

    <section id="daily-tracker">
      <h2>Daily Financial Tracker:</h2>
      <div id="year-grid" class="year-grid"></div>
    </section>

    <button id="export-tags-csv">Export CSV (Summary)</button>
    <button id="export-details">Export Data (Backup)</button>
    <button id="trigger-import">Import JSON (Overwrite)</button>
    <input type="file" id="load-data" accept=".json" style="display:none">
    <button class="clear-button" id="clear-details">Delete Data</button>

    <a href="#top" class="to-top" aria-label="Back to top">↑</a>

  </main>

  <script type="module">
    import { auth, onAuthStateChanged, database, ref, onValue, set, get, update } from './assets/js/firebase-init.js';

    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    let currentYear = new Date().getFullYear();
    let yearlyDetails = initializeYearlyDetails();
    let DATABASE_BASE_PATH = 'public';
    let _engine = null;
    let handlersBound = false;
    let _lastSavedData = {};
    let budgetUnsub = null;

    function renderAll(savedData) {
      _lastSavedData = savedData || {};
      populateYearDropdown(_lastSavedData);
      fetchOverallTotals(_lastSavedData);
      renderTagBar(_lastSavedData);
      yearlyDetails = aggregateMonthlyData(_lastSavedData, currentYear);
      populateMonths();
      calculateYearlyTotals();
      generateYearGrid(_lastSavedData);
      displayAllTransactions();
      renderCharts();
    }

    // --- Tag helpers ---
    function parseTags(input) {
      if (!input) return [];
      return String(input)
        .split(',')
        .map(t => t.trim())
        .filter(Boolean)
        .slice(0, 20);
    }
    function formatTags(arr) {
      if (!Array.isArray(arr)) return '';
      return arr.join(', ');
    }

    function wireSearchEngine() {
      const input = document.getElementById('global-search');
      if (!input) return;

      if (window.SearchEngine) {
        _engine = window.SearchEngine.create({
          fields: {
            name: { type: 'string', resolver: r => r.name },
            type: { type: 'string', resolver: r => r.type },
            amount: { type: 'number', resolver: r => r.amount },
            date: { type: 'date', resolver: r => r.date },
            dateKey: { type: 'string', resolver: r => r.dateKey },
            tags: { type: 'string', resolver: r => Array.isArray(r.tags) ? r.tags.join(' ') : '' }
          },
          defaultFields: ['name', 'type', 'dateKey', 'tags'],
          caseSensitive: false
        });
        input.disabled = false;
        input.placeholder = 'Search…  e.g. tag:"rent", name:"gas", amount:>200';
        input.title = _engine.operatorsHelp();
      } else {
        input.disabled = true;
        input.placeholder = 'Search unavailable';
        input.title = 'Load ./assets/js/search.js to enable advanced search';
      }
    }

    onAuthStateChanged(auth, (user) => {
      DATABASE_BASE_PATH = user ? `${user.uid}` : 'public';

      if (typeof budgetUnsub === 'function') {
        budgetUnsub();
        budgetUnsub = null;
      }

      setupEventListeners();
      wireSearchEngine();

      attachBudgetListener();
    });

    function attachBudgetListener() {
      if (budgetUnsub) return;

      const budgetRef = ref(database, `${DATABASE_BASE_PATH}/budget`);

      budgetUnsub = onValue(budgetRef, (snapshot) => {
        const savedData = snapshot.exists() ? snapshot.val() : {};
        renderAll(savedData);
      }, (err) => {
        console.error('❌ onValue error:', err);
      });
    }

    function initApp() {
      setupEventListeners();
      fetchSavedData().then(savedData => {
        _lastSavedData = savedData;
        populateYearDropdown(savedData);
        fetchOverallTotals(savedData);
        renderTagBar(savedData);
        yearlyDetails = aggregateMonthlyData(savedData, currentYear);
        populateMonths();
        calculateYearlyTotals();
        generateYearGrid(savedData);
        displayAllTransactions();
        renderCharts();
        wireSearchEngine();
      });
    }

    function initializeYearlyDetails() {
      return months.reduce((acc, month) => {
        acc[month] = { details: [] };
        return acc;
      }, {});
    }

    function setupEventListeners() {
      if (handlersBound) return;
      handlersBound = true;

      document.getElementById('export-details')?.addEventListener('click', exportDetailsToJSON);
      document.getElementById('export-tags-csv')?.addEventListener('click', exportTagsCSV);

      const triggerImportBtn = document.getElementById('trigger-import');
      if (triggerImportBtn) {
        triggerImportBtn.addEventListener('click', () => {
          document.getElementById('load-data').click();
        });
      }

      document.getElementById('load-data')?.addEventListener('change', importJSONReplaceExisting);
      document.getElementById('clear-details')?.addEventListener('click', clearDetails);
      document.getElementById('yearSelect')?.addEventListener('change', handleYearChange);
      document.getElementById('closeModal').onclick = closeModal;
      window.onclick = event => {
        if (event.target === document.getElementById('detailsModal')) {
          closeModal();
        }
      };
      document.getElementById('pie-breakdown')?.addEventListener('change', () => renderPie());
      document.getElementById('pie-metric')?.addEventListener('change', () => renderPie());
    }

    // === Charts: state & helpers ===
    let monthlyBarChart = null;
    let yearPieChart = null;

    function getMonthlyIncomeExpenses() {
      const income = Array(12).fill(0);
      const expenses = Array(12).fill(0);

      months.forEach((m, idx) => {
        const monthData = yearlyDetails[m] || { details: [] };
        monthData.details.forEach(d => {
          if (d.type === 'Income') income[idx] += d.amount || 0;
          if (d.type === 'Expenses') expenses[idx] += d.amount || 0;
        });
      });

      return { income, expenses };
    }

    function getYearTotals() {
      let totalIncome = 0, totalExpenses = 0;
      months.forEach(m => {
        const md = yearlyDetails[m] || { details: [] };
        md.details.forEach(d => {
          if (d.type === 'Income') totalIncome += d.amount || 0;
          if (d.type === 'Expenses') totalExpenses += d.amount || 0;
        });
      });
      return { totalIncome, totalExpenses };
    }

    function renderCharts() {
      const { income, expenses } = getMonthlyIncomeExpenses();
      const labels = months;

      // Monthly stacked bar
      const barCtx = document.getElementById('monthlyBar');
      if (monthlyBarChart) monthlyBarChart.destroy();
      monthlyBarChart = new Chart(barCtx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            { label: 'Income', data: income },
            { label: 'Expenses', data: expenses }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: `Income vs Expenses by Month — ${currentYear}` },
            tooltip: { mode: 'index', intersect: false },
            legend: { position: 'top' }
          },
          scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } }
        }
      });

      // New dynamic pie
      renderPie();
    }

    function isIncome(d) { return String(d?.type || '').toLowerCase() === 'income'; }
    function isExpense(d) {
      const t = String(d?.type || '').toLowerCase();
      return t === 'expenses' || t === 'expense';
    }

    // Build dataset by months for the current year
    function groupByMonths(savedData, metric /* 'income' | 'expenses' */) {
      const totals = Array(12).fill(0);
      for (const bucket of Object.values(savedData || {})) {
        const items = Array.isArray(bucket?.details) ? bucket.details : [];
        for (const d of items) {
          if (!d?.date) continue;
          const y = new Date(d.date).getFullYear();
          if (y !== currentYear) continue;
          const m = new Date(d.date).getMonth(); // 0-11
          const val = Number(d.amount) || 0;
          if (metric === 'income' && isIncome(d)) totals[m] += val;
          if (metric === 'expenses' && isExpense(d)) totals[m] += val;
        }
      }
      return { labels: months.slice(), values: totals };
    }

    // Build dataset by tags for the current year (top N + Other)
    function groupByTags(savedData, metric, topN = 12) {
      const map = new Map(); // tag -> total
      for (const bucket of Object.values(savedData || {})) {
        const items = Array.isArray(bucket?.details) ? bucket.details : [];
        for (const d of items) {
          if (!d?.date) continue;
          const y = new Date(d.date).getFullYear();
          if (y !== currentYear) continue;
          const val = Number(d.amount) || 0;
          const ok = (metric === 'income' && isIncome(d)) ||
            (metric === 'expenses' && isExpense(d));
          if (!ok) continue;
          const tags = Array.isArray(d.tags) ? d.tags : [];
          if (!tags.length) {
            // Optional: attribute untagged to "(No tag)"
            const prev = map.get('(No tag)') || 0;
            map.set('(No tag)', prev + val);
          } else {
            for (const raw of tags) {
              const t = String(raw || '').trim();
              if (!t) continue;
              const prev = map.get(t) || 0;
              map.set(t, prev + val);
            }
          }
        }
      }
      const entries = Array.from(map.entries()).sort((a, b) => b[1] - a[1]);
      const top = entries.slice(0, topN);
      const rest = entries.slice(topN);
      const otherSum = rest.reduce((s, [, v]) => s + v, 0);

      const labels = top.map(([k]) => k);
      const values = top.map(([, v]) => v);
      if (otherSum > 0) { labels.push('Other'); values.push(otherSum); }
      if (!labels.length) return { labels: ['(No data)'], values: [0] };
      return { labels, values };
    }

    // Build dataset by years (across all data you have)
    function groupByYears(savedData, metric) {
      const map = new Map(); // year -> total
      for (const bucket of Object.values(savedData || {})) {
        const items = Array.isArray(bucket?.details) ? bucket.details : [];
        for (const d of items) {
          if (!d?.date) continue;
          const y = new Date(d.date).getFullYear();
          const val = Number(d.amount) || 0;
          if (metric === 'income' && isIncome(d)) map.set(y, (map.get(y) || 0) + val);
          if (metric === 'expenses' && isExpense(d)) map.set(y, (map.get(y) || 0) + val);
        }
      }
      const years = Array.from(map.keys()).sort((a, b) => a - b);
      const values = years.map(y => map.get(y));
      if (!years.length) return { labels: ['(No data)'], values: [0] };
      return { labels: years.map(String), values };
    }

    function currentPieControls() {
      const breakdown = (document.getElementById('pie-breakdown')?.value || 'months').toLowerCase();
      const metric = (document.getElementById('pie-metric')?.value || 'expenses').toLowerCase();
      return { breakdown, metric };
    }

    function renderPie() {
      const { breakdown, metric } = currentPieControls();
      const pieCtx = document.getElementById('yearPie');
      if (!pieCtx) return;

      // Build data based on selection
      let labels = [], values = [];
      if (breakdown === 'months') {
        ({ labels, values } = groupByMonths(_lastSavedData, metric));
      } else if (breakdown === 'tags') {
        ({ labels, values } = groupByTags(_lastSavedData, metric, 12));
      } else if (breakdown === 'years') {
        ({ labels, values } = groupByYears(_lastSavedData, metric));
      }

      // Title text
      let title = '';
      if (breakdown === 'months') {
        title = `${capitalize(metric)} by Month — ${currentYear}`;
      } else if (breakdown === 'tags') {
        title = `${capitalize(metric)} by Tag — ${currentYear}`;
      } else {
        title = `${capitalize(metric)} by Year`;
      }

      // (Re)create chart
      if (yearPieChart) yearPieChart.destroy();
      yearPieChart = new Chart(pieCtx, {
        type: 'pie',
        data: {
          labels,
          datasets: [{ label: title, data: values }]
        },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: title },
            legend: { position: 'right' },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const v = Number(ctx.parsed) || 0;
                  return `${ctx.label}: $${v.toFixed(2)}`;
                }
              }
            }
          }
        }
      });
    }

    function capitalize(s) { return String(s || '').charAt(0).toUpperCase() + String(s || '').slice(1); }

    function handleYearChange() {
      currentYear = parseInt(document.getElementById('yearSelect').value, 10);
      yearlyDetails = aggregateMonthlyData(_lastSavedData, currentYear);
      populateMonths();
      calculateYearlyTotals();
      generateYearGrid(_lastSavedData);
      displayAllTransactions();
      renderCharts();
      renderTagBar(_lastSavedData);
    }

    function populateYearDropdown(savedData) {
      const yearSelect = document.getElementById('yearSelect');
      const years = getYearsFromData(savedData);
      if (years.length === 0) years.push(currentYear);
      years.sort((a, b) => a - b);
      yearSelect.innerHTML = years.map(y =>
        `<option value="${y}" ${y === currentYear ? 'selected' : ''}>${y}</option>`
      ).join('');
    }

    function getYearsFromData(data) {
      const years = new Set();
      Object.values(data).forEach(dayData => {
        if (dayData.details) {
          dayData.details.forEach(detail => {
            const year = new Date(detail.date).getFullYear();
            years.add(year);
          });
        }
      });
      return Array.from(years);
    }

    function aggregateMonthlyData(data, year) {
      const result = initializeYearlyDetails();
      const alias = { September: 'Sep', Sept: 'Sep', March: 'Mar', April: 'Apr', June: 'Jun', July: 'Jul' };

      Object.entries(data).forEach(([key, value]) => {
        let [month, day] = key.split('-');
        month = (alias[month] || month);
        const details = (value.details || []).filter(d => new Date(d.date).getFullYear() === year);

        if (!result[month]) result[month] = { details: [] };
        details.forEach(detail => result[month].details.push(detail));
      });
      return result;
    }

    function createButton(className, textContent, dataMonth, onClickCallback) {
      const button = document.createElement('button');
      button.className = className;
      button.textContent = textContent;
      if (dataMonth) button.setAttribute('data-month', dataMonth);
      button.addEventListener('click', onClickCallback);
      return button;
    }

    function populateMonths(records /* optional: filtered records */) {
      const monthsContainer = document.querySelector('#months-container tbody');
      monthsContainer.innerHTML = '';

      // Build records if not provided (initial/full render)
      if (!records) {
        records = [];
        const savedData = _lastSavedData || {};
        const yr = currentYear;

        Object.entries(savedData).forEach(([dateKey, data]) => {
          const [monthName, dayStr] = dateKey.split('-');
          const mIdx = months.indexOf(monthName);
          const baseDate = new Date(yr, mIdx, parseInt(dayStr, 10)); // <- UI date

          const details = (data.details || []).filter(d =>
            new Date(d.date).getFullYear() === yr
          );

          details.forEach(d => {
            records.push({
              name: d.name ?? '',
              type: d.type ?? '',
              amount: Number(d.amount ?? 0),
              // IMPORTANT: use the UI date, not d.date
              _dateObject: baseDate,
              dateKey,
              tags: Array.isArray(d.tags) ? d.tags : []
            });
          });
        });
      }

      // Sum by the UI date (prefer _dateObject; fall back to dateKey)
      const sums = Array.from({ length: 12 }, () => ({ income: 0, expenses: 0 }));

      for (const r of records) {
        let dt = r._dateObject instanceof Date ? r._dateObject : null;

        if (!dt && r.dateKey) {
          const [mName, dayStr] = String(r.dateKey).split('-');
          const mIdx = months.indexOf(mName);
          const dNum = parseInt(dayStr, 10) || 1;
          dt = new Date(currentYear, mIdx, dNum);
        }
        if (!dt) {
          // last-resort fallback (shouldn't be needed now)
          dt = new Date(r.date);
        }

        if (!(dt instanceof Date) || Number.isNaN(dt.getTime())) continue;
        if (dt.getFullYear() !== currentYear) continue;

        const mi = dt.getMonth();
        const amt = Number(r.amount) || 0;
        const t = String(r.type || '').toLowerCase();
        if (t === 'income') sums[mi].income += amt;
        if (t === 'expenses' || t === 'expense') sums[mi].expenses += amt;
      }

      // Render rows
      months.forEach((month, i) => {
        const income = sums[i].income;
        const expenses = sums[i].expenses;
        const balance = income - expenses;

        const row = monthsContainer.insertRow();
        row.innerHTML = `
          <td>${month}</td>
          <td>${income.toFixed(2)}</td>
          <td>${expenses.toFixed(2)}</td>
          <td>${balance.toFixed(2)}</td>
          <td></td>
          <td></td>
        `;

        row.cells[4].appendChild(createButton('add-income', 'Add Income', month, () => addEntry('Income', month)));
        row.cells[5].appendChild(createButton('add-expense', 'Add Expense', month, () => addEntry('Expenses', month)));
      });
    }

    function calculateTotal(details, type) {
      return details.filter(detail => detail.type === type).reduce((acc, detail) => acc + (detail.amount || 0), 0);
    }

    function addEntry(type, selectedMonth) {
      const name = prompt(`Enter a name for this ${type}:`);
      if (!name) return;

      const amount = parseFloat(prompt(`Enter ${type} amount:`));
      if (isNaN(amount)) return;

      const year = currentYear;

      let inputDate = prompt(`Enter day of month for ${type} (1-31, default is today):`);
      let day = parseInt(inputDate, 10);
      if (isNaN(day) || day < 1 || day > 31) {
        console.warn("⚠️ Invalid day provided. Defaulting to today.");
        day = new Date().getDate();
      }

      const tagsInput = prompt('Add tags (comma-separated), optional:');
      const tags = parseTags(tagsInput);

      const monthIndex = months.indexOf(selectedMonth);
      if (monthIndex === -1) {
        console.error("❌ Error: Invalid month selected.");
        alert("Invalid month selection. Please try again.");
        return;
      }

      if (!yearlyDetails[selectedMonth]) {
        console.warn(`⚠️ Creating new entry for month: ${selectedMonth}`);
        yearlyDetails[selectedMonth] = { details: [] };
      }

      let entryDate = new Date(year, monthIndex, day);
      if (isNaN(entryDate.getTime())) {
        console.warn("⚠️ Invalid date detected. Defaulting to today.");
        entryDate = new Date();
      }

      const dateKey = `${selectedMonth}-${day}`;
      const newEntry = {
        name,
        type,
        amount,
        date: entryDate.toISOString(),
        tags
      };

      yearlyDetails[selectedMonth].details.push(newEntry);

      fetchSavedData().then(savedData => {
        if (!savedData[dateKey]) {
          console.warn(`⚠️ No existing data for ${dateKey}, creating new entry.`);
          savedData[dateKey] = { details: [] };
        }
        savedData[dateKey].details.push(newEntry);
        saveData(savedData);
      });
    }

    function calculateYearlyTotals() {
      let totalIncome = 0, totalExpenses = 0, totalTransactions = 0;

      months.forEach(month => {
        if (yearlyDetails[month]) {
          totalIncome += calculateTotal(yearlyDetails[month].details, 'Income');
          totalExpenses += calculateTotal(yearlyDetails[month].details, 'Expenses');
          totalTransactions += yearlyDetails[month].details.length;
        }
      });

      document.getElementById('total-income').textContent = totalIncome.toFixed(2);
      document.getElementById('total-expenses').textContent = totalExpenses.toFixed(2);
      document.getElementById('yearly-balance').textContent = (totalIncome - totalExpenses).toFixed(2);

      document.getElementById('total-transactions').textContent = totalTransactions;
    }

    function fetchOverallTotals(savedData) {
      let overallIncome = 0, overallExpenses = 0;

      Object.values(savedData).forEach(dayData => {
        if (dayData.details) {
          overallIncome += calculateTotal(dayData.details, 'Income');
          overallExpenses += calculateTotal(dayData.details, 'Expenses');
        }
      });

      document.getElementById('overall-income').textContent = overallIncome.toFixed(2);
      document.getElementById('overall-expenses').textContent = overallExpenses.toFixed(2);
      document.getElementById('overall-balance').textContent = (overallIncome - overallExpenses).toFixed(2);
    }

    function generateYearGrid(savedData) {
      const yearGrid = document.getElementById('year-grid');
      yearGrid.innerHTML = '';

      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const startOfYear = new Date(currentYear, 0, 1);
      const endOfYear = new Date(currentYear, 11, 31);

      for (let day = new Date(startOfYear); day <= endOfYear; day.setDate(day.getDate() + 1)) {
        const monthName = months[day.getMonth()];
        const dayOfMonth = day.getDate();
        const dateKey = `${monthName}-${dayOfMonth}`;

        const details = (savedData[dateKey]?.details || []).filter(entry =>
          new Date(entry.date).getFullYear() === currentYear
        );

        const income = details.filter(d => d.type === 'Income').reduce((s, d) => s + (d.amount || 0), 0);
        const expenses = details.filter(d => d.type === 'Expenses').reduce((s, d) => s + (d.amount || 0), 0);

        if (day.getDate() === 1) {
          const monthLabel = document.createElement('div');
          monthLabel.textContent = monthName;
          monthLabel.style.gridColumn = "1 / -1";
          yearGrid.appendChild(monthLabel);
        }

        const dayBlock = document.createElement('div');
        dayBlock.className = 'day-block';
        dayBlock.textContent = dayOfMonth;
        dayBlock.setAttribute('data-date', dateKey);

        if (day.toDateString() === today.toDateString()) dayBlock.classList.add('today');

        if (details.length > 0) {
          if (expenses > income) {
            dayBlock.classList.add('expenses-higher');
          } else {
            dayBlock.classList.add('has-data');
          }
        }

        dayBlock.addEventListener('click', () => displayDayDetails(dateKey));
        yearGrid.appendChild(dayBlock);
      }
    }

    function displayDayDetails(dateKey) {
      const savedData = _lastSavedData || {};
      const details = savedData[dateKey] || { details: [] };
      const modalContentElement = document.getElementById('modalContent');
      modalContentElement.innerHTML = '';

      const [month, day] = dateKey.split('-');
      const formattedDate = `${month} ${day}, ${currentYear}`;
      document.getElementById('date-selected').textContent = formattedDate;

      const filteredDetails = (details.details || []).filter(
        detail => new Date(detail.date).getFullYear() === currentYear
      );

      if (filteredDetails.length > 0) {
        const table = document.createElement('table');
        table.innerHTML = `
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Amount</th>
          <th>Tags</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody></tbody><br>
    `;
        const tbody = table.querySelector('tbody');

        filteredDetails.forEach((detail, index) => {
          const row = document.createElement('tr');
          row.innerHTML = `
        <td contenteditable="true" data-key="name">${detail.name ?? ''}</td>
        <td>${detail.type ?? ''}</td>
        <td contenteditable="true" data-key="amount">${(detail.amount ?? 0)}</td>
        <td contenteditable="true" data-key="tags">${formatTags(detail.tags || [])}</td>
        <td><button class="clear-button" onclick="deleteEntry('${dateKey}', ${index})">Delete</button></td>
      `;
          row.querySelectorAll('[contenteditable="true"]').forEach(cell => {
            cell.addEventListener('blur', (event) => {
              const key = event.target.dataset.key;
              let val = event.target.innerText;
              if (key === 'amount') {
                updateEntry(dateKey, index, 'amount', val);
              } else if (key === 'tags') {
                updateEntry(dateKey, index, 'tags', parseTags(val));
              } else {
                updateEntry(dateKey, index, key, val);
              }
            });
          });
          tbody.appendChild(row);
        });

        modalContentElement.appendChild(table);
      } else {
        modalContentElement.innerHTML = "<p>No details available for this date.</p>";
      }

      modalContentElement.appendChild(createButton('', 'Add Income', null, () => addEntryFromModal(dateKey, 'Income')));
      modalContentElement.appendChild(createButton('', 'Add Expense', null, () => addEntryFromModal(dateKey, 'Expenses')));

      document.getElementById('detailsModal').style.display = 'block';
    }

    function addEntryFromModal(dateKey, type) {
      const name = prompt(`Enter a name for this ${type}:`);
      if (!name) return;

      const amount = parseFloat(prompt(`Enter ${type} amount:`));
      if (isNaN(amount)) return;

      const year = currentYear;

      const [month, dayStr] = dateKey.split('-');
      const day = parseInt(dayStr, 10) || 1;

      const tagsInput = prompt('Add tags (comma-separated), optional:');
      const tags = parseTags(tagsInput);

      const newEntry = {
        name,
        type,
        amount,
        date: new Date(year, months.indexOf(month), day).toISOString(),
        tags
      };

      fetchSavedData().then(savedData => {
        if (!savedData[dateKey]) savedData[dateKey] = { details: [] };
        savedData[dateKey].details.push(newEntry);
        saveData(savedData);
        displayDayDetails(dateKey);
      });
    }

    window.deleteEntry = async function deleteEntry(dateKey, entryIndex) {
      if (!confirm("Are you sure you want to delete this entry?")) return;

      try {
        let savedData = await fetchSavedData();

        if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
          const filteredEntries = savedData[dateKey].details.filter(detail =>
            new Date(detail.date).getFullYear() === currentYear
          );

          if (filteredEntries.length > entryIndex) {
            const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
            if (globalIndex !== -1) {
              savedData[dateKey].details.splice(globalIndex, 1);
            }

            if (savedData[dateKey].details.length === 0) {
              delete savedData[dateKey];
            }

            await saveData(savedData);
            console.log(`✅ Successfully deleted entry from ${dateKey} (${currentYear})`);

            displayDayDetails(dateKey);
          } else {
            console.warn("⚠️ No entry found for deletion in the current year.");
          }
        } else {
          console.warn("⚠️ No entry found for deletion or index out of bounds.");
        }
      } catch (error) {
        console.error("❌ Error fetching or updating saved data:", error);
      }
    };

    async function updateEntry(dateKey, entryIndex, field, newValue) {
      let savedData = await fetchSavedData();

      if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
        const filteredEntries = savedData[dateKey].details.filter(detail =>
          new Date(detail.date).getFullYear() === currentYear
        );

        if (filteredEntries.length > entryIndex) {
          const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
          if (globalIndex !== -1) {
            if (field === "amount") {
              newValue = parseFloat(newValue);
              if (isNaN(newValue)) return;
            }
            if (field === "tags") {
              if (!Array.isArray(newValue)) newValue = parseTags(String(newValue ?? ''));
            }

            savedData[dateKey].details[globalIndex][field] = newValue;

            await saveData(savedData);
          }
        }
      }
    }

    async function loadJSONData(event) {
      const file = event.target.files[0];
      if (file && file.type === "application/json") {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          mergeAndUpdateData(data);
          event.target.value = '';
        } catch (error) {
          console.error("Error reading or parsing file", error);
          alert("Failed to load data. Please ensure the file is a valid JSON format.");
        }
      } else {
        alert("Please select a JSON file.");
      }
    }

    function mergeAndUpdateData(newData) {
      fetchSavedData().then(savedData => {
        Object.keys(newData).forEach(key => {
          if (!savedData[key]) savedData[key] = { details: [] };
          savedData[key].details = [...savedData[key].details, ...newData[key].details];
        });
        saveData(savedData);
      });
    }

    function clearDetails() {
      if (confirm("Are you sure you want to clear all data? This cannot be undone.")) {
        set(ref(database, `${DATABASE_BASE_PATH}/budget`), {});
        alert("All data has been cleared.");
      }
    }

    async function fetchSavedData() {
      try {
        const snapshot = await get(ref(database, `${DATABASE_BASE_PATH}/budget`));
        return snapshot.exists() ? snapshot.val() : {};
      } catch (error) {
        console.error("❌ Error fetching saved data:", error);
        return {};
      }
    }

    function saveData(data) {
      set(ref(database, `${DATABASE_BASE_PATH}/budget`), data);
    }

    function closeModal() {
      document.getElementById('detailsModal').style.display = "none";
    }

    async function displayAllTransactions() {

      const savedData = _lastSavedData || {};
      const tbody = document.querySelector('#transactions-table tbody');
      tbody.innerHTML = '';

      const input = document.getElementById('global-search');
      const query = input ? (input.value ?? '') : '';

      const current = currentYear;
      const records = [];

      // Flatten DB → records for selected year
      Object.entries(savedData).forEach(([dateKey, data]) => {
        const [monthName, dayStr] = dateKey.split('-');
        const monthIndex = months.indexOf(monthName);
        const dateObject = new Date(current, monthIndex, parseInt(dayStr, 10));

        const details = (data.details || []).filter(d =>
          new Date(d.date).getFullYear() === current
        );

        details.forEach((detail, index) => {
          records.push({
            name: (detail.name ?? ''),
            type: (detail.type ?? ''),
            amount: Number(detail.amount ?? 0),
            date: new Date(detail.date || dateObject),
            dateKey,
            _dateObject: dateObject,
            _detail: detail,
            _index: index,
            // NEW: tags into records for search
            tags: Array.isArray(detail.tags) ? detail.tags : []
          });
        });
      });

      const filtered = _engine ? _engine.filter(records, query) : simpleFilter(records, query);

      // Totals for the filtered set
      updateFilteredTotal(filtered.map(r => r._detail));

      // Sort & render
      filtered.sort((a, b) => a._dateObject - b._dateObject);

      filtered.forEach(rec => {
        const { dateKey, _detail: detail, _index: index } = rec;

        const tr = document.createElement('tr');
        tr.classList.add('transaction-row');

        const tdDate = document.createElement('td');
        tdDate.textContent = dateKey;

        const tdName = document.createElement('td');
        tdName.contentEditable = 'true';
        tdName.dataset.key = 'name';
        tdName.textContent = detail.name || 'Unknown';
        tdName.addEventListener('focus', e => { e.target.dataset.original = e.target.innerText.trim(); });
        tdName.addEventListener('blur', e => {
          const next = e.target.innerText.trim();
          const prev = (e.target.dataset.original ?? '').trim();
          if (next === prev) return;
          updateTransactionEntry(dateKey, index, 'name', next);
        });

        const tdType = document.createElement('td');
        tdType.appendChild(
          createTypeSelect(detail.type || 'Expenses', async newVal => {
            await updateTransactionEntry(dateKey, index, 'type', newVal);
            handleYearChange();
          })
        );

        const tdAmount = document.createElement('td');
        tdAmount.contentEditable = 'true';
        tdAmount.dataset.key = 'amount';
        tdAmount.textContent = (detail.amount ?? 0).toFixed(2);
        tdAmount.addEventListener('focus', e => { e.target.dataset.original = String(detail.amount ?? 0); });
        tdAmount.addEventListener('blur', e => {
          let v = parseFloat(e.target.innerText.replace(/[^\d.-]/g, ''));
          if (isNaN(v)) { e.target.textContent = (detail.amount ?? 0).toFixed(2); return; }
          const prev = parseFloat(e.target.dataset.original ?? 'NaN');
          if (!isNaN(prev) && v === prev) { e.target.textContent = prev.toFixed(2); return; }
          e.target.textContent = v.toFixed(2);
          updateTransactionEntry(dateKey, index, 'amount', v);
        });

        const tdTags = document.createElement('td');
        tdTags.contentEditable = 'true';
        tdTags.dataset.key = 'tags';
        tdTags.textContent = formatTags(detail.tags || []);
        tdTags.addEventListener('focus', e => { e.target.dataset.original = e.target.innerText.trim(); });
        tdTags.addEventListener('blur', async e => {
          const next = e.target.innerText.trim();
          const prev = (e.target.dataset.original ?? '').trim();
          if (next === prev) return;
          const tagsArr = parseTags(next);
          await updateTransactionEntry(dateKey, index, 'tags', tagsArr);
          handleYearChange();
        });

        const tdActions = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.className = 'clear-button';
        delBtn.textContent = 'x';
        delBtn.addEventListener('click', () => { deleteTransactionEntry(dateKey, index); });
        tdActions.appendChild(delBtn);

        tr.append(tdDate, tdName, tdType, tdAmount, tdTags, tdActions);
        tbody.appendChild(tr);
      });
      populateMonths(filtered);
    }

    window.filterGlobalEntries = function filterGlobalEntries() {
      displayAllTransactions();
    };

    async function updateTransactionEntry(dateKey, entryIndex, field, newValue) {
      let savedData = await fetchSavedData();

      if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
        const filteredEntries = savedData[dateKey].details.filter(detail =>
          new Date(detail.date).getFullYear() === currentYear
        );

        if (filteredEntries.length > entryIndex) {
          const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
          if (globalIndex !== -1) {
            if (field === "amount") {
              newValue = parseFloat(newValue);
              if (isNaN(newValue)) return;
            }
            if (field === "tags") {
              if (!Array.isArray(newValue)) newValue = parseTags(String(newValue ?? ''));
            }

            savedData[dateKey].details[globalIndex][field] = newValue;

            await saveData(savedData);
          }
        }
      }
    }

    function updateFilteredTotal(filteredData) {
      let totalIncome = 0;
      let totalExpenses = 0;

      for (const detail of filteredData) {
        const amt = Number(detail?.amount) || 0;
        const t = String(detail?.type || '').toLowerCase();
        if (t === 'income') {
          totalIncome += amt;
        } else if (t === 'expenses' || t === 'expense') {
          totalExpenses += amt;
        }
      }

      const net = totalIncome - totalExpenses;
      const fmt = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });

      const el = document.getElementById('filtered-total');
      el.textContent = `Filtered Total: ${fmt.format(net)} (Income: ${fmt.format(totalIncome)} • Expenses: ${fmt.format(totalExpenses)})`;
    }

    function simpleFilter(records, query) {
      const q = String(query || '').trim();
      if (!q) return records;

      // Support: tags:<word> or tags:"two words"
      const m = q.match(/tags\s*:\s*(?:"([^"]+)"|([^\s]+))/i);
      if (!m) return records;

      const want = (m[1] || m[2] || '').toLowerCase();
      if (!want) return records;

      return records.filter(r =>
        Array.isArray(r.tags) &&
        r.tags.some(t => String(t).toLowerCase() === want)
      );
    }

    function createTypeSelect(currentType, onChange) {
      const sel = document.createElement('select');
      ['Income', 'Expenses'].forEach(optVal => {
        const opt = document.createElement('option');
        opt.value = optVal;
        opt.textContent = optVal;
        if ((currentType || '').toLowerCase() === optVal.toLowerCase()) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', e => onChange(e.target.value));
      return sel;
    }

    window.deleteTransactionEntry = async function deleteTransactionEntry(dateKey, entryIndex) {
      if (!confirm("Are you sure you want to delete this entry?")) return;

      try {
        let savedData = await fetchSavedData();

        if (savedData[dateKey] && savedData[dateKey].details.length > entryIndex) {
          const filteredEntries = savedData[dateKey].details.filter(detail =>
            new Date(detail.date).getFullYear() === currentYear
          );

          if (filteredEntries.length > entryIndex) {
            const globalIndex = savedData[dateKey].details.indexOf(filteredEntries[entryIndex]);
            if (globalIndex !== -1) {
              savedData[dateKey].details.splice(globalIndex, 1);
            }

            if (savedData[dateKey].details.length === 0) {
              delete savedData[dateKey];
            }

            await saveData(savedData);

            handleYearChange();
            displayAllTransactions();
          } else {
            console.warn("⚠️ No entry found for deletion in the current year.");
          }
        } else {
          console.warn("⚠️ No entry found for deletion or index out of bounds.");
        }
      } catch (error) {
        console.error("❌ Error deleting entry:", error);
      }
    };

    function exportDetailsToJSON() {
      fetchSavedData().then(savedData => {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(savedData, null, 2));
        const a = document.createElement('a');
        a.setAttribute("href", dataStr);
        a.setAttribute("download", `financial_tracker_backup_${new Date().toISOString().slice(0, 10)}.json`);
        document.body.appendChild(a);
        a.click();
        a.remove();
      });
    }

    /**
     * Import a JSON file and REPLACE existing data at `${DATABASE_BASE_PATH}/budget`.
     */
    async function importJSONReplaceExisting(event) {
      const file = event.target.files?.[0];
      event.target.value = '';

      if (!file) return;

      const warned = confirm(
        "⚠️ WARNING: Importing will REPLACE all current data.\n\n" +
        "Please export a BACKUP first (use the Export button).\n\n" +
        "Click OK to continue to file validation, or Cancel to stop."
      );
      if (!warned) return;

      let parsed;
      try {
        const text = await file.text();
        parsed = JSON.parse(text);
      } catch (err) {
        console.error("Failed to read/parse JSON:", err);
        alert("❌ Failed to read or parse the JSON file. Make sure it's valid JSON.");
        return;
      }

      const isObj = parsed && typeof parsed === 'object' && !Array.isArray(parsed);
      if (!isObj) {
        alert("❌ Invalid format: root must be an object of { 'Mon-1': { details: [...] }, ... }");
        return;
      }

      let dayBuckets = 0, entries = 0;
      try {
        Object.values(parsed).forEach(v => {
          dayBuckets++;
          const arr = (v && Array.isArray(v.details)) ? v.details : [];
          entries += arr.length;
        });
      } catch (_) { }

      const confirmReplace = confirm(
        `This will OVERWRITE existing data at "Budget".\n\n` +
        `About to import ~${dayBuckets} day buckets and ~${entries} entries.\n\n` +
        "Are you sure? Click OK to replace, or Cancel to abort."
      );
      if (!confirmReplace) return;

      try {
        await set(ref(database, `${DATABASE_BASE_PATH}/budget`), parsed);
        alert("✅ Import complete. Data has been replaced.");
      } catch (err) {
        console.error("Error writing imported data:", err);
        alert("❌ Failed to write imported data. See console for details.");
      }
    }

    // For quoting tags with spaces/quotes in search queries
    function quoteForQuery(s) {
      if (s == null) return '';
      const hasSpaceOrQuote = /[\s"]/g.test(s);
      const safe = String(s).replace(/"/g, '\\"');
      return hasSpaceOrQuote ? `"${safe}"` : safe;
    }

    // Build a tag index for the CURRENT YEAR from savedData
    function buildTagIndex(savedData) {
      const map = new Map();
      for (const [dateKey, bucket] of Object.entries(savedData || {})) {
        const details = Array.isArray(bucket?.details) ? bucket.details : [];
        for (const d of details) {
          if (!d?.date || new Date(d.date).getFullYear() !== currentYear) continue;
          const tags = Array.isArray(d.tags) ? d.tags : [];
          for (const raw of tags) {
            const t = String(raw || '').trim();
            if (!t) continue;
            const key = t.toLowerCase();
            const prev = map.get(key);
            if (prev) {
              prev.count += 1;
            } else {
              map.set(key, { label: t, count: 1 });
            }
          }
        }
      }
      // Sort by count desc, then alpha
      return Array.from(map.values())
        .sort((a, b) => b.count - a.count || a.label.localeCompare(b.label));
    }

    // Render clickable chips and wire them to the search box
    function renderTagBar(savedData) {
      const bar = document.getElementById('tag-bar');
      if (!bar) return;
      bar.innerHTML = '';

      const tags = buildTagIndex(savedData);
      if (!tags.length) {
        const empty = document.createElement('span');
        empty.textContent = 'No tags for this year.';
        empty.style.opacity = '0.7';
        bar.appendChild(empty);
        return;
      }

      // Clear chip
      const clear = document.createElement('button');
      clear.type = 'button';
      clear.className = 'tag-chip';
      clear.textContent = 'Clear';
      clear.addEventListener('click', () => {
        const input = document.getElementById('global-search');
        if (input) {
          input.value = '';
          filterGlobalEntries();
        }
        bar.querySelectorAll('.tag-chip').forEach(el => el.classList.remove('active'));
      });
      bar.appendChild(clear);

      // Tag chips
      tags.forEach(({ label, count }) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tag-chip';
        btn.title = `Filter by tag: ${label}`;
        btn.textContent = `${label} (${count})`;
        btn.addEventListener('click', (e) => {
          applyTagFilter(label);
          bar.querySelectorAll('.tag-chip').forEach(el => el.classList.remove('active'));
          btn.classList.add('active');
        });
        bar.appendChild(btn);
      });
    }

    function applyTagFilter(tag) {
      const input = document.getElementById('global-search');
      if (!input) return;
      input.value = `tags:${quoteForQuery(tag)}`;
      filterGlobalEntries();
      input.focus();
    }

    function exportTagsCSV() {
      const savedData = _lastSavedData || {};
      const monthNames = months;
      const FILTER_YEAR = currentYear; // 👈 only export for the selected year

      // tagKey -> aggregate
      const map = new Map();

      for (const bucket of Object.values(savedData)) {
        const details = Array.isArray(bucket?.details) ? bucket.details : [];
        for (const d of details) {
          if (!d?.date) continue;
          const dt = new Date(d.date);
          if (Number.isNaN(dt.getTime())) continue;

          // year filter
          if (dt.getFullYear() !== FILTER_YEAR) continue;

          const tags = Array.isArray(d.tags) ? d.tags : [];
          if (!tags.length) continue;

          const isInc = String(d.type || '').toLowerCase() === 'income';
          const isExp = ['expenses', 'expense'].includes(String(d.type || '').toLowerCase());
          const amt = Number(d.amount) || 0;
          const monthAbbr = monthNames[dt.getMonth()];

          for (const rawTag of tags) {
            const t = String(rawTag || '').trim();
            if (!t) continue;

            const key = t.toLowerCase();
            let agg = map.get(key);
            if (!agg) {
              agg = {
                tagLabel: t,
                latestDate: null,
                latestName: '',
                monthsSet: new Set(),
                income: 0,
                expenses: 0,
                count: 0
              };
              map.set(key, agg);
            }

            if (isInc) agg.income += amt;
            if (isExp) agg.expenses += amt;
            agg.count += 1;
            agg.monthsSet.add(monthAbbr);

            if (!agg.latestDate || dt > agg.latestDate) {
              agg.latestDate = dt;
              agg.latestName = String(d.name ?? '').trim();
            }
          }
        }
      }

      if (map.size === 0) {
        alert(`No tagged entries found for ${FILTER_YEAR}.`);
        return;
      }

      const rows = [];
      rows.push(['Tag', 'Year', 'LatestDate', 'NameWithMonths', 'IncomeTotal', 'ExpensesTotal', 'NetTotal', 'Occurrences']);

      const sorted = Array.from(map.values()).sort((a, b) => {
        const at = a.latestDate ? a.latestDate.getTime() : 0;
        const bt = b.latestDate ? b.latestDate.getTime() : 0;
        if (bt !== at) return bt - at;
        return a.tagLabel.localeCompare(b.tagLabel);
      });

      for (const agg of sorted) {
        const monthsList = monthNames.filter(m => agg.monthsSet.has(m));
        const latestDateStr = agg.latestDate ? agg.latestDate.toISOString().slice(0, 10) : '';
        const nameWithMonths = `${agg.latestName || ''} (${monthsList.join(', ')})`.trim();
        const net = agg.income - agg.expenses;

        rows.push([
          agg.tagLabel,
          String(FILTER_YEAR),
          latestDateStr,
          nameWithMonths,
          agg.income.toFixed(2),
          agg.expenses.toFixed(2),
          net.toFixed(2),
          String(agg.count)
        ]);
      }

      const csv = rows.map(r => r.map(csvEscape).join(',')).join('\n');

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `tags_summary_${FILTER_YEAR}.csv`; // 👈 year in filename
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function csvEscape(v) {
      const s = String(v ?? '');
      return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
    }

  </script>
</body>

</html>