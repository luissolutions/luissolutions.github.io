<!DOCTYPE html>
<html lang="en">

<head>
    <title>Online Task Manager</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./assets/css/app-styles.css" id="stylesheet">
    <script type="module" src="./assets/js/login.js" defer></script>
    <style>
        @media (max-width: 768px) {

            input,
            button,
            textarea {
                width: 95%;
            }

            header button,
            .checkbox input {
                width: auto;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip-utils/0.1.0/jszip-utils.min.js"></script>
</head>

<body>
    <header>
        <h1>Online Task Manager</h1>
        <section id="login-section">
            <form id="login-form">
                <label for="username">Email:</label>
                <input type="email" id="username" required>
                <br>
                <label for="password">Password:</label>
                <input type="password" id="password" required>
                <br>
                <button type="submit">Login</button>
            </form>
            <button id="logout" style="display: none;">Logout</button>
        </section>
        <button id="goToBottomBtn">⤓</button>
    </header>

    <main>
        <section id="task-manager" class="app-section">

            <div>
                <div class="name-column-input">
                    <input type="text" id="taskName" placeholder="Name">
                </div>
                <div class="project-column-input">
                    <input type="text" id="project" placeholder="Project">
                </div>
                <div class="start-odometer-column-input odometer-input">
                    <input type="number" id="startOdometer" placeholder="Start Odometer">
                </div>
                <div class="end-odometer-column-input odometer-input">
                    <input type="number" id="endOdometer" placeholder="End Odometer" disabled>
                </div>
                <div class="address-column-input">
                    <input type="text" id="customerAddress" placeholder="Address">
                </div>
                <div class="notes-column-input">
                    <textarea id="taskNotes" placeholder="Notes"></textarea>
                </div>
                <button id="updateTaskBtn" style="display: none;">Update Task</button>
                <button id="toggleTimer">Start/Stop Timer</button>
                <div>Timer: <span id="currentTaskTime">00:00:00</span></div>
            </div>

            <div id="imageUploadSection" class="hidden">
                <p>Images for Task</p>
                <input type="file" id="fileUploader" accept="image/*">
                <input type="text" id="imageNameInput" placeholder="Enter Image Name">
                <button id="uploadButton">Upload Image</button>
                <br>
                <label for="imageSelect">Existing Images:</label>
                <select id="imageSelect">
                    <option value="" disabled selected>Select Image</option>
                </select>
                <div class="photoGrid">
                    <div id="photoContainer"></div>
                    <div id="paginationControls"></div>
                </div>
                <div id="loadingIndicator" style="display: none;">Loading images...</div>
                <button id="deleteImageButton">Delete Selected Image</button>
            </div>

            <div>
                <br>
                <label for="searchTask">Search <span id="totalTasks">0</span> Tasks:</label>
                <input type="text" id="searchTask" placeholder="Enter Name">
            </div>

            <div>
                <label for="taskSelect">Select Task:</label>
                <select id="taskSelect">
                    <option value="" disabled selected>Select Task</option>
                </select>
            </div>

            <div class="checkbox">
                <label style="display: none;"><input type="checkbox" class="toggle-column" value="name-column" checked>
                    Name</label>
                <label><input type="checkbox" class="toggle-column" value="project-column" checked>
                    Project |</label>
                <label><input type="checkbox" class="toggle-column" value="address-column"> Address |</label>
                <label><input type="checkbox" class="toggle-column" value="odometer-column"> Mileage |</label>
                <label><input type="checkbox" class="toggle-column" value="location-column">
                    Location |</label>
                <label><input type="checkbox" class="toggle-column" value="start-time-column" checked> Start
                    Time |</label>
                <label><input type="checkbox" class="toggle-column" value="end-time-column" checked> End Time |</label>
                <label><input type="checkbox" class="toggle-column" value="length-column" checked> Length |</label>
                <label><input type="checkbox" class="toggle-column" value="notes-column" checked> Notes</label>
            </div>

            <div class="table">
                <table id="task-log">
                    <thead>
                        <tr>
                            <th class="name-column">Name</th>
                            <th class="project-column">Project</th>
                            <th class="address-column">Address</th>
                            <th class="start-odometer-column odometer-column">Start Odometer</th>
                            <th class="end-odometer-column odometer-column">End Odometer</th>
                            <th class="distance-column odometer-column">Distance</th>
                            <th class="location-column">Location</th>
                            <th class="start-time-column">Start Time</th>
                            <th class="end-time-column">End Time</th>
                            <th class="length-column">Length</th>
                            <th class="notes-column">Notes</th>
                            <th class="actions-column">Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <div>
                <h3>Hours (last 14 days):</h3>
                <span id="dailyTimeSpent"></span>
            </div>

            <div>
                <b>Total Hours (all time): </b><span id="totalHours">0</span>
            </div>
            <div id="date-range-picker" class="app-section">
                <h3>Hours Between Dates:</h3>
                <label for="startDate">Start:</label>
                <input type="datetime-local" id="startDate">
                <label for="endDate">End:</label>
                <input type="datetime-local" id="endDate">
                <button id="calculateHoursBtn">Calculate Hours</button>
                <div>Total Hours Between Dates: <span id="calculatedHours">0</span></div>
            </div>

            <div id="buttons"></div>

            <button id="goToTopBtn">Go to Top ⤒</button>

        </section>
    </main>

    <script type="module">
        import { database, ref, set, get, push, onValue, remove, update, storageRef, uploadBytesResumable, getDownloadURL, deleteObject, listAll, getStorage, storage } from './assets/js/firebase-init.js';

        const taskNameInput = document.getElementById('taskName');
        const projectInput = document.getElementById('project');
        const customerAddressInput = document.getElementById('customerAddress');
        const taskNotesTextarea = document.getElementById('taskNotes');
        const startOdometerInput = document.getElementById('startOdometer');
        const endOdometerInput = document.getElementById('endOdometer');
        const toggleTimerBtn = document.getElementById('toggleTimer');
        const taskLogTable = document.getElementById('task-log').getElementsByTagName('tbody')[0];
        const totalHoursSpan = document.getElementById('totalHours');
        const currentTaskTimeDisplay = document.getElementById('currentTaskTime');
        const deleteImageButton = document.getElementById('deleteImageButton');
        const updateTaskBtn = document.getElementById('updateTaskBtn');
        const fileUploader = document.getElementById('fileUploader');
        const imageNameInput = document.getElementById('imageNameInput');
        const uploadButton = document.getElementById('uploadButton');

        let sortOrder = 'asc';

        let currentTask = null;
        let timerInterval = null;
        let currentTaskId = null;
        let imageUrls = [];
        let currentPage = 1;
        let imagesPerPage = 6;
        let totalPages = 0;

        document.querySelectorAll('.toggle-column').forEach(checkbox => {
            checkbox.addEventListener('change', toggleColumnVisibility);
        });

        function toggleTimer() {
            currentTask ? endTask() : startTask();
        }

        function startTask() {
            const taskName = taskNameInput.value.trim();
            const project = projectInput.value.trim();
            const startOdometer = startOdometerInput.value.trim();
            const customerAddress = customerAddressInput.value.trim();

            if (!taskName) {
                alert('Please enter a task name');
                return;
            }

            const handleTaskStart = (location) => {
                currentTask = {
                    id: Date.now().toString(),
                    customerName: taskName,
                    project: project,
                    customerAddress: customerAddress,
                    notes: taskNotesTextarea.value.trim(),
                    startOdometer,
                    endOdometer: null,
                    location,
                    startTime: new Date().toISOString(),
                    endTime: null
                };
                saveTask(currentTask);
                timerInterval = setInterval(updateCurrentTaskTime, 1000);
                endOdometerInput.disabled = false;
            };

            if (typeof getGeolocation === 'function') {
                getGeolocation(location => {
                    handleTaskStart(location);
                });
            } else {
                const fallbackLocation = { latitude: "NA", longitude: "NA" };
                handleTaskStart(fallbackLocation);
            }
        }

        function endTask() {
            clearInterval(timerInterval);
            currentTask.endOdometer = endOdometerInput.value.trim();
            currentTask.endTime = new Date().toISOString();
            currentTask.notes = taskNotesTextarea.value.trim();
            saveTask(currentTask);
            updateTaskInTable(currentTask);
            resetTimerState();
            updateTotalHours();
            applyColumnVisibility();
        }

        function saveTask(task) {
            const taskRef = ref(database, `share/tasks/${task.id}`);
            set(taskRef, task);
        }

        function updateTaskInTable(task) {
            const existingRow = document.querySelector(`[data-task-id="${task.id}"]`);
            if (existingRow) {
                updateRow(existingRow, task);
            } else {
                addTaskToTable(task);
            }
        }

        function addTaskToTable(task) {
            const row = taskLogTable.insertRow();
            row.dataset.taskId = task.id;
            updateRow(row, task);
            applyColumnVisibility();
        }

        function updateRow(row, task) {
            row.innerHTML = '';

            const nameCell = row.insertCell(0);
            const projectCell = row.insertCell(1);
            const addressCell = row.insertCell(2);
            const startOdometerCell = row.insertCell(3);
            const endOdometerCell = row.insertCell(4);
            const distanceCell = row.insertCell(5);
            const locationCell = row.insertCell(6);
            const startTimeCell = row.insertCell(7);
            const endTimeCell = row.insertCell(8);
            const lengthCell = row.insertCell(9);
            const notesCell = row.insertCell(10);
            const actionsCell = row.insertCell(11);

            nameCell.classList.add('name-column');
            projectCell.classList.add('project-column');
            addressCell.classList.add('address-column');
            startOdometerCell.classList.add('start-odometer-column', 'odometer-column');
            endOdometerCell.classList.add('end-odometer-column', 'odometer-column');
            distanceCell.classList.add('distance-column', 'odometer-column');
            locationCell.classList.add('location-column');
            startTimeCell.classList.add('start-time-column');
            endTimeCell.classList.add('end-time-column');
            lengthCell.classList.add('length-column');
            notesCell.classList.add('notes-column');

            nameCell.innerText = task.customerName;
            projectCell.innerText = task.project;
            startOdometerCell.innerText = task.startOdometer;
            endOdometerCell.innerText = task.endOdometer;
            distanceCell.innerText = task.endOdometer ? calculateDistance(task.startOdometer, task.endOdometer) : '';
            locationCell.innerText = task.location ? `Lat: ${task.location.latitude} Long: ${task.location.longitude}` : '';
            startTimeCell.innerText = formatDateTime(task.startTime);
            endTimeCell.innerText = task.endTime ? formatDateTime(task.endTime) : '';
            lengthCell.innerText = task.endTime ? calculateTaskLength(task) : '';
            notesCell.innerText = task.notes;

            if (task.customerAddress) {
                const addressLink = document.createElement('a');
                const googleMapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(task.customerAddress)}`;
                addressLink.href = googleMapsUrl;
                addressLink.target = '_blank';
                addressLink.innerText = task.customerAddress;
                addressCell.appendChild(addressLink);
            } else {
                addressCell.innerText = 'No Address';
            }

            const loadTaskButton = document.createElement('button');
            loadTaskButton.innerText = 'Load';
            loadTaskButton.addEventListener('click', () => {
                loadTaskForEditing(task.id);
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            actionsCell.appendChild(loadTaskButton);

            nameCell.contentEditable = true;
            projectCell.contentEditable = true;
            startOdometerCell.contentEditable = true;
            endOdometerCell.contentEditable = true;
            startTimeCell.contentEditable = true;
            endTimeCell.contentEditable = true;
            notesCell.contentEditable = true;

            nameCell.addEventListener('blur', () => updateTaskField(task.id, 'customerName', nameCell.innerText));
            projectCell.addEventListener('blur', () => updateTaskField(task.id, 'project', projectCell.innerText));
            startOdometerCell.addEventListener('blur', () => updateTaskField(task.id, 'startOdometer', startOdometerCell.innerText));
            endOdometerCell.addEventListener('blur', () => updateTaskField(task.id, 'endOdometer', endOdometerCell.innerText));
            startTimeCell.addEventListener('blur', () => updateTaskField(task.id, 'startTime', new Date(startTimeCell.innerText).toISOString()));
            endTimeCell.addEventListener('blur', () => updateTaskField(task.id, 'endTime', new Date(endTimeCell.innerText).toISOString()));
            notesCell.addEventListener('blur', () => updateTaskField(task.id, 'notes', notesCell.innerText));

            const deleteButton = document.createElement('button');
            deleteButton.classList.add('clear-button');
            deleteButton.innerText = 'Delete';
            deleteButton.addEventListener('click', () => confirmDeleteTask(task.id, row));
            actionsCell.appendChild(deleteButton);
        }

        async function loadTaskForEditing(taskId) {
            currentTaskId = taskId;
            const taskRef = ref(database, `share/tasks/${taskId}`);

            const snapshot = await get(taskRef);
            if (snapshot.exists()) {
                const task = snapshot.val();
                taskNameInput.value = task.customerName || '';
                projectInput.value = task.project || '';
                taskNotesTextarea.value = task.notes || '';
                startOdometerInput.value = task.startOdometer || '';
                endOdometerInput.value = task.endOdometer || '';
                customerAddressInput.value = task.customerAddress || '';
                endOdometerInput.disabled = !task.endOdometer;

                loadTaskImages(task.project);
                changeTimerButtonToRefresh();
                updateTaskBtn.style.display = 'inline-block';

            } else {
                console.error('Task not found');
            }
        }

        function changeTimerButtonToRefresh() {
            toggleTimerBtn.removeEventListener('click', toggleTimer);

            toggleTimerBtn.innerText = 'Refresh Page';

            toggleTimerBtn.addEventListener('click', () => {
                location.reload();
            });
        }

        function confirmDeleteTask(taskId, row) {
            if (confirm('Are you sure you want to delete this task?')) {
                deleteTask(taskId, row);
            }
        }

        function deleteTask(taskId, row) {
            const taskRef = ref(database, `share/tasks/${taskId}`);
            remove(taskRef).then(() => {
                if (row && row.parentNode) {
                    row.parentNode.removeChild(row);
                }
                updateTotalHours();
            }).catch(error => {
                console.error('Error removing task:', error);
            });
        }

        function calculateTaskLength(task) {
            const startTime = new Date(task.startTime);
            const endTime = new Date(task.endTime);
            const lengthInSeconds = (endTime - startTime) / 1000;

            const hours = Math.floor(lengthInSeconds / 3600);
            const minutes = Math.floor((lengthInSeconds % 3600) / 60);
            const seconds = Math.floor(lengthInSeconds % 60);

            const decimalHours = (lengthInSeconds / 3600).toFixed(2);

            return `${hours}:${minutes}:${seconds} (${decimalHours})`;
        }

        function calculateDistance(startOdometer, endOdometer) {
            const distance = endOdometer - startOdometer;
            return distance;
        }

        function formatDateTime(dateTime) {
            const date = new Date(dateTime);
            return `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
        }

        function updateCurrentTaskTime() {
            if (currentTask) {
                const length = calculateTaskLength({
                    startTime: currentTask.startTime,
                    endTime: new Date().toISOString()
                });
                currentTaskTimeDisplay.innerText = length;
            }
        }

        function updateTotalHours() {
            const taskRef = ref(database, 'share/tasks');
            onValue(taskRef, snapshot => {
                let totalSeconds = 0;
                snapshot.forEach(taskSnapshot => {
                    const task = taskSnapshot.val();
                    if (task.endTime) {
                        const lengthInSeconds = (new Date(task.endTime) - new Date(task.startTime)) / 1000;
                        totalSeconds += lengthInSeconds;
                    }
                });
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const decimalHours = (totalSeconds / 3600).toFixed(2);
                totalHoursSpan.innerText = `${hours} hours, ${minutes} minutes (${decimalHours})`;
            });
        }

        function loadTasks() {
            const taskRef = ref(database, 'share/tasks');
            onValue(taskRef, snapshot => {
                taskLogTable.innerHTML = '';
                let taskCount = 0;

                snapshot.forEach(taskSnapshot => {
                    const task = taskSnapshot.val();
                    addTaskToTable(task);
                    taskCount++;
                });
                document.getElementById('totalTasks').innerText = taskCount;
                sortTableByColumn(7);
                updateTotalHours();
                applyColumnVisibility();
            });
        }

        function resetTimerState() {
            clearInterval(timerInterval);
            currentTask = null;
            taskNameInput.value = '';
            projectInput.value = '';
            taskNotesTextarea.value = '';
            startOdometerInput.value = '';
            endOdometerInput.value = '';
            customerAddressInput.value = '';
            endOdometerInput.disabled = true;
            currentTaskTimeDisplay.innerText = '00:00:00';
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadTasks();
            checkForOngoingTask();
            loadColumnVisibility();
            applyColumnVisibility();
            processTasksForDailyTimeSpent();

            document.querySelectorAll('.toggle-column').forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    saveColumnVisibility();
                    applyColumnVisibility();
                });
            });
        });

        function updateTaskField(taskId, field, value) {
            const taskRef = ref(database, `share/tasks/${taskId}`);
            update(taskRef, { [field]: value })
                .then(() => {
                    console.log(`Task ${taskId} updated: ${field} = ${value}`);
                    applySearchFilter();
                })
                .catch(error => {
                    console.error('Error updating task:', error);
                });
        }

        function checkForOngoingTask() {
            const taskRef = ref(database, 'share/tasks');
            onValue(taskRef, snapshot => {
                snapshot.forEach(taskSnapshot => {
                    const task = taskSnapshot.val();
                    if (!task.endTime) {
                        currentTask = task;
                        taskNameInput.value = currentTask.customerName;
                        projectInput.value = currentTask.project;
                        taskNotesTextarea.value = currentTask.notes;
                        startOdometerInput.value = currentTask.startOdometer;
                        endOdometerInput.disabled = false;
                        timerInterval = setInterval(updateCurrentTaskTime, 1000);
                    }
                });
            });
        }

        function toggleColumnVisibility(event) {
            const columnClass = event.target.value;
            const cells = document.querySelectorAll(`.${columnClass}, td.${columnClass}`);
            const inputs = document.querySelectorAll(`.${columnClass}-input, .start-${columnClass}-input, .end-${columnClass}-input`);
            cells.forEach(cell => {
                cell.style.display = event.target.checked ? '' : 'none';
            });
            inputs.forEach(input => {
                input.style.display = event.target.checked ? '' : 'none';
            });
        }

        function saveColumnVisibility() {
            const checkboxStates = {};
            document.querySelectorAll('.toggle-column').forEach(checkbox => {
                checkboxStates[checkbox.value] = checkbox.checked;
            });
            localStorage.setItem('columnVisibility', JSON.stringify(checkboxStates));
        }

        function loadColumnVisibility() {
            const savedStates = JSON.parse(localStorage.getItem('columnVisibility'));
            if (savedStates) {
                document.querySelectorAll('.toggle-column').forEach(checkbox => {
                    checkbox.checked = savedStates[checkbox.value] !== undefined ? savedStates[checkbox.value] : checkbox.checked;
                });
            }
        }

        function applyColumnVisibility() {
            document.querySelectorAll('.toggle-column').forEach(checkbox => {
                const columnClass = checkbox.value;
                const cells = document.querySelectorAll(`.${columnClass}, td.${columnClass}`);
                const inputs = document.querySelectorAll(`.${columnClass}-input, .start-${columnClass}-input, .end-${columnClass}-input`);
                cells.forEach(cell => {
                    cell.style.display = checkbox.checked ? '' : 'none';
                });
                inputs.forEach(input => {
                    input.style.display = checkbox.checked ? '' : 'none';
                });
            });
        }

        function calculateDailyTimeSpent(tasks) {
            const dailyTimeSpent = {};

            tasks.forEach(task => {
                if (task.startTime && task.endTime) {
                    let startTime = new Date(task.startTime);
                    let endTime = new Date(task.endTime);

                    startTime = new Date(startTime.getTime() - (startTime.getTimezoneOffset() * 60000));
                    endTime = new Date(endTime.getTime() - (endTime.getTimezoneOffset() * 60000));

                    while (startTime < endTime) {
                        const currentDate = startTime.toISOString().split('T')[0];
                        const nextDay = new Date(currentDate);
                        nextDay.setDate(nextDay.getDate() + 1);

                        const endOfDay = nextDay < endTime ? nextDay : endTime;

                        const durationInSeconds = (endOfDay - startTime) / 1000;

                        if (!dailyTimeSpent[currentDate]) {
                            dailyTimeSpent[currentDate] = 0;
                        }
                        dailyTimeSpent[currentDate] += durationInSeconds;

                        startTime = endOfDay;
                    }
                }
            });

            return dailyTimeSpent;
        }

        function displayDailyTimeSpent(dailyTimeSpent) {
            const dailyTimeContainer = document.getElementById('dailyTimeSpent');
            dailyTimeContainer.innerHTML = '';

            const today = new Date();
            const pastDate = new Date(today);
            pastDate.setDate(today.getDate() - 15);

            const sortedDates = Object.keys(dailyTimeSpent)
                .map(date => new Date(date))
                .filter(date => date >= pastDate)
                .sort((a, b) => a - b);

            sortedDates.forEach(date => {
                const dateString = date.toISOString().split('T')[0];
                const totalSeconds = dailyTimeSpent[dateString];
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const decimalHours = (totalSeconds / 3600).toFixed(2);

                const dateElement = document.createElement('div');
                dateElement.innerText = `Date: ${dateString} - Time: ${hours} hours, ${minutes} min (${decimalHours})`;
                dailyTimeContainer.appendChild(dateElement);
            });
        }

        function processTasksForDailyTimeSpent() {
            const tasks = [];

            const taskRef = ref(database, 'share/tasks');
            onValue(taskRef, snapshot => {
                tasks.length = 0;
                snapshot.forEach(taskSnapshot => {
                    tasks.push(taskSnapshot.val());
                });

                const dailyTimeSpent = calculateDailyTimeSpent(tasks);
                displayDailyTimeSpent(dailyTimeSpent);
            });
        }

        function sortTableByColumn(columnIndex, sortOrder = 'desc') {
            const rows = Array.from(taskLogTable.rows);

            rows.sort((a, b) => {
                const dateA = new Date(a.cells[columnIndex].innerText);
                const dateB = new Date(b.cells[columnIndex].innerText);
                return sortOrder === 'asc' ? dateA - dateB : dateB - dateA;
            });

            rows.forEach(row => taskLogTable.appendChild(row));
        }

        document.addEventListener('DOMContentLoaded', () => {
            const startTimeHeader = document.querySelector('#task-log th.start-time-column');

            startTimeHeader.addEventListener('click', () => {
                sortTableByColumn(7, sortOrder);
                sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
            });
        });

        function saveData() {
            const taskRef = ref(database, 'share/tasks');
            get(taskRef).then(snapshot => {
                const tasks = [];
                snapshot.forEach(taskSnapshot => {
                    tasks.push(taskSnapshot.val());
                });
                const json = JSON.stringify(tasks, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'tasks.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        }

        function loadData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.addEventListener('change', event => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const json = reader.result;
                        const tasks = JSON.parse(json);
                        tasks.forEach(task => {
                            saveTaskIfNotExists(task);
                        });
                    };
                    reader.readAsText(file);
                }
            });
            input.click();
        }

        function saveTaskIfNotExists(task) {
            const taskRef = ref(database, `share/tasks/${task.id}`);
            get(taskRef).then(snapshot => {
                if (!snapshot.exists()) {
                    set(taskRef, task);
                }
            });
        }

        function exportData() {
            const headers = Array.from(document.querySelectorAll('#task-log thead th'))
                .filter(th => th.style.display !== 'none' && !th.classList.contains('actions-column'))
                .map(th => th.innerText);

            const rows = Array.from(document.querySelectorAll('#task-log tbody tr')).map(row => {
                return Array.from(row.cells)
                    .filter(cell => !cell.classList.contains('actions-column'))
                    .filter(cell => cell.style.display !== 'none')
                    .map(cell => cell.innerText.trim());
            });

            rows.unshift(headers);
            exportToSpreadsheet(rows);
        }

        function exportToSpreadsheet(rows) {
            let csvContent = "data:text/csv;charset=utf-8,";

            rows.forEach(rowArray => {
                let row = rowArray
                    .map(field => {
                        if (field === null || field === undefined) {
                            return '';
                        }
                        field = field.toString().trim();

                        field = field.replace(/[\u00A0\r?\n|\r]/g, ' ');

                        if (field === 'Delete') {
                            return '';
                        }

                        if (!isNaN(field) && field.length > 10) {
                            field = `="${field}"`;
                        }

                        if (field.includes(',') || field.includes('"') || field.includes('\n')) {
                            field = `"${field.replace(/"/g, '""')}"`;
                        }

                        return field;
                    }).join(",");
                csvContent += row + "\r\n";
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "task_data.csv");
            document.body.appendChild(link);

            link.click();
            document.body.removeChild(link);
        }

        function createButtons() {
            const buttonsDiv = document.getElementById('buttons');

            const exportBtn = document.createElement('button');
            exportBtn.id = 'exportBtn';
            exportBtn.innerText = 'Export CSV';
            exportBtn.addEventListener('click', exportData);

            const saveBtn = document.createElement('button');
            saveBtn.id = 'saveBtn';
            saveBtn.innerText = 'Save';
            saveBtn.addEventListener('click', saveData);

            const loadBtn = document.createElement('button');
            loadBtn.id = 'loadBtn';
            loadBtn.innerText = 'Load';
            loadBtn.addEventListener('click', loadData);

            buttonsDiv.appendChild(exportBtn);
            buttonsDiv.appendChild(saveBtn);
            buttonsDiv.appendChild(loadBtn);
        }

        document.addEventListener('DOMContentLoaded', createButtons);

        function getGeolocation(callback) {
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(position => {
                    const coords = position.coords;
                    callback({
                        latitude: coords.latitude.toFixed(4),
                        longitude: coords.longitude.toFixed(4)
                    });
                }, error => {
                    console.error("Geolocation error:", error.message);
                    callback(null);
                });
            } else {
                console.error("Geolocation is not supported in your browser.");
                callback(null);
            }
        }

        function calculateHoursBetweenDates() {
            const startDate = new Date(document.getElementById('startDate').value);
            const endDate = new Date(document.getElementById('endDate').value);

            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                alert('Please select valid start and end dates and times.');
                return;
            }

            endDate.setHours(23, 59, 59, 999);

            const taskRef = ref(database, 'share/tasks');
            get(taskRef).then(snapshot => {
                let totalSeconds = 0;

                snapshot.forEach(taskSnapshot => {
                    const task = taskSnapshot.val();
                    const taskStartTime = new Date(task.startTime);
                    const taskEndTime = task.endTime ? new Date(task.endTime) : null;

                    if (!taskEndTime) return;

                    const effectiveStart = taskStartTime > startDate ? taskStartTime : startDate;
                    const effectiveEnd = taskEndTime < endDate ? taskEndTime : endDate;

                    if (effectiveStart <= effectiveEnd) {
                        const lengthInSeconds = (effectiveEnd - effectiveStart) / 1000;
                        totalSeconds += lengthInSeconds;
                    }
                });

                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const decimalHours = (totalSeconds / 3600).toFixed(2);

                document.getElementById('calculatedHours').innerText = `${hours} hours, ${minutes} minutes (${decimalHours})`;
            }).catch(error => {
                console.error('Error calculating hours:', error);
            });
        }

        document.getElementById('calculateHoursBtn').addEventListener('click', calculateHoursBetweenDates);

        document.getElementById('goToTopBtn').addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        document.getElementById('goToBottomBtn').addEventListener('click', () => {
            window.scrollTo({
                top: document.body.scrollHeight,
                behavior: 'smooth'
            });
        });

        document.getElementById('searchTask').addEventListener('input', applySearchFilter);

        function applySearchFilter() {
            const searchTerm = document.getElementById('searchTask').value.toLowerCase();
            const rows = document.querySelectorAll('#task-log tbody tr');

            rows.forEach(row => {
                const name = row.querySelector('.name-column').innerText.toLowerCase();
                const project = row.querySelector('.project-column').innerText.toLowerCase();
                const notes = row.querySelector('.notes-column').innerText.toLowerCase();

                if (name.includes(searchTerm) || project.includes(searchTerm) || notes.includes(searchTerm)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        function loadTasksIntoSelect() {
            const taskRef = ref(database, 'share/tasks');
            onValue(taskRef, (snapshot) => {
                const taskArray = [];
                snapshot.forEach(taskSnapshot => {
                    const task = taskSnapshot.val();
                    taskArray.push(task);
                });

                taskSelect.innerHTML = '<option value="" disabled selected>Select Task</option>';

                taskArray.sort((a, b) => b.id - a.id).forEach(task => {
                    const option = document.createElement('option');
                    option.value = task.id;
                    option.text = `${task.customerName} (${task.project})`;
                    taskSelect.appendChild(option);
                });
            });
        }

        taskSelect.addEventListener('change', async (event) => {
            currentTaskId = event.target.value;
            if (!currentTaskId) return;

            const taskRef = ref(database, `share/tasks/${currentTaskId}`);
            const snapshot = await get(taskRef);
            if (snapshot.exists()) {
                const task = snapshot.val();
                taskNameInput.value = task.customerName || '';
                projectInput.value = task.project || '';
                taskNotesTextarea.value = task.notes || '';
                startOdometerInput.value = task.startOdometer || '';
                endOdometerInput.value = task.endOdometer || '';
                endOdometerInput.disabled = !task.endOdometer;

                loadTaskImages(task.project);
                changeTimerButtonToRefresh();
            }
        });

        const loadingIndicator = document.getElementById('loadingIndicator');

        async function loadTaskImages(project) {
            imageUrls = [];
            imageSelect.innerHTML = '<option value="" disabled selected>Select Image</option>';
            photoContainer.innerHTML = '';

            loadingIndicator.style.display = 'block';

            try {
                const storageImagesRef = storageRef(storage, `share/images/${project}`);
                const storageSnapshot = await listAll(storageImagesRef);

                for (const item of storageSnapshot.items) {
                    const imageUrl = await getDownloadURL(item);
                    const option = document.createElement('option');
                    option.value = imageUrl;
                    option.textContent = item.name;
                    imageSelect.appendChild(option);
                    imageUrls.push(imageUrl);
                }

                displayImagesForPage(1);
            } catch (error) {
                console.error("Error loading images:", error);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function updateTask() {
            if (!currentTaskId) {
                alert('No task is loaded to update.');
                return;
            }

            const updatedTask = {
                customerName: taskNameInput.value.trim(),
                project: projectInput.value.trim(),
                notes: taskNotesTextarea.value.trim(),
                startOdometer: startOdometerInput.value.trim(),
                endOdometer: endOdometerInput.value.trim(),
                customerAddress: customerAddressInput.value.trim(),
            };

            const taskRef = ref(database, `share/tasks/${currentTaskId}`);
            update(taskRef, updatedTask)
                .then(() => {
                    alert('Task updated successfully.');
                })
                .catch(error => {
                    console.error('Error updating task:', error);
                });
            applySearchFilter();
        }

        uploadButton.addEventListener('click', async () => {
            const files = fileUploader.files;
            if (!files.length || !currentTaskId || !projectInput.value.trim()) {
                alert('Please select a task, project, and choose an image.');
                return;
            }

            const file = files[0];
            const project = projectInput.value.trim();

            let fileName = imageNameInput.value.trim();
            if (!fileName) {
                fileName = file.name.split('.').slice(0, -1).join('.');
            }

            const fileExtension = file.name.split('.').pop();
            const fullFileName = `${fileName}.${fileExtension}`;

            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.src = event.target.result;

                img.onload = function () {
                    let width = img.width;
                    let height = img.height;

                    if (width > 1024) {
                        height = height * (1024 / width);
                        width = 1024;
                    }

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    canvas.toBlob(async (blob) => {
                        const storageReference = storageRef(storage, `share/images/${project}/${fullFileName}`);
                        const uploadTask = uploadBytesResumable(storageReference, blob);

                        uploadTask.on('state_changed', null, null, async () => {
                            const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);

                            await set(ref(database, `share/images/${project}/${fileName}`), downloadURL);

                            await loadTaskImages(project);
                        });
                    }, file.type);
                };
            };

            reader.readAsDataURL(file);
        });

        const displayImagesForPage = (page) => {
            const startIndex = (page - 1) * imagesPerPage;
            const endIndex = Math.min(startIndex + imagesPerPage, imageUrls.length);

            photoContainer.innerHTML = '';

            for (let i = startIndex; i < endIndex; i++) {
                const url = imageUrls[i];
                const img = document.createElement('img');
                img.dataset.src = url;
                img.className = 'thumbnail';
                img.loading = 'lazy';
                img.addEventListener('click', () => displaySelectedImage(url));
                photoContainer.appendChild(img);

                lazyLoadImage(img);
            }

            updatePaginationControls();
        };

        const updatePaginationControls = () => {
            const paginationControls = document.getElementById('paginationControls');
            paginationControls.innerHTML = '';

            totalPages = Math.ceil(imageUrls.length / imagesPerPage);

            const prevButton = document.createElement('button');
            prevButton.textContent = 'Previous Page';
            prevButton.disabled = currentPage === 1;
            prevButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    displayImagesForPage(currentPage);
                }
            });
            paginationControls.appendChild(prevButton);

            for (let i = 1; i <= totalPages; i++) {
                const pageButton = document.createElement('button');
                pageButton.textContent = i;
                pageButton.className = 'pg';
                pageButton.addEventListener('click', () => {
                    currentPage = i;
                    displayImagesForPage(currentPage);
                });
                paginationControls.appendChild(pageButton);
            }

            const nextButton = document.createElement('button');
            nextButton.textContent = 'Next Page';
            nextButton.disabled = currentPage === totalPages;
            nextButton.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    displayImagesForPage(currentPage);
                }
            });
            paginationControls.appendChild(nextButton);
        };

        const displaySelectedImage = (url) => {
            photoContainer.innerHTML = '';
            const imgWrapper = document.createElement('div');
            imgWrapper.className = 'img-wrapper';

            const img = document.createElement('img');
            img.src = url;
            img.className = 'photo';
            imgWrapper.appendChild(img);
            photoContainer.appendChild(imgWrapper);

            const options = imageSelect.options;
            for (let i = 0; i < options.length; i++) {
                if (options[i].value === url) {
                    imageSelect.selectedIndex = i;
                    break;
                }
            }

            imgWrapper.addEventListener('click', (event) => {
                const rect = img.getBoundingClientRect();
                const x = event.clientX - rect.left;

                if (x < rect.width / 2) {
                    goToPreviousImage();
                } else {
                    goToNextImage();
                }
            });
        };

        const goToPreviousImage = () => {
            if (imageSelect.selectedIndex > 1) {
                imageSelect.selectedIndex--;
                const selectedUrl = imageSelect.value;
                displaySelectedImage(selectedUrl);
            }
        };

        const goToNextImage = () => {
            if (imageSelect.selectedIndex < imageSelect.options.length - 1) {
                imageSelect.selectedIndex++;
                const selectedUrl = imageSelect.value;
                displaySelectedImage(selectedUrl);
            }
        };

        imageSelect.addEventListener('change', (event) => {
            const selectedUrl = event.target.value;
            if (selectedUrl) {
                displaySelectedImage(selectedUrl);
            }
        });

        const deleteSelectedImage = async () => {
            const selectedImageUrl = imageSelect.value;
            if (!selectedImageUrl || !projectInput.value.trim()) return;

            if (!confirm('Are you sure you want to delete this image?')) {
                return;
            }

            const project = projectInput.value.trim();

            try {
                const imageRef = storageRef(storage, selectedImageUrl);
                await deleteObject(imageRef);

                const projectImagesRef = ref(database, `share/images/${project}`);
                const imagesSnapshot = await get(projectImagesRef);
                const images = imagesSnapshot.val();
                const imageKey = Object.keys(images).find(key => images[key] === selectedImageUrl);

                if (imageKey) {
                    await remove(ref(database, `share/images/${project}/${imageKey}`));
                    loadTaskImages(project);
                    photoContainer.innerHTML = '';
                }
            } catch (error) {
                console.error('Error deleting image:', error);
            }
        };

        function lazyLoadImage(image) {
            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        observer.unobserve(img);
                    }
                });
            });
            observer.observe(image);
        }

        toggleTimerBtn.addEventListener('click', toggleTimer);
        deleteImageButton.addEventListener('click', deleteSelectedImage);
        updateTaskBtn.addEventListener('click', updateTask);

        loadTasksIntoSelect();
    </script>
</body>

</html>