<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Job Information Manager</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Auth / login UI -->
  <script type="module" src="./assets/js/login.js" defer></script>

  <!-- Your existing CSS (walmart-tracker look) -->
  <link rel="stylesheet" href="../other/assets/css/tracker.css" />
  <script src="https://cdn.jsdelivr.net/npm/heic2any/dist/heic2any.min.js"></script>
</head>

<body>

  <header>
    <h1>Project Tracker</h1>

    <div class="header-login">
      <div id="login-section">
        <form id="login-form" class="login-form">
          <input type="email" id="username" placeholder="Email" required>
          <input type="password" id="password" placeholder="Password" required>
          <button type="submit" class="login-btn">Login</button>
        </form>
        <button id="logout" class="logout-btn" style="display:none;">Logout</button>
      </div>
    </div>
  </header>

  <main>
    <div class="app-shell">

      <!-- SIDEBAR -->
      <aside class="sidebar card">

        <div class="main-header">
          <div id="sectionTitle">Select a project</div>
          <div id="sectionMeta"></div>
        </div>

        <!-- Site name (saved to record.customerName) -->
        <div class="row">
          <div class="field">
            <label for="siteNameInput">Site Name</label>
            <input type="text" id="siteNameInput" placeholder="Enter site name..." />
          </div>
        </div>

        <div class="sidebar-header">

          <div class="field">
            <label for="projectDropdown">Select existing project:</label>
            <select id="projectDropdown" class="project-link-input">
              <option value="">(loading...)</option>
            </select>
          </div>

          <div class="project-row">
            <input id="projectNameInput" placeholder="New project" />
            <button id="setProjectBtn" type="button">Create</button>
          </div>

          <br>

          <!-- ✅ Export / Import -->
          <div class="row">
            <button id="exportCsvBtn" type="button">Export CSV</button>
            <button id="importCsvBtn" type="button">Import CSV</button>
          </div>
          <input type="file" id="csvImportInput" accept=".csv,text/csv" class="hidden" />

          <div class="row" style="display: none;">
            <button id="clearAppDataBtn" type="button" class="danger-btn">Clear App Data</button>
          </div>

          <br>

          <div class="pill-sub">
            Data path: <code id="dataPathLabel">public</code>
          </div>

          <!-- Project links -->
          <div class="project-links-card">
            <div class="project-links-header">Project links</div>
            <ul id="projectLinksList" class="project-links-list"></ul>

            <form id="projectLinksForm" class="project-links-form">
              <input type="text" id="projectLinkTitle" placeholder="Title" class="project-link-input">
              <input type="url" id="projectLinkUrl" placeholder="URL (https://...)" class="project-link-input">
              <button type="submit" class="project-link-add-btn">Add</button>
            </form>
          </div>

          <div class="progress-row">
            <span>Items summary:</span>
            <span id="sidebarSummary">0 daily task(s) • 0 list(s) • 0 item(s)</span>
          </div>
        </div>

        <!-- Pills -->
        <div class="pill-list" id="sectionList"></div>
      </aside>

      <!-- MAIN CONTENT -->
      <main class="main card">

        <!-- Global search -->
        <div class="camera-search-row">
          <input type="text" id="globalSearchInput" placeholder="Search Filter">
        </div>

        <!-- Project Notes (static, no pill) -->
        <div class="panel-toolbar">
          <div><strong>Project Notes</strong></div>
        </div>
        <textarea style="width: 100%;" id="projectNotesInput" rows="6" placeholder="Project notes..."></textarea>

        <!-- DAILY TASKS PANEL -->
        <div id="dailyTasksPanel" class="detail-panel hidden">
          <div class="card">
            <div class="panel-toolbar">
              <div><strong>Daily Tasks / Notes</strong> <span class="small-muted" id="dailyTasksCountLabel"></span>
              </div>
            </div>

            <div style="overflow:auto;">
              <table class="detail-table" id="dailyTasksTable">
                <thead>
                  <tr>
                    <th>Date/Time</th>
                    <th>Notes</th>
                    <th style="width:240px;">Images</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>

            <hr />

            <div class="panel-toolbar">
              <div><strong>Add new daily task</strong></div>
            </div>

            <div class="row">
              <input type="datetime-local" id="newDailyTaskDate" />
              <input type="text" id="newDailyTaskNotes" placeholder="Notes..." />
              <button id="addDailyTaskBtn" type="button">Add</button>
            </div>
          </div>
        </div>

        <!-- LISTS PANEL -->
        <div id="listsPanel" class="detail-panel hidden">
          <div class="card">

            <div class="row">
              <div class="field">
                <label for="newListName">Create new list</label>
                <input id="newListName" placeholder="e.g. Cameras, Controllers, Maglocks..." />
              </div>
              <button id="createListBtn" type="button">Create</button>
            </div>

            <div class="panel-toolbar">

              <div>
                <strong id="activeListTitle">List</strong>
                <span class="small-muted" id="activeListCountLabel"></span>
              </div>

              <div class="inline-btns">
                <button id="deleteListBtn" type="button" class="danger-btn">Delete List</button>
              </div>

            </div>

            <div class="panel-toolbar">
              <div><strong>Add item to this list</strong></div>
            </div>

            <div class="row" style="flex-wrap:wrap;">
              <input id="item_id" placeholder="ID (key)" />
              <input id="item_model" placeholder="Model" />
              <input id="item_type" placeholder="Type" />
              <input id="item_location" placeholder="Location" />
              <input id="item_status" placeholder="Status" />
              <input id="item_ip" placeholder="IP" />
              <input id="item_mac" placeholder="MAC" />
              <button id="addItemBtn" type="button">Add Item</button>
            </div>

            <div style="overflow:auto; margin-top:8px;">
              <table class="detail-table" id="activeListTable">
                <thead>
                  <tr>
                    <th style="width:120px;">ID</th>
                    <th>Model</th>
                    <th>Type</th>
                    <th>Location</th>
                    <th>Status</th>
                    <th style="width:150px;">IP</th>
                    <th style="width:170px;">MAC</th>
                    <th style="width:240px;">Images</th>
                    <th style="width:210px;">Actions</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>

          </div>
        </div>

        <!-- Shared hidden file input (images) -->
        <input type="file" id="imageUploadInput" accept="image/*" class="hidden" />
      </main>

    </div>
  </main>

  <script type="module">
    import {
      auth,
      onAuthStateChanged,
      database,
      storage,
      ref,
      set,
      update,
      remove,
      get,
      onValue,
      off,
      storageRef,
      uploadBytes,
      getDownloadURL,
      deleteObject
    } from "./assets/js/firebase-init.js";

    // ============================
    // Base Path + PATH helpers
    // ============================
    let DATABASE_BASE_PATH = "public";

    const PATH = {
      root: () => DATABASE_BASE_PATH,
      tasksRoot: () => `${DATABASE_BASE_PATH}/tasks`,
      record: (id) => `${DATABASE_BASE_PATH}/tasks/${id}`,
      recordMeta: (id) => `${DATABASE_BASE_PATH}/tasks/${id}/meta`,
      dailyRoot: (id) => `${DATABASE_BASE_PATH}/tasks/${id}/tasks`,
      dailyItem: (id, key) => `${DATABASE_BASE_PATH}/tasks/${id}/tasks/${encodeURIComponent(key)}`,
      listsRoot: (id) => `${DATABASE_BASE_PATH}/tasks/${id}/lists`,
      list: (id, listId) => `${DATABASE_BASE_PATH}/tasks/${id}/lists/${listId}`,
      item: (id, listId, itemKey) => `${DATABASE_BASE_PATH}/tasks/${id}/lists/${listId}/${itemKey}`,
    };

    // ============================
    // State
    // ============================
    const state = {
      recordId: "",
      activePanel: "daily", // daily | lists
      activeListId: "",
      globalQuery: "",

      projectFieldName: "",
      customerName: "",
      notes: "",
      meta: { updatedAt: 0 },
      links: [],
      lists: {},
      daily: {},

      listeners: {
        recordRef: null,
        recordCb: null,
        dropdownRef: null,
        dropdownCb: null
      }
    };

    // Dropdown cache (deduped/oldest-per-project)
    let dropdownProjectsCache = [];

    // ============================
    // DOM
    // ============================
    const $ = (id) => document.getElementById(id);

    const ui = {
      sectionListEl: $("sectionList"),
      sectionTitleEl: $("sectionTitle"),
      sectionMetaEl: $("sectionMeta"),

      projectDropdown: $("projectDropdown"),
      projectNameInput: $("projectNameInput"),
      setProjectBtn: $("setProjectBtn"),
      clearAppDataBtn: $("clearAppDataBtn"),

      exportCsvBtn: $("exportCsvBtn"),
      importCsvBtn: $("importCsvBtn"),
      csvImportInput: $("csvImportInput"),

      sidebarSummary: $("sidebarSummary"),
      dataPathLabel: $("dataPathLabel"),
      globalSearchInput: $("globalSearchInput"),

      siteNameInput: $("siteNameInput"),
      projectNotesInput: $("projectNotesInput"),

      dailyTasksPanel: $("dailyTasksPanel"),
      listsPanel: $("listsPanel"),

      dailyTasksTableBody: document.querySelector("#dailyTasksTable tbody"),
      dailyTasksCountLabel: $("dailyTasksCountLabel"),
      newDailyTaskDate: $("newDailyTaskDate"),
      newDailyTaskNotes: $("newDailyTaskNotes"),
      addDailyTaskBtn: $("addDailyTaskBtn"),

      projectLinksList: $("projectLinksList"),
      projectLinksForm: $("projectLinksForm"),
      projectLinkTitle: $("projectLinkTitle"),
      projectLinkUrl: $("projectLinkUrl"),

      activeListTitle: $("activeListTitle"),
      activeListCountLabel: $("activeListCountLabel"),
      newListName: $("newListName"),
      createListBtn: $("createListBtn"),
      deleteListBtn: $("deleteListBtn"),

      itemInputs: {
        id: $("item_id"),
        model: $("item_model"),
        type: $("item_type"),
        location: $("item_location"),
        status: $("item_status"),
        ip: $("item_ip"),
        mac: $("item_mac"),
      },
      addItemBtn: $("addItemBtn"),
      activeListTableBody: document.querySelector("#activeListTable tbody"),

      imageUploadInput: $("imageUploadInput"),
    };

    let pendingUploadTarget = null; // { kind:'daily'|'listItem', dailyKey?, listId?, itemId? }

    // ============================
    // LocalStorage (per base path)
    // ============================
    const LS_KEY = () => `jobInfoManager:lastOpen:${DATABASE_BASE_PATH}`;

    function loadLastOpenState() {
      try {
        const raw = localStorage.getItem(LS_KEY());
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch {
        return {};
      }
    }

    function saveLastOpenState(patch = {}) {
      try {
        const current = loadLastOpenState();
        const next = {
          recordId: state.recordId || "",
          activePanel: state.activePanel || "daily",
          activeListId: state.activeListId || "",
          globalQuery: state.globalQuery || "",
          ...current,
          ...patch,
          savedAt: Date.now()
        };
        localStorage.setItem(LS_KEY(), JSON.stringify(next));
      } catch (e) {
        console.warn("localStorage save failed:", e);
      }
    }

    function clearLastOpenState() {
      try { localStorage.removeItem(LS_KEY()); } catch { }
    }

    // ============================
    // Utils
    // ============================
    const RESERVED_LIST_KEYS = new Set(["_name", "createdAt", "meta", "items"]);

    function dbRef(path) { return ref(database, path); }

    function sanitizeKey(name) {
      return String(name || "")
        .trim()
        .toLowerCase()
        .replace(/[.#$/\[\]]/g, "_")
        .replace(/\s+/g, "_");
    }

    function debounce(fn, wait = 120) {
      let t = null;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    function matchesAny(...vals) {
      const q = (state.globalQuery || "").trim().toLowerCase();
      if (!q) return true;
      return vals.some(v => String(v || "").toLowerCase().includes(q));
    }

    function getListItems(listObj) {
      if (!listObj || typeof listObj !== "object") return {};
      const out = {};
      for (const [k, v] of Object.entries(listObj)) {
        if (RESERVED_LIST_KEYS.has(k)) continue;
        out[k] = v;
      }
      return out;
    }

    function ensureImagesArray(obj) {
      if (!obj) return [];
      if (!Array.isArray(obj.images)) obj.images = [];
      return obj.images;
    }

    function collectImagePaths(obj) {
      const out = [];
      if (!obj) return out;
      if (Array.isArray(obj.images)) obj.images.forEach(img => { if (img?.path) out.push(img.path); });
      return out;
    }

    function safeFilePart(v) {
      return String(v || "")
        .trim()
        .replace(/[^\w\-]+/g, "_")
        .slice(0, 50);
    }

    function storageImagePath({ kind, dailyKey, listId, itemId }) {
      const ts = Date.now();

      if (kind === "daily") {
        const idPart = safeFilePart(dailyKey);
        return `${DATABASE_BASE_PATH}/tasks/${state.recordId}/daily/${encodeURIComponent(dailyKey)}/${idPart}_${ts}.jpg`;
      }

      const idPart = safeFilePart(itemId);
      return `${DATABASE_BASE_PATH}/tasks/${state.recordId}/lists/${listId}/${itemId}/${idPart}_${ts}.jpg`;
    }

    // ============================
    // ✅ Dirty-on-blur (saves ONLY if changed)
    // ============================
    function attachDirtyBlur(el, saveFn) {
      el.addEventListener("focus", () => {
        el.dataset._saved = String(el.value ?? "").trim();
      });

      el.addEventListener("blur", async () => {
        const before = String(el.dataset._saved ?? "").trim();
        const now = String(el.value ?? "").trim();
        if (before === now) return;
        el.dataset._saved = now;
        await saveFn(now);
      });
    }

    // ============================
    // HEIC + Resize
    // ============================
    function isHeic(file) {
      const name = (file?.name || "").toLowerCase();
      const type = (file?.type || "").toLowerCase();
      return type.includes("heic") || type.includes("heif") || name.endsWith(".heic") || name.endsWith(".heif");
    }

    async function fileToJpegBlobIfNeeded(file) {
      if (!isHeic(file)) return file;

      if (!window.heic2any) {
        throw new Error("HEIC converter not loaded (heic2any missing).");
      }

      const jpegBlob = await heic2any({
        blob: file,
        toType: "image/jpeg",
        quality: 0.95
      });

      return Array.isArray(jpegBlob) ? jpegBlob[0] : jpegBlob;
    }

    async function resizeImageToJpeg(file, maxWidth = 2048, quality = 0.9) {
      const inputBlob = await fileToJpegBlobIfNeeded(file);

      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          const img = new Image();

          img.onload = () => {
            let w = img.width, h = img.height;

            if (w > maxWidth) {
              const s = maxWidth / w;
              w = maxWidth;
              h = Math.round(h * s);
            }

            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;

            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, w, h);

            canvas.toBlob(
              (blob) => blob ? resolve(blob) : reject(new Error("toBlob returned null")),
              "image/jpeg",
              quality
            );
          };

          img.onerror = () => reject(new Error("Image decode failed"));
          img.src = reader.result;
        };

        reader.onerror = () => reject(reader.error || new Error("FileReader failed"));
        reader.readAsDataURL(inputBlob);
      });
    }

    // ============================
    // DB helpers
    // ============================
    async function touchRecord() {
      if (!state.recordId) return;
      await update(dbRef(PATH.recordMeta(state.recordId)), { updatedAt: Date.now() });
    }

    async function dbUpdate(path, patch, touch = true) {
      await update(dbRef(path), patch);
      if (touch) await touchRecord();
    }

    async function dbSet(path, value, touch = true) {
      await set(dbRef(path), value);
      if (touch) await touchRecord();
    }

    async function dbRemove(path, touch = true) {
      await remove(dbRef(path));
      if (touch) await touchRecord();
    }

    // ============================
    // CSV helpers + Export/Import
    // ============================
    function csvEscape(val) {
      const s = String(val ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }

    function toCsv(rows, header) {
      const lines = [];
      lines.push(header.map(csvEscape).join(","));
      for (const r of rows) {
        lines.push(header.map(h => csvEscape(r[h])).join(","));
      }
      return lines.join("\n");
    }

    function parseCsv(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let i = 0;
      let inQuotes = false;

      while (i < text.length) {
        const ch = text[i];

        if (inQuotes) {
          if (ch === '"') {
            if (text[i + 1] === '"') { cur += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          cur += ch; i++; continue;
        }

        if (ch === '"') { inQuotes = true; i++; continue; }
        if (ch === ",") { row.push(cur); cur = ""; i++; continue; }
        if (ch === "\n") { row.push(cur); rows.push(row); row = []; cur = ""; i++; continue; }
        if (ch === "\r") { i++; continue; }

        cur += ch; i++;
      }

      row.push(cur);
      rows.push(row);
      return rows;
    }

    function downloadTextFile(filename, text) {
      const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function buildExportRows() {
      const rows = [];

      // DAILY TASKS
      for (const [key, v] of Object.entries(state.daily || {})) {
        const images = Array.isArray(v?.images) ? v.images : [];
        rows.push({
          kind: "daily",
          projectId: state.recordId,
          project: state.projectFieldName || "",
          customerName: state.customerName || "",
          listId: "",
          itemKey: key,
          id: "",
          date: v?.date || key || "",
          notes: v?.notes || "",
          model: "",
          type: "",
          location: "",
          status: "",
          ip: "",
          mac: "",
          itemNotes: "",
          imageUrls: images.map(x => x?.url || "").filter(Boolean).join("|"),
          imageNotes: images.map(x => x?.note || "").join("|")
        });
      }

      // LIST ITEMS
      for (const [listId, listObj] of Object.entries(state.lists || {})) {
        const items = getListItems(listObj);
        for (const [itemKey, v] of Object.entries(items)) {
          const images = Array.isArray(v?.images) ? v.images : [];
          rows.push({
            kind: "listItem",
            projectId: state.recordId,
            project: state.projectFieldName || "",
            customerName: state.customerName || "",
            listId,
            itemKey,
            id: v?.id ?? itemKey,
            date: "",
            notes: "",
            model: v?.model || "",
            type: v?.type || "",
            location: v?.location || "",
            status: v?.status || "",
            ip: v?.ip || "",
            mac: v?.mac || "",
            itemNotes: v?.notes || "",
            imageUrls: images.map(x => x?.url || "").filter(Boolean).join("|"),
            imageNotes: images.map(x => x?.note || "").join("|")
          });
        }
      }

      return rows;
    }

    async function exportCsv() {
      if (!state.recordId) return alert("Select a project first.");

      const header = [
        "kind",
        "projectId",
        "project",
        "customerName",
        "listId",
        "itemKey",
        "id",
        "date",
        "notes",
        "model",
        "type",
        "location",
        "status",
        "ip",
        "mac",
        "itemNotes",
        "imageUrls",
        "imageNotes"
      ];

      const rows = buildExportRows();
      const csv = toCsv(rows, header);

      const safeName = (state.projectFieldName || state.recordId || "project")
        .replace(/[^\w\-]+/g, "_")
        .slice(0, 60);

      downloadTextFile(`job_tracker_${safeName}.csv`, csv);
    }

    function normalizeHeader(h) {
      return String(h || "")
        .trim()
        .toLowerCase()
        .replace(/\s+/g, " ")
        .replace(/[^\w #\-]/g, "");
    }

    function pickListForCableImport() {
      if (state.activeListId && state.lists?.[state.activeListId]) return state.activeListId;
      return "cameras";
    }

    async function ensureListExists(listId, displayName) {
      if (!state.recordId) return;
      if (state.lists?.[listId]) return;

      await dbSet(PATH.list(state.recordId, listId), {
        _name: displayName || listId,
        createdAt: Date.now()
      });
    }

    async function importCableAssignmentSheet(csvText) {
      if (!state.recordId) return alert("Select a project first.");

      const parsed = parseCsv(csvText.trim());
      if (!parsed.length) return alert("CSV looks empty.");

      let headerRowIndex = -1;
      for (let i = 0; i < Math.min(parsed.length, 25); i++) {
        const norm = parsed[i].map(normalizeHeader);
        if (norm.includes("cable #") && norm.includes("location name")) {
          headerRowIndex = i;
          break;
        }
      }
      if (headerRowIndex < 0) {
        return alert("Could not find Cable Assignment Sheet headers (Cable # / Location Name).");
      }

      const header = parsed[headerRowIndex].map(normalizeHeader);
      const idx = (name) => header.indexOf(normalizeHeader(name));

      const iCable = idx("cable #");
      const iLoc = idx("location name");
      const iIP = idx("ip address");
      const iMAC = idx("mac address");
      const iSw = idx("switch");
      const iSwP = idx("switch port");
      const iModel = idx("camera model");
      const iDisp = idx("camera to be displayed");
      const iProf = idx("camera recording profile");
      const iGroup = idx("camera group");

      if (iCable < 0 || iLoc < 0) {
        return alert("CSV is missing required columns: Cable # and Location Name.");
      }

      const listId = pickListForCableImport();
      await ensureListExists(listId, listId === "cameras" ? "Cameras" : (state.lists?.[listId]?._name || listId));

      const basePath = PATH.record(state.recordId);
      const patch = {};
      let imported = 0;

      for (let r = headerRowIndex + 1; r < parsed.length; r++) {
        const row = parsed[r];
        if (!row || row.every(c => !String(c || "").trim())) continue;

        const cableRaw = String(row[iCable] ?? "").trim();
        const locRaw = String(row[iLoc] ?? "").trim();
        if (!cableRaw && !locRaw) continue;

        const itemKey = cableRaw;
        if (!itemKey) continue;

        const ip = iIP >= 0 ? String(row[iIP] ?? "").trim() : "";
        const mac = iMAC >= 0 ? String(row[iMAC] ?? "").trim() : "";
        const sw = iSw >= 0 ? String(row[iSw] ?? "").trim() : "";
        const swp = iSwP >= 0 ? String(row[iSwP] ?? "").trim() : "";
        const model = iModel >= 0 ? String(row[iModel] ?? "").trim() : "";
        const disp = iDisp >= 0 ? String(row[iDisp] ?? "").trim() : "";
        const prof = iProf >= 0 ? String(row[iProf] ?? "").trim() : "";
        const group = iGroup >= 0 ? String(row[iGroup] ?? "").trim() : "";

        const notesParts = [];
        if (disp) notesParts.push(`Display: ${disp}`);
        if (prof) notesParts.push(`Profile: ${prof}`);
        if (group) notesParts.push(`Group: ${group}`);
        if (sw || swp) notesParts.push(`Switch: ${sw}${swp ? ` Port ${swp}` : ""}`);
        const notes = notesParts.join(" • ");

        patch[`lists/${listId}/${itemKey}`] = {
          id: itemKey,
          model: model || "",
          type: group || "Camera",
          location: locRaw || "",
          status: "",
          ip: ip || "",
          mac: mac || "",
          notes: notes || "",
          images: []
        };

        imported++;
      }

      await update(dbRef(basePath), patch);
      await touchRecord();

      state.activeListId = listId;
      saveLastOpenState({ activePanel: "lists", activeListId: listId });
      setActivePanel("lists");

      alert(`Imported ${imported} camera row(s) into list "${listId}".`);
    }

    async function importAppCsvText(csvText) {
      if (!state.recordId) return alert("Select a project first.");

      const parsed = parseCsv(csvText.trim());
      if (!parsed.length) return alert("CSV looks empty.");

      const header = parsed[0].map(h => String(h || "").trim());
      const idx = (name) => header.indexOf(name);

      if (idx("kind") < 0) return alert('CSV missing required column: "kind".');

      const basePath = PATH.record(state.recordId);
      let importedDaily = 0;
      let importedItems = 0;

      const patch = {};

      const firstDataRow = parsed[1] || [];
      const csvProject = firstDataRow[idx("project")] || "";
      const csvCustomer = firstDataRow[idx("customerName")] || "";

      if (csvProject && !state.projectFieldName) patch["project"] = csvProject;
      if (csvCustomer) patch["customerName"] = csvCustomer;

      for (let r = 1; r < parsed.length; r++) {
        const row = parsed[r];
        if (!row || (row.length === 1 && !row[0])) continue;

        const kind = row[idx("kind")] || "";

        if (kind === "daily") {
          const itemKey = row[idx("itemKey")] || row[idx("date")] || "";
          if (!itemKey) continue;

          const date = row[idx("date")] || itemKey;
          const notes = row[idx("notes")] || "";

          const urls = (row[idx("imageUrls")] || "").split("|").filter(Boolean);
          const notesArr = (row[idx("imageNotes")] || "").split("|");
          const images = urls.map((u, i) => ({ url: u, path: "", note: notesArr[i] || "" }));

          patch[`tasks/${itemKey}`] = { date, notes, images };
          importedDaily++;
        }

        if (kind === "listItem") {
          const listId = row[idx("listId")] || "";
          const itemKey = row[idx("itemKey")] || row[idx("id")] || "";
          if (!listId || !itemKey) continue;

          const idVal = row[idx("id")] || itemKey;

          const urls = (row[idx("imageUrls")] || "").split("|").filter(Boolean);
          const notesArr = (row[idx("imageNotes")] || "").split("|");
          const images = urls.map((u, i) => ({ url: u, path: "", note: notesArr[i] || "" }));

          patch[`lists/${listId}/${itemKey}`] = {
            id: idVal,
            model: row[idx("model")] || "",
            type: row[idx("type")] || "",
            location: row[idx("location")] || "",
            status: row[idx("status")] || "",
            ip: row[idx("ip")] || "",
            mac: row[idx("mac")] || "",
            notes: row[idx("itemNotes")] || "",
            images
          };

          if (!state.lists?.[listId]) {
            patch[`lists/${listId}/_name`] = listId;
            patch[`lists/${listId}/createdAt`] = Date.now();
          }

          importedItems++;
        }
      }

      await update(dbRef(basePath), patch);
      await touchRecord();

      alert(`Imported: ${importedDaily} daily task(s), ${importedItems} list item(s).`);
    }

    async function importAnyCsvText(csvText) {
      const parsed = parseCsv(csvText.trim());
      if (!parsed.length) return alert("CSV looks empty.");

      const firstRow = parsed[0].map(normalizeHeader);
      if (firstRow.includes("kind")) {
        return importAppCsvText(csvText);
      }

      for (let i = 0; i < Math.min(parsed.length, 25); i++) {
        const norm = parsed[i].map(normalizeHeader);
        if (norm.includes("cable #") && norm.includes("location name")) {
          return importCableAssignmentSheet(csvText);
        }
      }

      alert("Unrecognized CSV format. (Not app export, and not Cable Assignment Sheet.)");
    }

    // ============================
    // Listener management
    // ============================
    function detachRecordListener() {
      const { recordRef, recordCb } = state.listeners;
      if (recordRef && recordCb) {
        try { off(recordRef, "value", recordCb); } catch { }
      }
      state.listeners.recordRef = null;
      state.listeners.recordCb = null;
    }

    function detachDropdownListener() {
      const { dropdownRef, dropdownCb } = state.listeners;
      if (dropdownRef && dropdownCb) {
        try { off(dropdownRef, "value", dropdownCb); } catch { }
      }
      state.listeners.dropdownRef = null;
      state.listeners.dropdownCb = null;
    }

    // ============================
    // UI helpers
    // ============================
    function renderDataPathLabel() {
      if (!ui.dataPathLabel) return;
      ui.dataPathLabel.textContent = state.recordId
        ? `${DATABASE_BASE_PATH} / ${state.recordId}`
        : `${DATABASE_BASE_PATH} / (no project)`;
    }

    function renderHeader() {
      if (!state.recordId) {
        ui.sectionTitleEl.textContent = "Select a project";
        ui.sectionMetaEl.textContent = "";
        return;
      }

      const displayName = state.projectFieldName || state.recordId;
      const dailyCount = Object.keys(state.daily || {}).length;

      if (state.activePanel === "daily") {
        ui.sectionTitleEl.textContent = "Daily Tasks / Notes";
        ui.sectionMetaEl.textContent = `Project: ${displayName} • ${dailyCount} daily task(s)`;
      } else {
        const listId = state.activeListId;
        const list = state.lists[listId] || {};
        const itemCount = Object.keys(getListItems(list)).length;
        ui.sectionTitleEl.textContent = list?._name || listId || "List";
        ui.sectionMetaEl.textContent = `Project: ${displayName} • ${itemCount} item(s)`;
      }
    }

    function renderSidebarSummary() {
      const dailyCount = Object.keys(state.daily || {}).length;
      const listIds = Object.keys(state.lists || {});
      const listCount = listIds.length;
      const itemCount = listIds.reduce((acc, id) => acc + Object.keys(getListItems(state.lists[id])).length, 0);
      ui.sidebarSummary.textContent = `${dailyCount} daily task(s) • ${listCount} list(s) • ${itemCount} item(s)`;
    }

    function setActivePanel(panel) {
      state.activePanel = panel;

      ui.dailyTasksPanel.classList.toggle("hidden", panel !== "daily");
      ui.listsPanel.classList.toggle("hidden", panel !== "lists");

      saveLastOpenState({ activePanel: panel, activeListId: state.activeListId || "" });

      renderHeader();
      renderSidebarPills();
      renderAll();
    }

    // ============================
    // Project dropdown (dedupe + filter by global search)
    // ============================
    function renderProjectDropdown() {
      const q = (state.globalQuery || "").toLowerCase().trim();

      ui.projectDropdown.innerHTML = `<option value="">Select project</option>`;

      const filtered = dropdownProjectsCache.filter(p => {
        if (!q) return true;
        return (
          (p.projectName || "").toLowerCase().includes(q) ||
          (p.customerName || "").toLowerCase().includes(q) ||
          String(p.id || "").includes(q)
        );
      });

      filtered
        .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
        .forEach(p => {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = `${p.projectName} (${p.customerName})`;
          ui.projectDropdown.appendChild(opt);
        });

      if (state.recordId) ui.projectDropdown.value = state.recordId;
    }

    function startTasksDropdownListener() {
      detachDropdownListener();

      const dRef = dbRef(PATH.tasksRoot());
      const dCb = (snap) => {
        if (!snap.exists()) {
          dropdownProjectsCache = [];
          renderProjectDropdown();
          return;
        }

        const byProjectName = new Map();

        snap.forEach(child => {
          const id = child.key;
          const v = child.val() || {};

          const projectName = (v.project || "").trim() || id;
          const customerName = (v.customerName || "").trim();
          const updatedAt = v.meta?.updatedAt || v.updatedAt || 0;

          const createdAt = Number(id);
          const createdAtSafe = Number.isFinite(createdAt) ? createdAt : Number.MAX_SAFE_INTEGER;

          const existing = byProjectName.get(projectName);

          // keep OLDEST record per project name
          if (!existing || createdAtSafe < existing.createdAt) {
            byProjectName.set(projectName, {
              id,
              projectName,
              customerName: customerName || "—",
              updatedAt,
              createdAt: createdAtSafe
            });
          }
        });

        dropdownProjectsCache = Array.from(byProjectName.values());
        renderProjectDropdown();
      };

      state.listeners.dropdownRef = dRef;
      state.listeners.dropdownCb = dCb;
      onValue(dRef, dCb);
    }

    // ============================
    // Project links
    // ============================
    function renderProjectLinks() {
      ui.projectLinksList.innerHTML = "";

      if (!state.recordId) {
        const li = document.createElement("li");
        li.style.color = "var(--text-muted,#8d96a8)";
        li.textContent = "(No project selected)";
        ui.projectLinksList.appendChild(li);
        return;
      }

      const links = Array.isArray(state.links) ? state.links : [];
      if (!links.length) {
        const li = document.createElement("li");
        li.style.color = "var(--text-muted,#8d96a8)";
        li.textContent = "(No links yet)";
        ui.projectLinksList.appendChild(li);
        return;
      }

      const sorted = links.slice().sort((a, b) =>
        (a.title || "").localeCompare((b.title || ""), undefined, { sensitivity: "base" })
      );

      sorted.forEach((link) => {
        const li = document.createElement("li");
        li.style.display = "flex";
        li.style.alignItems = "center";
        li.style.justifyContent = "space-between";
        li.style.gap = "6px";

        const a = document.createElement("a");
        a.href = link.url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = link.title || link.url;
        a.style.color = "var(--accent,#2f81f7)";
        a.style.textDecoration = "none";

        const del = document.createElement("button");
        del.textContent = "×";
        del.title = "Remove link";
        del.style.borderRadius = "999px";
        del.style.border = "1px solid var(--border-subtle,#202637)";
        del.style.background = "#050814";
        del.style.color = "var(--text,#e4e8f0)";
        del.style.cursor = "pointer";
        del.style.padding = "0 8px";

        del.addEventListener("click", async () => {
          const idx = (state.links || []).findIndex(l => l.title === link.title && l.url === link.url);
          if (idx < 0) return;
          const next = state.links.slice();
          next.splice(idx, 1);
          await dbUpdate(PATH.record(state.recordId), { links: next });
        });

        li.appendChild(a);
        li.appendChild(del);
        ui.projectLinksList.appendChild(li);
      });
    }

    // ============================
    // Thumb strip
    // ============================
    function renderThumbStrip({ images, onOpen, onDelete, onNoteSave }) {
      const wrap = document.createElement("div");
      wrap.className = "thumb-strip";

      (Array.isArray(images) ? images : []).forEach((img, idx) => {
        const w = document.createElement("div");
        w.className = "thumb-wrapper";

        const thumb = document.createElement("img");
        thumb.className = "thumb-img";
        thumb.src = img.url;
        thumb.addEventListener("click", () => onOpen(img.url));

        const del = document.createElement("button");
        del.className = "thumb-delete";
        del.textContent = "×";
        del.addEventListener("click", () => onDelete(idx));

        const note = document.createElement("textarea");
        note.className = "thumb-note";
        note.rows = 2;
        note.placeholder = "Notes…";
        note.value = img.note || "";

        attachDirtyBlur(note, async (val) => onNoteSave(idx, val));

        w.appendChild(thumb);
        w.appendChild(del);
        w.appendChild(note);
        wrap.appendChild(w);
      });

      return wrap;
    }

    // ============================
    // Daily tasks
    // ============================
    function renderDailyTasks() {
      ui.dailyTasksTableBody.innerHTML = "";
      if (!state.recordId) return;

      const entries = Object.entries(state.daily || {})
        .map(([k, v]) => ({
          key: k,
          date: v?.date || "",
          notes: v?.notes || "",
          images: Array.isArray(v?.images) ? v.images : []
        }))
        .filter(t => matchesAny(t.key, t.date, t.notes))
        .sort((a, b) => String(b.date).localeCompare(String(a.date)));

      ui.dailyTasksCountLabel.textContent = `(${entries.length})`;

      const baseDailyRoot = PATH.dailyRoot(state.recordId);

      entries.forEach((t) => {
        const tr = document.createElement("tr");

        const tdDate = document.createElement("td");
        const dateInput = document.createElement("input");
        dateInput.type = "datetime-local";
        dateInput.value = t.date || "";
        attachDirtyBlur(dateInput, (val) => dbUpdate(`${baseDailyRoot}/${encodeURIComponent(t.key)}`, { date: val }));
        tdDate.appendChild(dateInput);

        const tdNotes = document.createElement("td");
        const notesArea = document.createElement("textarea");
        notesArea.value = t.notes || "";
        notesArea.placeholder = "Notes...";
        attachDirtyBlur(notesArea, (val) => dbUpdate(`${baseDailyRoot}/${encodeURIComponent(t.key)}`, { notes: val }));
        tdNotes.appendChild(notesArea);

        const tdImg = document.createElement("td");
        const addImgBtn = document.createElement("button");
        addImgBtn.textContent = "Add Image";
        addImgBtn.addEventListener("click", () => {
          pendingUploadTarget = { kind: "daily", dailyKey: t.key };
          ui.imageUploadInput.value = "";
          ui.imageUploadInput.click();
        });
        tdImg.appendChild(addImgBtn);

        tdImg.appendChild(renderThumbStrip({
          images: t.images,
          onOpen: (url) => window.open(url, "_blank"),
          onDelete: async (index) => {
            if (!confirm("Delete this image?")) return;

            const currentObj = state.daily[t.key] || {};
            const imgs = ensureImagesArray(currentObj).slice();
            const [removed] = imgs.splice(index, 1);

            await dbUpdate(`${baseDailyRoot}/${encodeURIComponent(t.key)}`, { images: imgs });

            if (removed?.path) {
              try { await deleteObject(storageRef(storage, removed.path)); } catch (e) { console.warn(e); }
            }
          },
          onNoteSave: async (index, noteVal) => {
            const currentObj = state.daily[t.key] || {};
            const imgs = ensureImagesArray(currentObj).slice();
            if (!imgs[index]) return;
            imgs[index].note = noteVal || "";
            await dbUpdate(`${baseDailyRoot}/${encodeURIComponent(t.key)}`, { images: imgs });
          }
        }));

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.className = "danger-btn";
        delBtn.addEventListener("click", async () => {
          if (!confirm("Delete this daily task (and its images)?")) return;

          const currentObj = state.daily[t.key] || {};
          const paths = collectImagePaths(currentObj);

          await dbRemove(`${baseDailyRoot}/${encodeURIComponent(t.key)}`);

          for (const p of paths) {
            try { await deleteObject(storageRef(storage, p)); } catch (e) { console.warn(e); }
          }
        });
        tdActions.appendChild(delBtn);

        tr.appendChild(tdDate);
        tr.appendChild(tdNotes);
        tr.appendChild(tdImg);
        tr.appendChild(tdActions);
        ui.dailyTasksTableBody.appendChild(tr);
      });
    }

    async function addDailyTask() {
      if (!state.recordId) return alert("Select a project first.");

      const dt = (ui.newDailyTaskDate.value || "").trim();
      const notes = (ui.newDailyTaskNotes.value || "").trim();
      if (!dt || !notes) return alert("Enter a date/time and notes.");

      // Keep your existing pattern: key = dt (compatible with current data)
      const key = dt;

      await dbSet(`${PATH.dailyRoot(state.recordId)}/${encodeURIComponent(key)}`, { date: dt, notes, images: [] });

      ui.newDailyTaskDate.value = "";
      ui.newDailyTaskNotes.value = "";
    }

    // ============================
    // Lists
    // ============================
    function renderActiveList() {
      ui.activeListTableBody.innerHTML = "";

      if (!state.recordId) {
        ui.activeListTitle.textContent = "List";
        ui.activeListCountLabel.textContent = "";
        return;
      }

      const listId = state.activeListId;
      const listObj = state.lists[listId];

      if (!listId || !listObj) {
        ui.activeListTitle.textContent = "Lists";
        ui.activeListCountLabel.textContent = " (create a list to begin)";
        return;
      }

      ui.activeListTitle.textContent = listObj._name || listId;

      const itemsNode = getListItems(listObj);
      const rows = Object.entries(itemsNode)
        .map(([k, v]) => ({
          key: k,
          id: v?.id ?? k,
          model: v?.model || "",
          type: v?.type || "",
          location: v?.location || "",
          status: v?.status || "",
          ip: v?.ip || "",
          mac: v?.mac || "",
          notes: v?.notes || "",
          images: Array.isArray(v?.images) ? v.images : []
        }))
        .filter(r => matchesAny(r.key, r.id, r.model, r.type, r.location, r.status, r.ip, r.mac, r.notes))
        .sort((a, b) => String(a.id).localeCompare(String(b.id), undefined, { numeric: true }));

      ui.activeListCountLabel.textContent = `(${rows.length})`;

      const basePath = PATH.record(state.recordId);

      const mkTdInput = (initialVal, placeholder, saveFn) => {
        const td = document.createElement("td");
        const input = document.createElement("input");
        input.type = "text";
        input.value = initialVal || "";
        input.placeholder = placeholder || "";
        attachDirtyBlur(input, saveFn);
        td.appendChild(input);
        return td;
      };

      rows.forEach((r) => {
        const tr = document.createElement("tr");
        const baseItemPath = `${basePath}/lists/${listId}/${r.key}`;

        tr.appendChild(mkTdInput(r.id, "Camera ID / Cable #", (val) => dbUpdate(baseItemPath, { id: val })));
        tr.appendChild(mkTdInput(r.model, "Model", (val) => dbUpdate(baseItemPath, { model: val })));
        tr.appendChild(mkTdInput(r.type, "Type (Camera, Controller, etc)", (val) => dbUpdate(baseItemPath, { type: val })));
        tr.appendChild(mkTdInput(r.location, "Location", (val) => dbUpdate(baseItemPath, { location: val })));
        tr.appendChild(mkTdInput(r.status, "Status", (val) => dbUpdate(baseItemPath, { status: val })));
        tr.appendChild(mkTdInput(r.ip, "IP Address", (val) => dbUpdate(baseItemPath, { ip: val })));
        tr.appendChild(mkTdInput(r.mac, "MAC Address", (val) => dbUpdate(baseItemPath, { mac: val })));

        const tdImg = document.createElement("td");
        const addImgBtn = document.createElement("button");
        addImgBtn.textContent = "Add Image";
        addImgBtn.addEventListener("click", () => {
          pendingUploadTarget = { kind: "listItem", listId, itemId: r.key };
          ui.imageUploadInput.value = "";
          ui.imageUploadInput.click();
        });
        tdImg.appendChild(addImgBtn);

        tdImg.appendChild(renderThumbStrip({
          images: r.images,
          onOpen: (url) => window.open(url, "_blank"),
          onDelete: async (index) => {
            if (!confirm("Delete this item image?")) return;

            const itemObj = getListItems(state.lists[listId] || {})[r.key] || {};
            const imgs = ensureImagesArray(itemObj).slice();
            const [removed] = imgs.splice(index, 1);

            await dbUpdate(baseItemPath, { images: imgs });

            if (removed?.path) {
              try { await deleteObject(storageRef(storage, removed.path)); } catch (e) { console.warn(e); }
            }
          },
          onNoteSave: async (index, noteVal) => {
            const itemObj = getListItems(state.lists[listId] || {})[r.key] || {};
            const imgs = ensureImagesArray(itemObj).slice();
            if (!imgs[index]) return;
            imgs[index].note = noteVal || "";
            await dbUpdate(baseItemPath, { images: imgs });
          }
        }));

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.className = "danger-btn";
        delBtn.addEventListener("click", async () => {
          if (!confirm(`Delete item "${r.key}" (and images)?`)) return;

          const itemObj = getListItems(state.lists[listId] || {})[r.key] || {};
          const paths = collectImagePaths(itemObj);

          await dbRemove(baseItemPath);

          for (const p of paths) {
            try { await deleteObject(storageRef(storage, p)); } catch (e) { console.warn(e); }
          }
        });
        tdActions.appendChild(delBtn);

        tr.appendChild(tdImg);
        tr.appendChild(tdActions);

        ui.activeListTableBody.appendChild(tr);
      });
    }

    async function createList() {
      if (!state.recordId) return alert("Select a project first.");
      const name = (ui.newListName.value || "").trim();
      if (!name) return alert("Enter a list name.");

      const listId = sanitizeKey(name);
      if (!listId) return alert("That list name becomes an invalid key. Try letters/numbers.");

      if (state.lists && Object.prototype.hasOwnProperty.call(state.lists, listId)) {
        state.activeListId = listId;
        saveLastOpenState({ activePanel: "lists", activeListId: listId });
        ui.newListName.value = "";
        return setActivePanel("lists");
      }

      await dbSet(PATH.list(state.recordId, listId), {
        _name: name,
        createdAt: Date.now()
      });

      state.activeListId = listId;
      saveLastOpenState({ activePanel: "lists", activeListId: listId });
      ui.newListName.value = "";
      setActivePanel("lists");
    }

    async function deleteActiveList() {
      if (!state.recordId) return alert("Select a project first.");
      if (!state.activeListId) return alert("No list selected.");

      const listId = state.activeListId;
      const listObj = state.lists[listId] || {};
      const display = listObj._name || listId;

      if (!confirm(`Delete list "${display}" and all items/images?`)) return;

      const items = getListItems(listObj);
      const paths = [];
      Object.values(items).forEach(item => paths.push(...collectImagePaths(item)));

      await dbRemove(PATH.list(state.recordId, listId));

      for (const p of paths) {
        try { await deleteObject(storageRef(storage, p)); } catch (e) { console.warn(e); }
      }

      state.activeListId = "";
      saveLastOpenState({ activeListId: "", activePanel: "daily" });
      setActivePanel("daily");
    }

    async function addItemToActiveList() {
      if (!state.recordId) return alert("Select a project first.");
      if (!state.activeListId) return alert("Select or create a list first.");

      const listId = state.activeListId;
      const id = (ui.itemInputs.id.value || "").trim();
      if (!id) return alert("ID is required.");

      const item = {
        id,
        model: ui.itemInputs.model.value || "",
        type: ui.itemInputs.type.value || "",
        location: ui.itemInputs.location.value || "",
        status: ui.itemInputs.status.value || "",
        ip: ui.itemInputs.ip.value || "",
        mac: ui.itemInputs.mac.value || "",
        notes: "",
        images: []
      };

      await dbSet(PATH.item(state.recordId, listId, id), item);

      Object.values(ui.itemInputs).forEach(el => el.value = "");
    }

    // ============================
    // Sidebar pills
    // ============================
    function renderSidebarPills() {
      ui.sectionListEl.innerHTML = "";
      renderSidebarSummary();

      const makePill = ({ title, right, isActive, onClick }) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "section-pill" + (isActive ? " active" : "");
        btn.innerHTML = `
        <span class="label">${title}</span>
        <span class="pill-progress">
          <span class="pill-dot ${right === "✓" ? "done" : ""}"></span>
          <span>${right}</span>
        </span>
      `;
        btn.addEventListener("click", onClick);
        ui.sectionListEl.appendChild(btn);
      };

      makePill({
        title: "Daily Tasks",
        right: String(Object.keys(state.daily || {}).length),
        isActive: state.activePanel === "daily",
        onClick: () => setActivePanel("daily")
      });

      const listIds = Object.keys(state.lists || {})
        .sort((a, b) => {
          const A = state.lists[a]?._name || a;
          const B = state.lists[b]?._name || b;
          return String(A).localeCompare(String(B), undefined, { sensitivity: "base" });
        });

      listIds.forEach(listId => {
        const listObj = state.lists[listId] || {};
        const count = Object.keys(getListItems(listObj)).length;
        makePill({
          title: listObj._name || listId,
          right: String(count),
          isActive: state.activePanel === "lists" && state.activeListId === listId,
          onClick: () => {
            state.activeListId = listId;
            saveLastOpenState({ activePanel: "lists", activeListId: listId });
            setActivePanel("lists");
          }
        });
      });

      if (!listIds.length) {
        makePill({
          title: "Lists",
          right: "0",
          isActive: state.activePanel === "lists",
          onClick: () => setActivePanel("lists")
        });
      }
    }

    // ============================
    // Uploads
    // ============================
    ui.imageUploadInput.addEventListener("change", async () => {
      const file = ui.imageUploadInput.files?.[0];
      if (!file || !pendingUploadTarget || !state.recordId) return;

      const target = pendingUploadTarget;
      pendingUploadTarget = null;

      try {
        const resizedBlob = await resizeImageToJpeg(file, 2048, 0.9);

        let storagePath;
        let dbNodePath;

        if (target.kind === "daily") {
          storagePath = storageImagePath({ kind: "daily", dailyKey: target.dailyKey });
          dbNodePath = PATH.dailyItem(state.recordId, target.dailyKey);
        } else {
          storagePath = storageImagePath({ kind: "listItem", listId: target.listId, itemId: target.itemId });
          dbNodePath = PATH.item(state.recordId, target.listId, target.itemId);
        }

        const sRef = storageRef(storage, storagePath);
        await uploadBytes(sRef, resizedBlob, { contentType: "image/jpeg" });
        const url = await getDownloadURL(sRef);

        const snap = await get(dbRef(dbNodePath));
        const current = snap.val() || {};
        const images = Array.isArray(current.images) ? current.images.slice() : [];
        images.push({ url, path: storagePath, note: "" });

        await dbUpdate(dbNodePath, { images });
      } catch (err) {
        console.error(err);
        alert("Image upload failed (check console).");
      } finally {
        ui.imageUploadInput.value = "";
      }
    });

    // ============================
    // Record loading
    // ============================
    async function ensureMetaExists(recordId) {
      const metaRef = dbRef(PATH.recordMeta(recordId));
      const snap = await get(metaRef);
      if (!snap.exists()) {
        await update(dbRef(PATH.record(recordId)), { meta: { updatedAt: Date.now() } });
      }
    }

    async function loadRecordById(id) {
      if (!id) return;

      detachRecordListener();

      state.recordId = id;
      saveLastOpenState({ recordId: id });
      renderDataPathLabel();

      const rRef = dbRef(PATH.record(id));
      const rCb = (snap) => {
        if (!snap.exists()) return;

        const data = snap.val() || {};
        state.customerName = data.customerName || "";
        state.notes = data.notes || "";
        state.projectFieldName = data.project || "";
        state.meta = data.meta || { updatedAt: 0 };
        state.links = Array.isArray(data.links) ? data.links : [];
        state.lists = data.lists || {};
        state.daily = data.tasks || {};

        const listIds = Object.keys(state.lists || {});
        if (state.activeListId && !state.lists[state.activeListId]) state.activeListId = "";
        if (!state.activeListId && listIds.length) state.activeListId = listIds[0];

        renderHeader();
        renderSidebarPills();
        renderAll();
      };

      state.listeners.recordRef = rRef;
      state.listeners.recordCb = rCb;
      onValue(rRef, rCb);

      await ensureMetaExists(id);
    }

    // ============================
    // Project creation
    // ============================
    async function createNewProjectWithName(name) {
      const now = Date.now();
      const newId = String(now);

      await set(dbRef(PATH.record(newId)), {
        id: newId,
        project: name,
        customerName: "",
        notes: "",
        meta: { updatedAt: now },
        tasks: {},
        lists: {},
        links: []
      });

      await loadRecordById(newId);

      ui.projectDropdown.value = newId;
      ui.projectNameInput.value = "";
      return newId;
    }

    // ============================
    // Render all
    // ============================
    function renderAll() {
      renderProjectLinks();

      if (!state.recordId) {
        ui.dailyTasksTableBody.innerHTML = "";
        ui.activeListTableBody.innerHTML = "";
        ui.dailyTasksCountLabel.textContent = "";
        ui.activeListCountLabel.textContent = "";
        return;
      }

      // Don’t clobber while typing (static fields)
      const siteVal = state.customerName || "";
      if (document.activeElement !== ui.siteNameInput && ui.siteNameInput.value !== siteVal) {
        ui.siteNameInput.value = siteVal;
      }

      const notesVal = state.notes || "";
      if (ui.projectNotesInput && document.activeElement !== ui.projectNotesInput && ui.projectNotesInput.value !== notesVal) {
        ui.projectNotesInput.value = notesVal;
      }

      if (state.activePanel === "daily") renderDailyTasks();
      if (state.activePanel === "lists") renderActiveList();
    }

    // ============================
    // Restore last-open state
    // ============================
    async function restoreLastOpenState() {
      const saved = loadLastOpenState();

      if (typeof saved.globalQuery === "string") {
        state.globalQuery = saved.globalQuery;
        ui.globalSearchInput.value = saved.globalQuery;
      }

      if (saved.recordId) {
        await loadRecordById(saved.recordId);
      }

      if (saved.activePanel === "lists") {
        const listIds = Object.keys(state.lists || {});
        state.activeListId = (saved.activeListId && state.lists?.[saved.activeListId])
          ? saved.activeListId
          : (listIds[0] || "");
        setActivePanel("lists");
      } else {
        setActivePanel("daily");
      }
    }

    // ============================
    // Events
    // ============================
    ui.setProjectBtn.addEventListener("click", async () => {
      const name = (ui.projectNameInput.value || "").trim();
      if (!name) return alert("Enter a project name to create.");
      await createNewProjectWithName(name);
    });

    ui.projectNameInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        ui.setProjectBtn.click();
      }
    });

    ui.projectDropdown.addEventListener("change", async () => {
      const id = ui.projectDropdown.value;
      if (!id) return;
      await loadRecordById(id);
    });

    ui.clearAppDataBtn.addEventListener("click", async () => {
      if (!state.recordId) return alert("No project selected.");
      if (!confirm("Clear app data for this record? (customerName, notes, daily tasks, lists, links)")) return;

      await dbUpdate(PATH.record(state.recordId), {
        customerName: "",
        notes: "",
        meta: { ...state.meta, updatedAt: Date.now() },
        tasks: {},
        lists: {},
        links: []
      }, false);

      await touchRecord();

      state.activeListId = "";
      clearLastOpenState();
      setActivePanel("daily");
    });

    ui.addDailyTaskBtn.addEventListener("click", addDailyTask);
    ui.createListBtn.addEventListener("click", createList);
    ui.deleteListBtn.addEventListener("click", deleteActiveList);
    ui.addItemBtn.addEventListener("click", addItemToActiveList);

    const debouncedSearchRender = debounce(() => {
      saveLastOpenState({ globalQuery: state.globalQuery });
      renderAll();
      renderProjectDropdown();
    }, 120);

    ui.globalSearchInput.addEventListener("input", () => {
      state.globalQuery = ui.globalSearchInput.value || "";
      debouncedSearchRender();
    });

    ui.projectLinksForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      if (!state.recordId) return alert("Select a project first.");

      const title = (ui.projectLinkTitle.value || "").trim();
      const url = (ui.projectLinkUrl.value || "").trim();
      if (!title || !url) return alert("Title and URL are required.");
      try { new URL(url); } catch { return alert("Invalid URL (include https://)"); }

      const next = Array.isArray(state.links) ? state.links.slice() : [];
      next.push({ title, url });

      ui.projectLinkTitle.value = "";
      ui.projectLinkUrl.value = "";

      await dbUpdate(PATH.record(state.recordId), { links: next });
    });

    ui.exportCsvBtn.addEventListener("click", exportCsv);

    ui.importCsvBtn.addEventListener("click", () => {
      if (!state.recordId) return alert("Select a project first.");
      ui.csvImportInput.value = "";
      ui.csvImportInput.click();
    });

    ui.csvImportInput.addEventListener("change", async () => {
      const file = ui.csvImportInput.files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        await importAnyCsvText(text);
      } catch (e) {
        console.error(e);
        alert("CSV import failed (check console).");
      } finally {
        ui.csvImportInput.value = "";
      }
    });

    // ✅ Dirty blur for STATIC fields (attached once)
    attachDirtyBlur(ui.siteNameInput, async (val) => {
      if (!state.recordId) return;
      await dbUpdate(PATH.record(state.recordId), { customerName: val });
    });

    if (ui.projectNotesInput) {
      attachDirtyBlur(ui.projectNotesInput, async (val) => {
        if (!state.recordId) return;
        await dbUpdate(PATH.record(state.recordId), { notes: val });
      });
    }

    // ============================
    // Init + Auth
    // ============================
    function initUIForBasePath() {
      renderDataPathLabel();
      startTasksDropdownListener();
      renderSidebarPills();
      setActivePanel("daily");
    }

    initUIForBasePath();

    onAuthStateChanged(auth, async (user) => {
      DATABASE_BASE_PATH = user ? `${user.uid}` : "public";

      detachRecordListener();
      detachDropdownListener();

      // reset in-memory state
      state.recordId = "";
      state.projectFieldName = "";
      state.customerName = "";
      state.notes = "";
      state.links = [];
      state.lists = {};
      state.daily = {};
      state.activeListId = "";
      state.globalQuery = "";

      if (ui.globalSearchInput) ui.globalSearchInput.value = "";
      dropdownProjectsCache = [];

      initUIForBasePath();
      await restoreLastOpenState();
    });
  </script>

</body>

</html>