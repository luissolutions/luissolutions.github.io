<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Knowledge RPG - Firebase</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script type="module" src="./assets/js/login.js"></script>
    <link rel="stylesheet" href="../assets/css/app-styles.css" id="stylesheet">
    <link rel="stylesheet" href="./assets/css/livegame.css" id="stylesheet">

</head>

<body>
    <header>
        <h1>Knowledge RPG</h1>
        <section id="login-section" style="display: none;">
            <form id="login-form">
                <label for="username">Email:</label>
                <input type="email" id="username" required>
                <br>
                <label for="password">Password:</label>
                <input type="password" id="password" required>
                <br>
                <button type="submit">Login</button>
            </form>
            <button id="logout" style="display: none;">Logout</button>

            <div class="ms" style="display: none;">
                <button id="loginButton">Login to Microsoft</button>
                <button id="logoutButton">Logout of Microsoft</button>
                <p id="loginStatus">Checking login status...</p>
            </div>

        </section>
    </header>
    <br>

    <div class="panel">
        <span class="hint" id="authHint"></span><br>
        Coins: <span id="coins">0</span> |
        XP: <span id="xp">0</span> |
        Level: <span id="level">1</span>
    </div>

    <!-- QUIZ -->
    <div id="quiz" class="panel mode">

        <div class="row">
            <button id="resetProgressBtn">Reset Quiz Progress</button>
            <button id="closeQuizBtn">âœ– Close</button>
        </div>

        <div class="panel">
            <label for="quizTopicSelect"><strong>Select Topic:</strong></label>
            <select id="quizTopicSelect">
                <option value="">-- Choose Topic --</option>
            </select>
        </div>

        <div id="quizStats" class="hint"></div>

        <div id="quizSection" class="panel quizCard"></div>

        <div id="recoveryShop" class="panel"></div>

    </div>

    <!-- MATH -->
    <div id="math" class="panel mode">

        <div class="row">
            <h3 style="margin:0;">Math Challenge</h3>
            <button id="closeMathBtn">âœ– Close</button>
        </div>

        <div id="mathGame" class="panel">

            <table id="mathTable"></table>

            <div id="mathPrompt"></div>

            <input type="number" id="mathAnswerInput">
            <button id="mathSubmitBtn">Submit</button>
            <button id="mathResetBtn">Reset</button>

            <div id="mathStats" class="hint"></div>

        </div>

    </div>

    <!-- ROOM -->
    <div id="room" class="panel mode">

        <div class="layout">

            <!-- LEFT COLUMN -->
            <div class="leftColumn">
                <canvas id="canvas" width="512" height="512" tabindex="0"></canvas>
            </div>

            <!-- RIGHT COLUMN -->
            <div class="rightColumn">
                <div id="infoPanel" class="panel">
                    Walk up to an item and press <b>E</b> â€” or click an item.
                </div>

                <div id="inventoryPanel" class="panel"></div>

                <div class="panel">
                    <label for="bgUpload" class="fileBtn">Upload Background</label>
                    <input type="file" id="bgUpload" style="display:none;">
                    <span id="bgFileName" class="hint"></span> <br>

                    <select id="blockTypeSelect">
                        <option value="npc">NPC</option>
                        <option value="quiz">Quiz</option>
                        <option value="math">Math</option>
                        <option value="shop">Shop</option>
                        <option value="door">Door</option>
                        <option value="app">App</option>
                    </select>
                    <br>
                    <input type="text" id="appUrlInput" placeholder="App URL (e.g. livenotes.html)">
                    <br>
                    <input type="file" id="blockImageUpload" accept="image/*">
                </div>

                <p class="hint">
                    Move: WASD / Arrows â€¢ Inspect: E â€¢ Drag item: mouse â€¢ Triple-click item: delete
                </p>
            </div>

        </div>
    </div>

    <!-- SHOP -->
    <div id="shop" class="panel mode">

        <div class="row">
            <h3 style="margin:0;">Shop (Inventory Driven)</h3>
            <button id="closeShopBtn">âœ– Close</button>
        </div>

        <div id="shopPanel"></div>
    </div>

    <!-- APP MODE -->
    <div id="app" class="panel mode">

        <div class="row">
            <h3 style="margin:0;">External App</h3>
            <button id="closeAppBtn">âœ– Close</button>
        </div>

        <iframe id="appFrame" src="" style="width:100%; height:500px; border:none;">
        </iframe>

    </div>

    <script type="module">
        import {
            auth, onAuthStateChanged, database, ref, onValue, set, update,
            storage, storageRef, uploadBytes, getDownloadURL, deleteObject, remove,
        } from '../assets/js/firebase-init.js';
        import { createQuizModule } from './assets/js/livegame.js';

        /* ================= BASE ================= */

        let DATABASE_BASE_PATH = 'public';

        const state = {
            coins: 0,
            xp: 0,
            level: 1,
            roomItems: {},
            player: { x: 7, y: 10, dir: 'down' }
        };

        const TILE = 32;
        const GRID = 16;


        let shopItems = [];
        let drag = null, hover = null;
        let clickCount = 0, lastClick = 0;
        let mouseDownPos = null;

        const itemImageCache = new Map(); // url -> HTMLImageElement
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const bgImage = new Image();

        bgImage.src = './assets/img/room-bg.png';
        let bgLoaded = false;

        bgImage.onload = () => {
            bgLoaded = true;
        };

        // ðŸ”¥ QUIZ BLOCK IMAGE
        const quizPortalImg = new Image();
        quizPortalImg.src = './assets/img/quiz-block2.png';
        let quizPortalLoaded = false;

        quizPortalImg.onload = () => {
            quizPortalLoaded = true;
        };

        const FRAME_WIDTH = 32;
        const FRAME_HEIGHT = 32;
        const FRAMES_PER_ROW = 3;

        let animationFrame = 0;
        let lastFrameTime = 0;
        const FRAME_SPEED = 150; // ms
        const playerSprite = new Image();
        playerSprite.src = './assets/img/player.png';
        let spriteLoaded = false;

        let activeInteraction = null;
        let dialogueIndex = 0;

        playerSprite.onload = () => {
            spriteLoaded = true;
        };

        // Quiz memory
        let allQuestions = [];
        let questions = [];
        let currentQuestionIndex = 0;

        let answeredQuestions = {}; // { [id]: 'answered' | 'incorrect' }
        let correctAnswersCount = 0;
        let wrongAnswersCount = 0;

        function getCurrentRoomItems() {

            if (!state.roomItems[currentRoom]) {
                state.roomItems[currentRoom] = {};
            }

            return state.roomItems[currentRoom];
        }

        /* ================= MATH GAME ================= */

        let mathNum1 = 0;
        let mathNum2 = 0;
        let mathScore = 0;
        let answeredSet = new Set();

        const CORRECT_REWARD = 500;
        const WRONG_COST = 200;

        function generateMathTable() {

            const table = document.getElementById('mathTable');
            table.innerHTML = '';

            for (let i = 0; i <= 9; i++) {

                const row = table.insertRow();

                for (let j = 0; j <= 9; j++) {

                    const cell = row.insertCell();
                    cell.style.width = '32px';
                    cell.style.height = '32px';
                    cell.style.textAlign = 'center';
                    cell.style.border = '1px solid #444';

                    if (i === 0 && j > 0) {
                        cell.textContent = j;
                    } else if (j === 0 && i > 0) {
                        cell.textContent = i;
                    } else if (i > 0 && j > 0) {
                        const key = `${i}_${j}`;
                        if (answeredSet.has(key)) {
                            cell.textContent = i * j;
                        } else {
                            cell.textContent = '';
                        }
                    }
                }
            }
        }

        function generateMathQuestion() {

            if (answeredSet.size >= 81) {
                endMathGame();
                return;
            }

            do {
                mathNum1 = Math.floor(Math.random() * 9) + 1;
                mathNum2 = Math.floor(Math.random() * 9) + 1;
            } while (answeredSet.has(`${mathNum1}_${mathNum2}`));

            document.getElementById('mathPrompt').innerHTML =
                `What is <strong>${mathNum1} Ã— ${mathNum2}</strong>?`;

            document.getElementById('mathAnswerInput').value = '';
        }

        function updateMathStats() {
            document.getElementById('mathStats').innerHTML =
                `Solved: ${answeredSet.size} / 81`;
        }

        function submitMathAnswer() {

            const input = document.getElementById('mathAnswerInput');
            const answer = parseInt(input.value);

            if (isNaN(answer)) return;

            const correct = answer === mathNum1 * mathNum2;

            if (correct) {

                answeredSet.add(`${mathNum1}_${mathNum2}`);
                mathScore++;

                state.coins += CORRECT_REWARD;
                state.xp += 3;

            } else {

                state.coins = Math.max(0, state.coins - WRONG_COST);
            }

            state.level = levelFromXP(state.xp);

            renderHUD();
            persistPlayer();

            generateMathTable();
            updateMathStats();
            generateMathQuestion();
            persistMath();
        }

        function startMathGame() {
            loadMathProgress();
        }

        function resetMathGame() {
            answeredSet.clear();
            mathScore = 0;

            set(ref(database, mathPath()), null);

            generateMathTable();
            updateMathStats();
            generateMathQuestion();
        }

        function endMathGame() {

            document.getElementById('mathPrompt').innerHTML =
                `All problems solved! Final Score: ${mathScore}`;

            document.getElementById('mathStats').innerHTML = '';

            setTimeout(() => {
                setMode('room');
                focusCanvas();
            }, 2500);
        }

        function mathPath() {
            return `${DATABASE_BASE_PATH}/gameData/mathProgress`;
        }

        function persistMath() {
            return set(ref(database, mathPath()), {
                answered: Array.from(answeredSet),
                score: mathScore
            });
        }

        function loadMathProgress() {
            onValue(ref(database, mathPath()), (snap) => {
                const data = snap.val();

                if (!data) {
                    answeredSet = new Set();
                    mathScore = 0;
                } else {
                    answeredSet = new Set(data.answered || []);
                    mathScore = data.score || 0;
                }

                generateMathTable();
                updateMathStats();
                generateMathQuestion();
            });
        }

        function focusCanvas() { canvas?.focus?.(); }

        function safeKey(str) {
            return String(str)
                .toLowerCase()
                .replace(/\./g, '')
                .replace(/[#$\/\[\]]/g, '')
                .replace(/\s+/g, '_')
                .replace(/[^a-z0-9_-]/g, '');
        }

        function escapeHTML(s) {
            return String(s ?? '').replace(/[&<>"']/g, c => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'
            }[c]));
        }

        /* ================= ROOM SYSTEM ================= */
        let gameStarted = false;

        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            loop();
        }

        let currentRoom = "room1";

        let rooms = {};

        function loadRooms() {
            const path = `${DATABASE_BASE_PATH}/gameData/rooms`;

            onValue(ref(database, path), async (snap) => {

                // ðŸ”¥ Safe existence check
                if (!snap.exists()) {
                    console.log("No rooms found. Creating default room...");
                    await createDefaultRoom();
                    return;
                }

                const data = snap.val();
                rooms = data;

                if (!rooms[currentRoom]) {
                    currentRoom = Object.keys(rooms)[0];
                }

                if (rooms[currentRoom]?.bg) {
                    bgLoaded = false;
                    bgImage.src = rooms[currentRoom].bg;
                }

                startGame();
            });
        }

        async function createDefaultRoom() {

            const defaultRoom = {
                bg: "",
                walls: [],
                interactables: {
                    default_npc: {
                        id: "default_npc",
                        type: "npc",
                        x: 6,
                        y: 6,
                        solid: true,
                        draggable: true,
                        img: "",
                        dialogue: [
                            "Welcome to Knowledge RPG.",
                            "This room was auto-generated.",
                            "Start building your world!"
                        ]
                    }
                }
            };

            // ðŸ”¥ Only create room1 node, do NOT overwrite rooms
            await update(
                ref(database, `${DATABASE_BASE_PATH}/gameData/rooms`),
                { room1: defaultRoom }
            );
        }

        /* ================= ROOM CHANGE ================= */

        function changeRoom(roomName) {

            if (!rooms[roomName]) return;

            currentRoom = roomName;

            if (rooms[currentRoom]?.bg) {
                bgLoaded = false;
                bgImage.src = rooms[currentRoom].bg;
            }
            // reset player position (optional)
            state.player.x = 5;
            state.player.y = 5;
        }

        function createRoom(roomId, returnRoom = null, doorImage = null) {

            const newRoom = {
                bg: "",
                walls: [],
                interactables: {}
            };

            if (returnRoom) {
                newRoom.interactables["return_door"] = {
                    id: "return_door",
                    type: "door",
                    x: 5,
                    y: 5,
                    solid: true,
                    draggable: true,
                    target: returnRoom,
                    img: doorImage || "./assets/img/door.png"  // ðŸ”¥ uses same image
                };
            }

            return update(
                ref(database, `${DATABASE_BASE_PATH}/gameData/rooms`),
                { [roomId]: newRoom }
            );
        }

        function addBlockToRoom(roomId, blockData) {
            const id = safeKey(blockData.type + "_" + Date.now());

            set(
                ref(database,
                    `${DATABASE_BASE_PATH}/gameData/rooms/${roomId}/interactables/${id}`
                ),
                {
                    ...blockData,
                    id
                }
            );
        }

        /* ================= COLLISION ================= */

        function isSolidTile(x, y) {

            if (x < 0 || x >= GRID || y < 0 || y >= GRID) return true;

            if (getItem(x, y)) return true;

            const room = rooms[currentRoom];
            if (!room) return true;

            // walls
            for (const wall of room.walls || []) {
                if (wall.x === x && wall.y === y) return true;
            }

            // interactables
            for (const obj of Object.values(room.interactables || {})) {
                if (obj.solid && obj.x === x && obj.y === y) {
                    return true;
                }
            }

            return false;
        }

        /* ================= DRAW INTERACTABLES ================= */

        function drawInteractables() {

            const room = rooms[currentRoom];
            if (!room) return;

            const interactables = room.interactables || {};

            Object.values(interactables).forEach(obj => {

                const px = obj.x * TILE;
                const py = obj.y * TILE;

                if (obj.img) {
                    const img = getCachedImage(obj.img);

                    if (img && img.complete && img.naturalWidth > 0) {
                        ctx.drawImage(img, px, py, TILE, TILE);
                        return;
                    }
                }

                ctx.fillStyle = '#ff3cff';
                ctx.fillRect(px + 4, py + 4, TILE - 8, TILE - 8);
            });
        }

        /* ================= INTERACTION ================= */

        function getInteractableInFront() {

            let { x, y } = state.player;

            if (state.player.dir === 'up') y--;
            if (state.player.dir === 'down') y++;
            if (state.player.dir === 'left') x--;
            if (state.player.dir === 'right') x++;

            return Object.values(rooms[currentRoom]?.interactables || {})
                .find(obj => obj.x === x && obj.y === y);
        }

        async function handleInteraction(obj) {
            if (!obj) return;

            // If object has dialogue
            if (obj.dialogue && obj.dialogue.length) {

                // If starting new interaction
                if (activeInteraction !== obj) {
                    activeInteraction = obj;
                    dialogueIndex = 0;
                }

                const text = obj.dialogue[dialogueIndex];

                infoPanel.innerHTML = `
                    <div class="panel">
                        ${text}
                        <div class="hint">(Press E to continue)</div>
                    </div>
                `;

                dialogueIndex++;

                // If dialogue finished
                if (dialogueIndex >= obj.dialogue.length) {

                    dialogueIndex = 0;
                    activeInteraction = null;

                    // AFTER dialogue, open element
                    if (obj.type === 'quiz') setMode('quiz');
                    if (obj.type === 'math') {
                        setMode('math');
                        startMathGame();
                    } if (obj.type === 'shop') setMode('shop');
                    if (obj.type === 'door') changeRoom(obj.target);
                    if (obj.type === 'app') {
                        if (!obj.appUrl) {
                            infoPanel.innerHTML = "No app URL defined.";
                            return;
                        }

                        const frame = document.getElementById('appFrame');
                        frame.src = obj.appUrl;

                        setMode('app');
                    }
                }

                return;
            }

            if (obj.type === 'quiz') setMode('quiz');
            if (obj.type === 'shop') setMode('shop');
            if (obj.type === 'door') {

                if (!rooms[obj.target]) {
                    await createRoom(obj.target);
                }

                changeRoom(obj.target);
            }
        }

        /* ================= MODE ================= */
        function getCachedImage(url) {
            if (!url) return null;

            if (itemImageCache.has(url)) return itemImageCache.get(url);

            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = url;

            itemImageCache.set(url, img);
            return img;
        }

        function setMode(mode) {
            document.querySelectorAll('.mode').forEach(m => m.style.display = 'none');
            document.getElementById(mode).style.display = 'block';
            if (mode === 'room') focusCanvas();
        }

        setMode('room');
        focusCanvas();

        /* ================= HUD ================= */

        function renderHUD() {
            const coinsEl = document.getElementById('coins');
            const xpEl = document.getElementById('xp');
            const levelEl = document.getElementById('level');

            if (!coinsEl || !xpEl || !levelEl) return;

            coinsEl.textContent = (state.coins / 100).toFixed(2);
            xpEl.textContent = state.xp;
            levelEl.textContent = state.level;
        }

        function levelFromXP(xp) {
            if (xp < 100) return 1;
            if (xp < 300) return 2;
            if (xp < 600) return 3;
            if (xp < 1000) return 4;
            return 5;
        }

        function rewardCorrect(topic = '') {
            state.coins += 1000;
            state.xp += 5;
            state.level = levelFromXP(state.xp);
        }

        function punishWrong(topic = '') {
            state.coins = Math.max(0, state.coins - 200);
            state.level = levelFromXP(state.xp);
        }

        /* ================= FIREBASE PLAYER SAVE/LOAD ================= */

        function playerPath() {
            return `${DATABASE_BASE_PATH}/gameData/player`;
        }

        function progressPath() {
            return `${DATABASE_BASE_PATH}/gameData/progress`;
        }

        function loadPlayer() {
            onValue(ref(database, playerPath()), (snap) => {
                const data = snap.val();
                if (!data) {
                    renderHUD();
                    renderInventory();
                    return;
                }

                state.coins = Number(data.coins || 0);
                state.xp = Number(data.xp || 0);
                state.level = Number(data.level || 1);

                // restore room background safely
                if (rooms[currentRoom]?.bg) {
                    bgLoaded = false;
                    bgImage.src = rooms[currentRoom].bg;
                }

                // inventory restore
                state.roomItems = data.roomItems || {};

                renderHUD();
                renderInventory();
            });
        }

        function persistPlayer() {

            return set(ref(database, playerPath()), {
                coins: state.coins,
                xp: state.xp,
                level: state.level,
                room: currentRoom,
                roomItems: state.roomItems,
                player: state.player
            });
        }

        /* ================= SHOP LOAD ================= */

        function loadShop() {
            const path = `${DATABASE_BASE_PATH}/ledgerTx`;

            onValue(ref(database, path), (snap) => {
                const raw = snap.val() || {};
                const list = [];

                Object.values(raw).forEach(year => {
                    Object.values(year || {}).forEach(v => {
                        if (!v) return;
                        if (v.type !== 'expense') return;

                        const tags = Array.isArray(v.tags) ? v.tags : [];

                        const hasInv = tags.some(t => String(t).toLowerCase() === 'inv');
                        if (!hasInv) return;

                        const isXL = tags.some(t => String(t).toLowerCase() === 'xl');

                        list.push({
                            sku: v.sku || v.name,
                            name: v.name || v.sku || 'Item',
                            price: Math.abs(Number(v.amt || 0)),
                            img: v.img || '',
                            desc: v.desc || '',
                            cat: v.cat || '',
                            link: v.link || '',
                            size: isXL ? 2 : 1
                        });
                    });
                });

                const grouped = {};
                list.forEach(i => {
                    const k = safeKey(i.sku);
                    if (!grouped[k]) grouped[k] = i;
                });

                shopItems = Object.values(grouped);
                renderShop();
            });
        }

        // Buy adds the item at (0,0) like your original.
        // (You can swap this to "place mode" later if you want.)
        function renderShop() {
            shopPanel.innerHTML = '';

            if (!shopItems.length) {
                shopPanel.innerHTML = '<div class="hint">No inv-tagged inventory items found in ledgerTx.</div>';
                return;
            }

            shopItems.forEach(item => {
                const btn = document.createElement('button');
                btn.textContent = `Buy ${item.name} (${item.price})`;

                btn.onclick = () => {
                    if (state.coins < item.price) return alert('Not enough coins.');

                    state.coins -= Math.round(item.price * 100); const key = safeKey(item.sku);

                    const roomInventory = getCurrentRoomItems();

                    if (!roomInventory[key]) roomInventory[key] = [];

                    roomInventory[key].push({
                        x: 0,
                        y: 0,
                        name: item.name,
                        sku: item.sku,
                        price: item.price,
                        img: item.img || '',
                        desc: item.desc || '',
                        cat: item.cat || '',
                        link: item.link || '',
                        size: item.size || 1
                    });

                    renderHUD();
                    renderInventory();
                    persistPlayer();
                };

                shopPanel.appendChild(btn);
            });
        }

        /* ================= INVENTORY PANEL ================= */

        function renderInventory() {

            inventoryPanel.innerHTML = '<h3>Inventory</h3>';

            const roomInventory = getCurrentRoomItems();

            const entries = Object.entries(roomInventory).filter(([, v]) => Array.isArray(v));

            if (!entries.length) {
                inventoryPanel.innerHTML += '<div class="hint">No items yet in this room.</div>';
                return;
            }

            for (const [key, list] of entries) {
                const div = document.createElement('div');
                div.className = 'inventory-line';
                div.textContent = `${list[0]?.name || key} x ${list.length}`;
                inventoryPanel.appendChild(div);
            }
        }

        /* ================= ROOM ================= */

        function tile(e) {
            const rect = canvas.getBoundingClientRect();

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;

            return {
                x: Math.floor(canvasX / TILE),
                y: Math.floor(canvasY / TILE)
            };
        }

        function drawItems() {

            const roomInventory = getCurrentRoomItems();

            for (const list of Object.values(roomInventory)) {

                if (!Array.isArray(list)) continue;

                list.forEach(obj => {

                    if (drag && drag.obj === obj) return;

                    if (obj.img) {
                        const img = getCachedImage(obj.img);

                        if (img && img.complete && img.naturalWidth > 0) {
                            const size = obj.size || 1;

                            ctx.drawImage(
                                img,
                                obj.x * TILE,
                                obj.y * TILE,
                                TILE * size,
                                TILE * size
                            );
                            return;
                        }
                    }

                    ctx.fillStyle = "#999";
                    const size = obj.size || 1;

                    ctx.fillRect(
                        obj.x * TILE + 5,
                        obj.y * TILE + 5,
                        TILE * size - 10,
                        TILE * size - 10
                    );
                });
            }

            if (drag && hover) {
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#fff';
                ctx.fillRect(hover.x * TILE + 5, hover.y * TILE + 5, TILE - 10, TILE - 10);
                ctx.globalAlpha = 1;
            }
        }

        function isAreaFree(x, y, size = 1) {

            for (let dy = 0; dy < size; dy++) {
                for (let dx = 0; dx < size; dx++) {

                    if (x + dx >= GRID || y + dy >= GRID) return false;

                    if (getItem(x + dx, y + dy)) return false;
                }
            }

            return true;
        }
        function drawGrid() {
            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    ctx.fillStyle = (x + y) % 2 ? '#141a33' : '#18203b';
                    ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
                }
            }
        }

        function drawPlayer() {
            if (!spriteLoaded) return;

            let row = 0;

            if (state.player.dir === 'down') row = 0;
            if (state.player.dir === 'left') row = 1;
            if (state.player.dir === 'right') row = 2;
            if (state.player.dir === 'up') row = 3;

            const sx = animationFrame * FRAME_WIDTH;
            const sy = row * FRAME_HEIGHT;

            ctx.drawImage(
                playerSprite,
                sx, sy,
                FRAME_WIDTH, FRAME_HEIGHT,
                state.player.x * TILE,
                state.player.y * TILE,
                TILE,
                TILE
            );
        }

        function draw() {
            ctx.clearRect(0, 0, 512, 512);

            if (bgImage.complete && bgImage.naturalWidth > 0) {
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            } else {
                drawGrid();
            }

            drawInteractables();
            drawItems();
            drawPlayer();
        }

        /* ================= INSPECT ================= */

        function getItem(x, y) {

            const roomInventory = getCurrentRoomItems();

            for (const [key, list] of Object.entries(roomInventory)) {

                if (!Array.isArray(list)) continue;

                for (const obj of list) {

                    const size = obj.size || 1;

                    for (let dy = 0; dy < size; dy++) {
                        for (let dx = 0; dx < size; dx++) {

                            if (obj.x + dx === x && obj.y + dy === y) {
                                return { key, obj };
                            }
                        }
                    }
                }
            }

            return null;
        }

        function getItemInFront() {
            let { x, y } = state.player;
            if (state.player.dir === 'up') y--;
            if (state.player.dir === 'down') y++;
            if (state.player.dir === 'left') x--;
            if (state.player.dir === 'right') x++;
            return getItem(x, y);
        }

        function inspectItem(item) {

            if (!item) {
                infoPanel.innerHTML = "Nothing here.";
                return;
            }

            const obj = item.obj;

            const imageHTML = obj.img
                ? `<img src="${obj.img}" 
            style="
                width:140px;
                image-rendering:pixelated;
                display:block;
                margin-bottom:12px;
                border:3px solid #d4af37;
                box-shadow:0 0 10px rgba(212,175,55,.6);
            ">`
                : '';

            const skuHTML = obj.sku
                ? `<div class="small">SKU: ${escapeHTML(obj.sku)}</div>`
                : '';

            const priceHTML = obj.price
                ? `<div class="small">Price: $${Number(obj.price).toFixed(2)}</div>`
                : '';

            const catHTML = obj.cat
                ? `<div class="small hint">Category: ${escapeHTML(obj.cat)}</div>`
                : '';

            const descHTML = obj.desc
                ? `<div class="hint" style="margin-top:10px;">${escapeHTML(obj.desc)}</div>`
                : '';

            const linkHTML = obj.link
                ? `<div style="margin-top:10px;">
                    <a href="${escapeHTML(obj.link)}" 
                        target="_blank" 
                        style="color:#d4af37;">
                        ðŸ”— View Product
                    </a>
                </div>`
                : '';

            infoPanel.innerHTML = `
                <div style="display:flex; gap:15px; align-items:flex-start;">
                    <div>${imageHTML}</div>

                    <div>
                        <div style="font-size:16px; margin-bottom:8px;">
                            <strong>${escapeHTML(obj.name || 'Item')}</strong>
                        </div>

                        ${skuHTML}
                        ${priceHTML}
                        ${catHTML}
                        ${descHTML}
                        ${linkHTML}
                    </div>
                </div>

                <div class="hint">Triple-click to delete â€¢ Drag to move</div>
            `;
        }
        /* ================= DRAG + DELETE ================= */

        canvas.onmousedown = (e) => {
            const { x, y } = tile(e);

            mouseDownPos = { x, y };

            const now = Date.now();
            clickCount = (now - lastClick < 400) ? clickCount + 1 : 1;
            lastClick = now;

            const item = getItem(x, y);

            // Triple click delete (items only)
            if (item && clickCount === 3) {
                const roomInventory = getCurrentRoomItems();
                const arr = roomInventory[item.key];
                const idx = arr.indexOf(item.obj);
                if (idx >= 0) arr.splice(idx, 1);

                clickCount = 0;
                renderInventory();
                persistPlayer();
                infoPanel.innerHTML = 'Item deleted.';
                return;
            }

        };

        canvas.onmousemove = (e) => {
            hover = tile(e);

            if (!mouseDownPos) return;

            // If mouse moved to different tile â†’ start drag
            if (hover.x !== mouseDownPos.x || hover.y !== mouseDownPos.y) {

                const interactable = Object.values(rooms[currentRoom]?.interactables || {})
                    .find(o => o.x === mouseDownPos.x && o.y === mouseDownPos.y);

                if (interactable && interactable.draggable) {
                    drag = { type: 'interactable', obj: interactable };
                    return;
                }

                const item = getItem(mouseDownPos.x, mouseDownPos.y);
                if (item) {
                    drag = item;
                }
            }
        };

        canvas.onmouseup = async (e) => {
            const { x, y } = tile(e);

            // If mouse didnâ€™t move â†’ treat as click
            if (mouseDownPos && mouseDownPos.x === x && mouseDownPos.y === y) {

                const interactable = Object.values(rooms[currentRoom]?.interactables || {})
                    .find(o => o.x === x && o.y === y);

                if (interactable) {
                    handleInteraction(interactable);
                    drag = null;
                    mouseDownPos = null;
                    return;
                }

                const item = getItem(x, y);
                if (item) inspectItem(item);

                drag = null;
                mouseDownPos = null;
                return;
            }

            // Otherwise it was a drag
            if (!drag || !hover) {
                drag = null;
                mouseDownPos = null;
                return;
            }

            // Interactable drag
            if (drag.type === 'interactable') {

                if (!isSolidTile(hover.x, hover.y)) {

                    drag.obj.x = hover.x;
                    drag.obj.y = hover.y;

                    await set(
                        ref(database,
                            `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${drag.obj.id}/x`),
                        hover.x
                    );

                    await set(
                        ref(database,
                            `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${drag.obj.id}/y`),
                        hover.y
                    );
                }

                drag = null;
                mouseDownPos = null;
                return;
            }

            // Room item drag
            const size = drag.obj.size || 1;
            if (isAreaFree(hover.x, hover.y, size)) {
                drag.obj.x = hover.x;
                drag.obj.y = hover.y;
                persistPlayer();
            }

            drag = null;
            mouseDownPos = null;
        };

        /* ================= PLAYER MOVEMENT (pokemon-ish step rate) ================= */

        const keys = {};
        let lastStepAt = 0;
        const STEP_MS = 140;

        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            keys[k] = true;

            if (e.key === 'Escape') {

                const currentAppFrame = document.getElementById('appFrame');
                if (currentAppFrame && currentAppFrame.src) {
                    currentAppFrame.src = '';
                }

                setMode('room');
                focusCanvas();
                return;
            }

            if (k === 'e') {

                const obj = getInteractableInFront();

                if (obj) {
                    handleInteraction(obj);
                    return;
                }

                const item = getItemInFront();
                inspectItem(item);
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function updatePlayer() {

            const now = performance.now();
            if (now - lastStepAt < STEP_MS) return;

            let newX = state.player.x;
            let newY = state.player.y;
            let moved = false;

            if (keys['arrowup'] || keys['w']) {
                newY--;
                state.player.dir = 'up';
                moved = true;
            } else if (keys['arrowdown'] || keys['s']) {
                newY++;
                state.player.dir = 'down';
                moved = true;
            } else if (keys['arrowleft'] || keys['a']) {
                newX--;
                state.player.dir = 'left';
                moved = true;
            } else if (keys['arrowright'] || keys['d']) {
                newX++;
                state.player.dir = 'right';
                moved = true;
            }

            if (!moved) {
                animationFrame = 1; // idle frame
                return;
            }

            if (newX < 0 || newX >= GRID || newY < 0 || newY >= GRID) {
                lastStepAt = now;
                return;
            }

            if (!isSolidTile(newX, newY)) {
                state.player.x = newX;
                state.player.y = newY;
                persistPlayer();
            }

            // Animate if moving
            const now2 = performance.now();
            if (now2 - lastFrameTime > FRAME_SPEED) {
                animationFrame = (animationFrame + 1) % FRAMES_PER_ROW;
                lastFrameTime = now2;
            }

            lastStepAt = now;
        }

        function loop() {
            updatePlayer();
            draw();
            requestAnimationFrame(loop);
        }

        /* ================= AUTH ================= */

        const quiz = createQuizModule({
            database,
            ref,
            onValue,
            set,
            remove,
            state,
            rewardCorrect,
            punishWrong,
            renderHUD,
            persistPlayer,
            basePathGetter: () => DATABASE_BASE_PATH
        });
        document.getElementById('closeQuizBtn')
            ?.addEventListener('click', () => {
                setMode('room');
                focusCanvas();
            });

        // Close Shop
        document.getElementById('closeShopBtn')
            ?.addEventListener('click', () => {
                setMode('room');
                focusCanvas();
            });

        // Close App
        document.getElementById('closeAppBtn')
            ?.addEventListener('click', () => {

                // ðŸ”¥ Clear iframe so app stops running
                const frame = document.getElementById('appFrame');
                if (frame) frame.src = '';

                setMode('room');
                focusCanvas();
            });


        onAuthStateChanged(auth, (user) => {
            DATABASE_BASE_PATH = user ? user.uid : 'public';
            const authHintEl = document.getElementById('authHint');
            if (authHintEl) {
                authHintEl.textContent = user
                    ? `Logged in: ${user.email || user.uid}`
                    : 'Guest mode (public)';
            }

            loadPlayer();
            loadRooms();
            loadShop();

            quiz.loadQuizProgress();
            quiz.populateQuizIndex();
        });

        renderHUD();
        renderInventory();

        document.getElementById('mathSubmitBtn')
            ?.addEventListener('click', submitMathAnswer);

        document.getElementById('mathResetBtn')
            ?.addEventListener('click', resetMathGame);

        document.getElementById('mathAnswerInput')
            ?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') submitMathAnswer();
            });

        document.getElementById('closeMathBtn')
            ?.addEventListener('click', () => {
                setMode('room');
                focusCanvas();
            });

        document.getElementById('bgUpload')
            ?.addEventListener('change', async (e) => {

                const file = e.target.files[0];
                if (!file) return;

                const ROOT_PATH = auth.currentUser?.uid || "public";
                const cleanName = file.name.replace(/\s+/g, '_').toLowerCase();

                const path =
                    `${ROOT_PATH}/gameData/roomAssets/${currentRoom}/bg_${Date.now()}_${cleanName}`;

                const fileRef = storageRef(storage, path);

                await uploadBytes(fileRef, file);
                const url = await getDownloadURL(fileRef);

                // ðŸ”¥ SAFE UPDATE â€” does not overwrite walls/interactables
                await update(
                    ref(database, `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}`),
                    { bg: url }
                );

                bgLoaded = false;
                bgImage.src = url;

                console.log("Background uploaded safely:", url);
            });

        document.getElementById('blockImageUpload')
            ?.addEventListener('change', async (e) => {

                const file = e.target.files[0];
                if (!file) return;

                const uid = auth.currentUser?.uid || "public";
                const cleanName = file.name.replace(/\s+/g, '_').toLowerCase();
                const ROOT_PATH = auth.currentUser?.uid || "public";

                const path =
                    `${ROOT_PATH}/gameData/blockAssets/${Date.now()}_${cleanName}`;

                const fileRef = storageRef(storage, path);
                await uploadBytes(fileRef, file);
                const url = await getDownloadURL(fileRef);

                const type = document.getElementById("blockTypeSelect").value;

                const baseBlock = {
                    type,
                    x: state.player.x + 1,
                    y: state.player.y,
                    solid: true,
                    draggable: true,
                    img: url
                };

                // Add special properties depending on type
                if (type === "npc") {
                    baseBlock.dialogue = [
                        "Hello!",
                        "I was created dynamically."
                    ];
                }

                if (type === "math") {
                    baseBlock.dialogue = [
                        "This portal tests your multiplication skills.",
                        "Solve problems to earn coins!"
                    ];
                }

                if (type === "app") {

                    const appUrl = document.getElementById("appUrlInput").value.trim();

                    if (!appUrl) {
                        alert("Enter an app URL first.");
                        return;
                    }

                    baseBlock.appUrl = appUrl;

                    baseBlock.dialogue = [
                        "This portal connects to an external system.",
                        "Press E again to open it."
                    ];
                }

                if (type === "door") {

                    const newRoomId = `room_${Date.now()}`;

                    baseBlock.target = newRoomId;

                    // ðŸ”¥ Pass the uploaded image to return door
                    await createRoom(newRoomId, currentRoom, url);
                }

                addBlockToRoom(currentRoom, baseBlock);
            });

    </script>
</body>

</html>