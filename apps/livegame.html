<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Knowledge RPG - Firebase</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script type="module" src="./assets/js/login.js"></script>
    <link rel="stylesheet" href="../assets/css/app-styles.css" id="stylesheet">
    <link rel="stylesheet" href="./assets/css/livegame.css" id="stylesheet">

</head>

<body>

    <header>
        <h1>Knowledge RPG</h1>
        <section id="login-section" style="display: none;">
            <form id="login-form">
                <label for="username">Email:</label>
                <input type="email" id="username" required>
                <br>
                <label for="password">Password:</label>
                <input type="password" id="password" required>
                <br>
                <button type="submit">Login</button>
            </form>
            <button id="logout" style="display: none;">Logout</button>

            <div class="ms" style="display: none;">
                <button id="loginButton">Login to Microsoft</button>
                <button id="logoutButton">Logout of Microsoft</button>
                <p id="loginStatus">Checking login status...</p>
            </div>
        </section>
    </header>

    <br>

    <div class="panel">
        <span class="hint" id="authHint"></span><br>
        Coins: <span id="coins">0</span> |
        XP: <span id="xp">0</span> |
        Level: <span id="level">1</span>
    </div>

    <!-- ROOM -->
    <div id="room" class="panel mode">
        <div class="layout">
            <!-- LEFT COLUMN -->
            <div class="leftColumn">
                <canvas id="canvas" width="512" height="512" tabindex="0"></canvas>
            </div>
            <!-- RIGHT COLUMN -->
            <div class="rightColumn">
                <div id="infoPanel" class="panel">
                    Walk up to an item and press <b>E</b> ‚Äî or click an item.
                </div>

                <div id="inventoryPanel" class="panel"></div>

                <div class="panel">
                    <label for="bgUpload" class="fileBtn">Upload Background</label>
                    <input type="file" id="bgUpload" style="display:none;">
                    <span id="bgFileName" class="hint"></span> <br>

                    <select id="blockTypeSelect">
                        <option value="npc">NPC</option>
                        <option value="quiz">Quiz</option>
                        <option value="math">Math</option>
                        <option value="shop">Shop</option>
                        <option value="door">Door</option>
                        <option value="app">App</option>
                        <option value="editor">Editor</option>
                    </select>
                    <br>
                    <input type="text" id="appUrlInput" placeholder="App URL (e.g. livenotes.html)">
                    <br>
                    <select id="blockShapeSelect">
                        <option value="1x1">1√ó1</option>
                        <option value="2x1">2√ó1</option>
                        <option value="1x2">1√ó2</option>
                        <option value="2x2">2√ó2</option>
                    </select>
                    <br>
                    <input type="file" id="blockImageUpload" accept="image/*">
                </div>

                <p class="hint">
                    Move: WASD / Arrows ‚Ä¢ Inspect: E ‚Ä¢ Drag item: mouse ‚Ä¢ Triple-click item: delete
                </p>
            </div>
        </div>
    </div>

    <!-- QUIZ -->
    <div id="quiz" class="panel mode">
        <div class="row">
            <button id="resetProgressBtn">Reset Quiz Progress</button>
            <button id="closeQuizBtn">‚úñ Close</button>
        </div>

        <div class="panel">
            <label for="quizTopicSelect"><strong>Select Topic:</strong></label>
            <select id="quizTopicSelect">
                <option value="">-- Choose Topic --</option>
            </select>
        </div>
        <div id="quizStats" class="hint"></div>
        <div id="quizSection" class="panel quizCard"></div>
        <div id="recoveryShop" class="panel"></div>
    </div>

    <!-- MATH -->
    <div id="math" class="panel mode">
        <div class="row">
            <h3>Math Challenge</h3>
            <button id="closeMathBtn">‚úñ Close</button>
        </div>
        <div id="mathGame" class="panel">

            <table id="mathTable"></table>

            <div id="mathPrompt"></div>

            <input type="number" id="mathAnswerInput">
            <button id="mathSubmitBtn">Submit</button>
            <button id="mathResetBtn">Reset</button>

            <div id="mathStats" class="hint"></div>
        </div>
    </div>

    <!-- SHOP -->
    <div id="shop" class="panel mode">
        <div class="row">
            <h3>Shop</h3>
            <button id="closeShopBtn">‚úñ Close</button>
        </div>
        <div id="shopPanel"></div>
    </div>

    <!-- APP MODE -->
    <div id="app" class="panel mode">
        <div class="row">
            <h3>External App</h3>
            <button id="closeAppBtn">‚úñ Close</button>
        </div>
        <iframe id="appFrame" src="" style="width:100%; height:800px;">
        </iframe>
    </div>

    <!-- EDITOR -->
    <div id="editor" class="panel mode">
        <div class="row">
            <h3>Room Editor</h3>
            <button id="closeEditorBtn">‚úñ Close</button>
            <button id="saveEditorBtn">üíæ Save</button>
        </div>

        <canvas id="editorCanvas" width="512" height="512"></canvas>

        <div class="hint">
            Wheel = zoom ‚Ä¢ Drag = move ‚Ä¢ Left click = wall ‚Ä¢ Right click = erase
        </div>
    </div>

    <script type="module">
        import {
            auth, onAuthStateChanged, database, ref, onValue, set, update,
            storage, storageRef, uploadBytes, getDownloadURL, deleteObject, remove,
        } from '../assets/js/firebase-init.js';
        import { createQuizModule } from './assets/js/livegame.js';
        import { createRoomEditor } from './assets/js/livegameEditor.js';

        /* ================= BASE ================= */

        let DATABASE_BASE_PATH = 'public';

        const state = {
            coins: 0,
            xp: 0,
            level: 1,
            roomItems: {},
            player: { x: 3, y: 3, dir: 'down' }
        };

        const GRID = 8;
        const TILE = 512 / GRID; // 64

        const roomEditor = createRoomEditor({
            database,
            ref,
            update,
            TILE,
            GRID
        });

        let shopItems = [];
        let drag = null, hover = null;
        let clickCount = 0, lastClick = 0;
        let mouseDownPos = null;
        let selectedInteractable = null;
        let lastClickTime = 0;
        const DOUBLE_CLICK_MS = 300;

        const itemImageCache = new Map();
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const bgImage = new Image();

        const DEFAULT_SPRITE_URL = './assets/img/default.png';

        const defaultSprite = new Image();
        defaultSprite.src = DEFAULT_SPRITE_URL;

        bgImage.src = './assets/img/room-bg.png';
        let bgLoaded = false;

        bgImage.onload = () => {
            bgLoaded = true;
        };

        // üî• QUIZ BLOCK IMAGE
        const quizPortalImg = new Image();
        quizPortalImg.src = './assets/img/quiz-block2.png';
        let quizPortalLoaded = false;

        quizPortalImg.onload = () => {
            quizPortalLoaded = true;
        };

        const FRAME_WIDTH = 32;
        const FRAME_HEIGHT = 32;
        const FRAMES_PER_ROW = 3;

        let animationFrame = 0;
        let lastFrameTime = 0;
        const FRAME_SPEED = 150; // ms
        const playerSprite = new Image();
        playerSprite.src = './assets/img/player.png';
        let spriteLoaded = false;

        let activeInteraction = null;
        let dialogueIndex = 0;

        playerSprite.onload = () => {
            spriteLoaded = true;
        };

        // Quiz memory
        let allQuestions = [];
        let questions = [];
        let currentQuestionIndex = 0;

        let answeredQuestions = {};
        let correctAnswersCount = 0;
        let wrongAnswersCount = 0;

        function getCurrentRoomItems() {

            if (!state.roomItems[currentRoom]) {
                state.roomItems[currentRoom] = {};
            }

            return state.roomItems[currentRoom];
        }

        /* ================= MATH GAME ================= */

        let mathNum1 = 0;
        let mathNum2 = 0;
        let mathScore = 0;
        let answeredSet = new Set();

        const CORRECT_REWARD = 500;
        const WRONG_COST = 200;

        function generateMathTable() {

            const table = document.getElementById('mathTable');
            table.innerHTML = '';

            for (let i = 0; i <= 9; i++) {

                const row = table.insertRow();

                for (let j = 0; j <= 9; j++) {

                    const cell = row.insertCell();
                    cell.style.width = '64px';
                    cell.style.height = '64px';
                    cell.style.textAlign = 'center';
                    cell.style.border = '1px solid #444';

                    if (i === 0 && j > 0) {
                        cell.textContent = j;
                    } else if (j === 0 && i > 0) {
                        cell.textContent = i;
                    } else if (i > 0 && j > 0) {
                        const key = `${i}_${j}`;
                        if (answeredSet.has(key)) {
                            cell.textContent = i * j;
                        } else {
                            cell.textContent = '';
                        }
                    }
                }
            }
        }

        function generateMathQuestion() {

            if (answeredSet.size >= 81) {
                endMathGame();
                return;
            }

            do {
                mathNum1 = Math.floor(Math.random() * 9) + 1;
                mathNum2 = Math.floor(Math.random() * 9) + 1;
            } while (answeredSet.has(`${mathNum1}_${mathNum2}`));

            document.getElementById('mathPrompt').innerHTML =
                `What is <strong>${mathNum1} √ó ${mathNum2}</strong>?`;

            document.getElementById('mathAnswerInput').value = '';
        }

        function updateMathStats() {
            document.getElementById('mathStats').innerHTML =
                `Solved: ${answeredSet.size} / 81`;
        }

        function submitMathAnswer() {

            const input = document.getElementById('mathAnswerInput');
            const answer = parseInt(input.value);

            if (isNaN(answer)) return;

            const correct = answer === mathNum1 * mathNum2;

            if (correct) {

                answeredSet.add(`${mathNum1}_${mathNum2}`);
                mathScore++;

                state.coins += CORRECT_REWARD;
                state.xp += 3;
                if (!mathNum1 || !mathNum2) return;
            } else {

                state.coins = Math.max(0, state.coins - WRONG_COST);
            }

            state.level = levelFromXP(state.xp);

            renderHUD();
            persistPlayer();

            generateMathTable();
            updateMathStats();
            generateMathQuestion();
            persistMath();
        }

        function startMathGame() {
            loadMathProgress();
        }

        function resetMathGame() {
            answeredSet.clear();
            mathScore = 0;

            set(ref(database, mathPath()), null);

            generateMathTable();
            updateMathStats();
            generateMathQuestion();
        }

        function endMathGame() {

            document.getElementById('mathPrompt').innerHTML =
                `All problems solved! Final Score: ${mathScore}`;

            document.getElementById('mathStats').innerHTML = '';
            mathNum1 = null;
            mathNum2 = null;
        }

        function mathPath() {
            return `${DATABASE_BASE_PATH}/gameData/mathProgress`;
        }

        function persistMath() {
            return set(ref(database, mathPath()), {
                answered: Array.from(answeredSet),
                score: mathScore
            });
        }

        import { get } from '../assets/js/firebase-init.js';

        async function loadMathProgress() {
            const snap = await get(ref(database, mathPath()));
            const data = snap.val();

            if (!data) {
                answeredSet = new Set();
                mathScore = 0;
            } else {
                answeredSet = new Set(data.answered || []);
                mathScore = data.score || 0;
            }

            generateMathTable();
            updateMathStats();
            generateMathQuestion();
        }

        function focusCanvas() { canvas?.focus?.(); }

        function safeKey(str) {
            return String(str)
                .toLowerCase()
                .replace(/\./g, '')
                .replace(/[#$\/\[\]]/g, '')
                .replace(/\s+/g, '_')
                .replace(/[^a-z0-9_-]/g, '');
        }

        function escapeHTML(s) {
            return String(s ?? '').replace(/[&<>"']/g, c => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'
            }[c]));
        }

        /* ================= ROOM SYSTEM ================= */
        let gameStarted = false;

        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            loop();
        }

        let currentRoom = "room1";

        let rooms = {};

        function loadRooms() {
            const path = `${DATABASE_BASE_PATH}/gameData/rooms`;

            onValue(ref(database, path), async (snap) => {

                // üî• Safe existence check
                if (!snap.exists()) {
                    console.log("No rooms found. Creating default room...");
                    await createDefaultRoom();
                    return;
                }

                const data = snap.val();
                rooms = data;

                if (!rooms[currentRoom]) {
                    currentRoom = Object.keys(rooms)[0];
                }

                if (rooms[currentRoom]?.bg) {
                    bgLoaded = false;
                    bgImage.src = rooms[currentRoom].bg;
                }

                startGame();
            });
        }

        async function createDefaultRoom() {

            const defaultRoom = {
                bg: "",
                walls: [],
                interactables: {
                    default_npc: {
                        id: "default_npc",
                        type: "npc",
                        x: 6,
                        y: 6,
                        solid: true,
                        draggable: true,
                        img: "",
                        dialogue: [
                            "Welcome to Knowledge RPG.",
                            "This room was auto-generated.",
                            "Start building your world!"
                        ]
                    }
                }
            };

            await update(
                ref(database, `${DATABASE_BASE_PATH}/gameData/rooms`),
                { room1: defaultRoom }
            );
        }

        /* ================= ROOM CHANGE ================= */

        function changeRoom(roomName) {

            if (!rooms[roomName]) return;

            currentRoom = roomName;

            if (rooms[currentRoom]?.bg) {
                bgLoaded = false;
                bgImage.src = rooms[currentRoom].bg;
            }

            renderInventory();
            renderHUD();

            persistPlayer();
        }

        function createRoom(roomId, returnRoom = null, doorImage = null) {

            const newRoom = {
                bg: "",
                walls: [],
                interactables: {}
            };

            if (returnRoom) {
                newRoom.interactables["return_door"] = {
                    id: "return_door",
                    type: "door",
                    x: 5,
                    y: 5,
                    solid: true,
                    draggable: true,
                    target: returnRoom,
                    img: doorImage || "./assets/img/door.png"
                };
            }

            return update(
                ref(database, `${DATABASE_BASE_PATH}/gameData/rooms`),
                { [roomId]: newRoom }
            );
        }

        function addBlockToRoom(roomId, blockData) {
            const id = safeKey(blockData.type + "_" + Date.now());

            set(
                ref(database,
                    `${DATABASE_BASE_PATH}/gameData/rooms/${roomId}/interactables/${id}`
                ),
                {
                    ...blockData,
                    id
                }
            );
        }

        function rectContains(obj, x, y) {
            const w = obj.w || obj.size || 1;
            const h = obj.h || obj.size || 1;

            return (
                x >= obj.x &&
                x < obj.x + w &&
                y >= obj.y &&
                y < obj.y + h
            );
        }

        /* ================= COLLISION ================= */

        function isSolidTile(x, y) {

            if (x < 0 || x >= GRID || y < 0 || y >= GRID) return true;

            const item = getItem(x, y);
            if (item && item.obj.solid !== false) return true;

            const room = rooms[currentRoom];
            if (!room) return true;

            // walls
            for (const wall of room.walls || []) {
                if (wall.x === x && wall.y === y) return true;
            }

            // interactables
            for (const obj of Object.values(room.interactables || {})) {
                if (obj.solid && rectContains(obj, x, y)) {
                    return true;
                }
            }

            return false;
        }

        /* ================= DRAW INTERACTABLES ================= */

        function drawInteractables() {

            const room = rooms[currentRoom];
            if (!room) return;

            const interactables = room.interactables || {};

            Object.values(interactables).forEach(obj => {

                const px = obj.x * TILE;
                const py = obj.y * TILE;

                const w = obj.w || 1;
                const h = obj.h || 1;

                const locked =
                    obj.levelRequirement &&
                    state.level < obj.levelRequirement;

                if (locked) ctx.globalAlpha = 0.5;

                // üîπ Use cached image (auto-fallback handled inside getCachedImage)
                const img = getCachedImage(obj.img);

                if (img && img.complete && img.naturalWidth > 0) {
                    ctx.drawImage(img, px, py, TILE * w, TILE * h);
                } else {
                    // fallback block
                    ctx.fillStyle = locked ? '#880000' : '#ff3cff';
                    ctx.fillRect(px + 4, py + 4, TILE * w - 8, TILE * h - 8);
                }

                if (locked) ctx.globalAlpha = 1;
            });
        }

        /* ================= INTERACTION ================= */

        function getInteractableInFront() {

            let { x, y } = state.player;

            if (state.player.dir === 'up') y--;
            if (state.player.dir === 'down') y++;
            if (state.player.dir === 'left') x--;
            if (state.player.dir === 'right') x++;

            return Object.values(rooms[currentRoom]?.interactables || {})
                .find(obj => rectContains(obj, x, y));
        }

        async function handleInteraction(obj) {
            if (obj.levelRequirement && state.level < obj.levelRequirement) {
                infoPanel.innerHTML = `
                    <div class="panel">
                        You must be level ${obj.levelRequirement} to access this.
                    </div>
                `;
                return;
            }

            // ================= SIMPLE ITEM PICKUP =================
            if (obj.item) {

                const item = obj.item;
                const roomInventory = getCurrentRoomItems();

                if (!roomInventory[item.sku]) {
                    roomInventory[item.sku] = [];
                }

                let spawnX = state.player.x;
                let spawnY = state.player.y;

                if (state.player.dir === 'up') spawnY--;
                if (state.player.dir === 'down') spawnY++;
                if (state.player.dir === 'left') spawnX--;
                if (state.player.dir === 'right') spawnX++;

                if (!isAreaFree(spawnX, spawnY, item.size || 1, item.size || 1)) {
                    spawnX = state.player.x;
                    spawnY = state.player.y;
                }

                roomInventory[item.sku].push({
                    x: spawnX,
                    y: spawnY,
                    name: item.name,
                    sku: item.sku,
                    img: item.img || '',
                    size: item.size || 1
                });

                await remove(
                    ref(database,
                        `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${obj.id}/item`
                    )
                );

                renderInventory();
                persistPlayer();

                infoPanel.innerHTML = `
                    <div class="panel">
                        üéÅ You obtained: <strong>${item.name}</strong>
                    </div>
                `;

                return;
            }

            if (!obj) return;

            // If object has dialogue
            if (obj.dialogue && obj.dialogue.length) {

                // If starting new interaction
                if (activeInteraction !== obj) {
                    activeInteraction = obj;
                    dialogueIndex = 0;
                }

                const text = obj.dialogue[dialogueIndex];

                infoPanel.innerHTML = `
                    <div class="panel">
                        ${text}
                        <div class="hint">(Press E to continue)</div>
                    </div>
                `;

                dialogueIndex++;

                // If dialogue finished
                if (dialogueIndex >= obj.dialogue.length) {

                    dialogueIndex = 0;
                    activeInteraction = null;

                    // AFTER dialogue, open element
                    if (obj.type === 'quiz') setMode('quiz');
                    if (obj.type === 'math') {
                        setMode('math');
                        startMathGame();
                    } if (obj.type === 'shop') setMode('shop');
                    if (obj.type === 'door') changeRoom(obj.target);
                    if (obj.type === 'app') {
                        if (!obj.appUrl) {
                            infoPanel.innerHTML = "No app URL defined.";
                            return;
                        }

                        const frame = document.getElementById('appFrame');
                        frame.src = obj.appUrl;

                        setMode('app');
                    }
                }

                return;
            }

            if (obj.type === 'quiz') setMode('quiz');

            if (obj.type === 'math') {
                setMode('math');
                startMathGame();
            };

            if (obj.type === 'shop') setMode('shop');

            if (obj.type === 'editor') {
                setMode('editor');

                roomEditor.open(
                    currentRoom,
                    rooms,
                    DATABASE_BASE_PATH
                );
            }

            if (obj.type === 'door') {

                if (!rooms[obj.target]) {
                    await createRoom(obj.target);
                }

                changeRoom(obj.target);
            }
        }

        /* ================= MODE ================= */

        function getCachedImage(url) {

            if (!url) return defaultSprite;

            if (itemImageCache.has(url)) {
                return itemImageCache.get(url);
            }

            const img = new Image();
            img.crossOrigin = "anonymous";

            img.onerror = () => {
                console.warn("Image failed, using default:", url);
                itemImageCache.set(url, defaultSprite);
            };

            img.src = url;

            itemImageCache.set(url, img);

            return img;
        }

        function setMode(mode) {
            document.querySelectorAll('.mode')
                .forEach(m => m.style.display = 'none');

            document.getElementById(mode).style.display = 'block';

            if (mode === 'room') {
                canvas.style.pointerEvents = 'auto';
                focusCanvas();
            } else {
                canvas.style.pointerEvents = 'none';
            }
        }

        setMode('room');
        focusCanvas();

        /* ================= HUD ================= */

        function renderHUD() {
            const coinsEl = document.getElementById('coins');
            const xpEl = document.getElementById('xp');
            const levelEl = document.getElementById('level');

            if (!coinsEl || !xpEl || !levelEl) return;

            coinsEl.textContent = (state.coins / 100).toFixed(2);
            xpEl.textContent = state.xp;
            levelEl.textContent = state.level;
        }

        function levelFromXP(xp) {
            if (xp < 100) return 1;
            if (xp < 300) return 2;
            if (xp < 600) return 3;
            if (xp < 1000) return 4;
            return 5;
        }

        function rewardCorrect(topic = '') {
            state.coins += 1000;
            state.xp += 5;
            state.level = levelFromXP(state.xp);
        }

        function punishWrong(topic = '') {
            state.coins = Math.max(0, state.coins - 200);
            state.level = levelFromXP(state.xp);
        }

        /* ================= FIREBASE PLAYER SAVE/LOAD ================= */

        function playerPath() {
            return `${DATABASE_BASE_PATH}/gameData/player`;
        }

        function progressPath() {
            return `${DATABASE_BASE_PATH}/gameData/progress`;
        }

        function loadPlayer() {
            onValue(ref(database, playerPath()), (snap) => {
                const data = snap.val();
                if (!data) {
                    renderHUD();
                    renderInventory();
                    return;
                }

                state.coins = Number(data.coins || 0);
                state.xp = Number(data.xp || 0);
                state.level = Number(data.level || 1);

                // restore room background safely
                if (rooms[currentRoom]?.bg) {
                    bgLoaded = false;
                    bgImage.src = rooms[currentRoom].bg;
                }

                // inventory restore
                state.roomItems = data.roomItems || {};

                renderHUD();
                renderInventory();
            });
        }

        function persistPlayer() {

            return set(ref(database, playerPath()), {
                coins: state.coins,
                xp: state.xp,
                level: state.level,
                room: currentRoom,
                roomItems: state.roomItems,
                player: state.player
            });
        }

        /* ================= SHOP LOAD ================= */

        function loadShop() {
            const path = `${DATABASE_BASE_PATH}/ledgerTx`;

            onValue(ref(database, path), (snap) => {
                const raw = snap.val() || {};
                const list = [];

                Object.values(raw).forEach(year => {
                    Object.values(year || {}).forEach(v => {
                        if (!v) return;
                        if (v.type !== 'expense') return;

                        const tags = Array.isArray(v.tags) ? v.tags : [];

                        const hasInv = tags.some(t => String(t).toLowerCase() === 'inv');
                        if (!hasInv) return;

                        const isXL = tags.some(t => String(t).toLowerCase() === 'xl');

                        list.push({
                            sku: v.sku || v.name,
                            name: v.name || v.sku || 'Item',
                            price: Math.abs(Number(v.amt || 0)),
                            img: v.img || '',
                            desc: v.desc || '',
                            cat: v.cat || '',
                            link: v.link || '',
                            size: isXL ? 2 : 1
                        });
                    });
                });

                const grouped = {};
                list.forEach(i => {
                    const k = safeKey(i.sku);
                    if (!grouped[k]) grouped[k] = i;
                });

                shopItems = Object.values(grouped);
                renderShop();
            });
        }

        // Buy adds the item at (0,0).
        function renderShop() {
            shopPanel.innerHTML = '';

            if (!shopItems.length) {
                shopPanel.innerHTML = '<div class="hint">No inventory items found.</div>';
                return;
            }

            shopItems.forEach(item => {
                const btn = document.createElement('button');
                btn.textContent = `Buy ${item.name} (${item.price})`;

                btn.onclick = () => {
                    if (state.coins < item.price) return alert('Not enough coins.');

                    state.coins -= Math.round(item.price * 100); const key = safeKey(item.sku);

                    const roomInventory = getCurrentRoomItems();

                    if (!roomInventory[key]) roomInventory[key] = [];

                    roomInventory[key].push({
                        x: 0,
                        y: 0,
                        name: item.name,
                        sku: item.sku,
                        price: item.price,
                        img: item.img || '',
                        desc: item.desc || '',
                        cat: item.cat || '',
                        link: item.link || '',
                        size: item.size || 1
                    });

                    renderHUD();
                    renderInventory();
                    persistPlayer();
                };

                shopPanel.appendChild(btn);
            });
        }

        /* ================= INVENTORY PANEL ================= */

        function renderInventory() {

            inventoryPanel.innerHTML = '<h3>Inventory</h3>';

            const roomInventory = getCurrentRoomItems();

            const entries = Object.entries(roomInventory).filter(([, v]) => Array.isArray(v));

            if (!entries.length) {
                inventoryPanel.innerHTML += '<div class="hint">No items yet in this room.</div>';
                return;
            }

            for (const [key, list] of entries) {
                const div = document.createElement('div');
                div.className = 'inventory-line';
                div.textContent = `${list[0]?.name || key} x ${list.length}`;
                inventoryPanel.appendChild(div);
            }
        }

        /* ================= ROOM ================= */

        function tile(e) {
            const rect = canvas.getBoundingClientRect();

            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;

            return {
                x: Math.floor(canvasX / TILE),
                y: Math.floor(canvasY / TILE)
            };
        }

        /* ================= DRAW ITEMS ================= */

        function drawItems() {

            const roomInventory = getCurrentRoomItems();

            for (const list of Object.values(roomInventory)) {

                if (!Array.isArray(list)) continue;

                list.forEach(obj => {

                    // Skip drawing if this item is currently being dragged
                    if (drag && drag.obj === obj) return;

                    const w = obj.w || obj.size || 1;
                    const h = obj.h || obj.size || 1;

                    const px = obj.x * TILE;
                    const py = obj.y * TILE;

                    // üîπ Use cached image (auto-fallback to default.png)
                    const img = getCachedImage(obj.img);

                    ctx.drawImage(
                        img,
                        px,
                        py,
                        TILE * w,
                        TILE * h
                    );
                });
            }

            /* ================= DRAG PREVIEW ================= */

            if (drag && hover) {

                const w = drag.obj.w || drag.obj.size || 1;
                const h = drag.obj.h || drag.obj.size || 1;

                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#ffffff';

                ctx.fillRect(
                    hover.x * TILE,
                    hover.y * TILE,
                    TILE * w,
                    TILE * h
                );

                ctx.globalAlpha = 1;
            }
        }

        function isAreaFree(x, y, w = 1, h = 1) {

            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {

                    const tx = x + dx;
                    const ty = y + dy;

                    if (tx < 0 || tx >= GRID || ty < 0 || ty >= GRID)
                        return false;

                    const existing = getItem(tx, ty);
                    if (existing && existing.obj.solid !== false)
                        return false;

                    const interactable = Object.values(
                        rooms[currentRoom]?.interactables || {}
                    ).find(o => rectContains(o, tx, ty));

                    if (interactable?.solid)
                        return false;
                }
            }

            return true;
        }

        function drawGrid() {
            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    ctx.fillStyle = (x + y) % 2 ? '#141a33' : '#18203b';
                    ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
                }
            }
        }

        function drawPlayer() {
            if (!spriteLoaded || playerSprite.naturalWidth === 0) {
                ctx.drawImage(
                    defaultSprite,
                    state.player.x * TILE,
                    state.player.y * TILE,
                    TILE,
                    TILE
                );
                return;
            }

            let row = 0;

            if (state.player.dir === 'down') row = 0;
            if (state.player.dir === 'left') row = 1;
            if (state.player.dir === 'right') row = 2;
            if (state.player.dir === 'up') row = 3;

            const sx = animationFrame * FRAME_WIDTH;
            const sy = row * FRAME_HEIGHT;

            ctx.drawImage(
                playerSprite,
                sx, sy,
                FRAME_WIDTH, FRAME_HEIGHT,
                state.player.x * TILE,
                state.player.y * TILE,
                TILE,
                TILE
            );
        }

        function draw() {
            ctx.clearRect(0, 0, 512, 512);

            if (bgImage.complete && bgImage.naturalWidth > 0) {
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            } else {
                drawGrid();
            }

            drawInteractables();
            drawItems();
            drawPlayer();
        }

        /* ================= INSPECT ================= */

        function getItem(x, y) {

            const roomInventory = getCurrentRoomItems();

            for (const [key, list] of Object.entries(roomInventory)) {

                if (!Array.isArray(list)) continue;

                for (const obj of list) {

                    const w = obj.w || obj.size || 1;
                    const h = obj.h || obj.size || 1;

                    for (let dy = 0; dy < h; dy++) {
                        for (let dx = 0; dx < w; dx++) {
                            if (obj.x + dx === x && obj.y + dy === y) {
                                return { key, obj };
                            }
                        }
                    }
                }
            }

            return null;
        }

        function getItemInFront() {
            let { x, y } = state.player;
            if (state.player.dir === 'up') y--;
            if (state.player.dir === 'down') y++;
            if (state.player.dir === 'left') x--;
            if (state.player.dir === 'right') x++;
            return getItem(x, y);
        }

        function inspectItem(item) {

            if (!item) {
                infoPanel.innerHTML = "Nothing here.";
                return;
            }

            const obj = item.obj;

            const imageHTML = obj.img
                ? `<img src="${obj.img}" 
                    style="
                        width:140px;
                        image-rendering:pixelated;
                        display:block;
                        margin-bottom:12px;
                        border:3px solid #d4af37;
                        box-shadow:0 0 10px rgba(212,175,55,.6);
                    ">`
                : '';

            const skuHTML = obj.sku
                ? `<div class="small">SKU: ${escapeHTML(obj.sku)}</div>`
                : '';

            const priceHTML = obj.price
                ? `<div class="small">Price: $${Number(obj.price).toFixed(2)}</div>`
                : '';

            const catHTML = obj.cat
                ? `<div class="small hint">Category: ${escapeHTML(obj.cat)}</div>`
                : '';

            const descHTML = obj.desc
                ? `<div class="hint" style="margin-top:10px;">${escapeHTML(obj.desc)}</div>`
                : '';

            const linkHTML = obj.link
                ? `<div style="margin-top:10px;">
                    <a href="${escapeHTML(obj.link)}" 
                        target="_blank" 
                        style="color:#d4af37;">
                        üîó View Product
                    </a>
                </div>`
                : '';

            infoPanel.innerHTML = `
                <div style="display:flex; gap:15px; align-items:flex-start;">
                    <div>${imageHTML}</div>

                    <div>
                        <div style="font-size:16px; margin-bottom:8px;">
                            <strong>${escapeHTML(obj.name || 'Item')}</strong>
                        </div>

                        ${skuHTML}
                        ${priceHTML}
                        ${catHTML}
                        ${descHTML}
                        ${linkHTML}
                    </div>
                </div>

                <div class="hint">Triple-click to delete ‚Ä¢ Drag to move</div>
            `;
        }
        /* ================= DRAG + DELETE ================= */

        canvas.onmousedown = (e) => {
            const { x, y } = tile(e);
            mouseDownPos = { x, y };

            const item = getItem(x, y);

            const now = Date.now();

            // If within 400ms ‚Üí count as multi-click
            if (now - lastClick < 400) {
                clickCount++;
            } else {
                clickCount = 1;
            }

            lastClick = now;

            // Triple click delete (items only)
            if (item && clickCount === 3) {

                const roomInventory = getCurrentRoomItems();
                const arr = roomInventory[item.key];
                const idx = arr.indexOf(item.obj);

                if (idx >= 0) {
                    arr.splice(idx, 1);
                }

                clickCount = 0;

                renderInventory();
                persistPlayer();
                infoPanel.innerHTML = "Item deleted.";

                return;
            }
        };

        canvas.onmousemove = (e) => {
            hover = tile(e);

            if (!mouseDownPos) return;

            // If mouse moved to different tile ‚Üí start drag
            if (hover.x !== mouseDownPos.x || hover.y !== mouseDownPos.y) {

                const interactable = Object.values(
                    rooms[currentRoom]?.interactables || {}
                ).find(o => rectContains(o, mouseDownPos.x, mouseDownPos.y));

                if (interactable && interactable.draggable) {
                    drag = { type: 'interactable', obj: interactable };
                    return;
                }

                const item = getItem(mouseDownPos.x, mouseDownPos.y);
                if (item) {
                    drag = item;
                }
            }
        };

        canvas.onmouseup = async (e) => {

            const { x, y } = tile(e);

            const now = Date.now();
            if (e.shiftKey)
                lastClickTime = now;

            /* ================= CLICK (no movement) ================= */
            if (mouseDownPos && mouseDownPos.x === x && mouseDownPos.y === y) {

                const interactable = Object.values(
                    rooms[currentRoom]?.interactables || {}
                ).find(o => rectContains(o, x, y));

                /* ---------- INTERACTABLE CLICK ---------- */
                if (interactable) {

                    // SHIFT + CLICK = EDIT MODE
                    if (e.shiftKey) {

                        selectedInteractable = interactable;

                        infoPanel.innerHTML = `
                            <div class="panel">
                                <strong>Editing:</strong> ${interactable.id}
                                <br><br>

                                <label class="fileBtn">
                                    Upload / Replace Image
                                    <input type="file" id="replaceBlockImageInput" style="display:none;">
                                </label>

                                <br><br>

                                <label>Dialogue (one line per row):</label><br>
                                <textarea id="dialogueInput" rows="5" style="width:100%;">${(interactable.dialogue || []).join("\n")}</textarea>
                                <button id="saveDialogueBtn">Save Dialogue</button>

                                <br><br>

                                <label>Required Level:</label>
                                <input type="number" id="levelReqInput" min="0"
                                    value="${interactable.levelRequirement || 0}">
                                <button id="saveLevelReqBtn">Save Level</button>

                                <br><br>

                                <label>
                                    <input type="checkbox" id="draggableInput"
                                        ${interactable.draggable !== false ? "checked" : ""}>
                                    Draggable
                                </label>

                                <br>

                                <button id="deleteBlockBtn">Delete Block</button>

                                <div class="hint">
                                    Shift+Click to edit ‚Ä¢ Drag to move
                                </div>
                            </div>
                        `;

                        document
                            .getElementById("replaceBlockImageInput")
                            ?.addEventListener("change", handleReplaceBlockImage);

                        document
                            .getElementById("deleteBlockBtn")
                            ?.addEventListener("click", async () => {

                                await remove(
                                    ref(database,
                                        `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${interactable.id}`
                                    )
                                );

                                selectedInteractable = null;
                                infoPanel.innerHTML = "Block deleted.";
                            });

                        document.getElementById("saveDialogueBtn")
                            ?.addEventListener("click", async () => {

                                const raw = document.getElementById("dialogueInput").value;

                                const dialogue = raw
                                    .split("\n")
                                    .map(line => line.trim())
                                    .filter(Boolean);

                                await update(
                                    ref(database,
                                        `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${interactable.id}`
                                    ),
                                    { dialogue }
                                );

                                interactable.dialogue = dialogue;
                                infoPanel.innerHTML = "Dialogue updated.";
                            });

                        document.getElementById("saveLevelReqBtn")
                            ?.addEventListener("click", async () => {

                                const level = parseInt(
                                    document.getElementById("levelReqInput").value
                                ) || 0;

                                await update(
                                    ref(database,
                                        `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${interactable.id}`
                                    ),
                                    { levelRequirement: level }
                                );

                                interactable.levelRequirement = level;
                                infoPanel.innerHTML = "Level requirement updated.";
                            });

                        document.getElementById("draggableInput")
                            ?.addEventListener("change", async (e) => {

                                const draggable = e.target.checked;

                                await update(
                                    ref(database,
                                        `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${interactable.id}`
                                    ),
                                    { draggable }
                                );

                                interactable.draggable = draggable;

                            });

                    } else {
                        handleInteraction(interactable);
                    }

                    drag = null;
                    mouseDownPos = null;
                    return;
                }

                /* ---------- ITEM CLICK ---------- */
                const item = getItem(x, y);

                if (item) {
                    inspectItem(item);
                } else {
                    infoPanel.innerHTML = "Nothing here.";
                    selectedInteractable = null;
                }

                drag = null;
                mouseDownPos = null;
                return;
            }

            /* ================= DRAG ================= */

            if (!drag || !hover) {
                drag = null;
                mouseDownPos = null;
                return;
            }

            /* ---------- DRAG INTERACTABLE ---------- */
            if (drag.type === 'interactable') {

                const w = drag.obj.w || 1;
                const h = drag.obj.h || 1;

                if (isAreaFree(hover.x, hover.y, w, h)) {

                    drag.obj.x = hover.x;
                    drag.obj.y = hover.y;

                    await update(
                        ref(database,
                            `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${drag.obj.id}`
                        ),
                        {
                            x: hover.x,
                            y: hover.y
                        }
                    );
                }

                drag = null;
                mouseDownPos = null;
                return;
            }

            /* ---------- DRAG INVENTORY ITEM ---------- */

            const w = drag.obj.w || drag.obj.size || 1;
            const h = drag.obj.h || drag.obj.size || 1;

            if (isAreaFree(hover.x, hover.y, w, h)) {

                drag.obj.x = hover.x;
                drag.obj.y = hover.y;

                persistPlayer();
            }

            drag = null;
            mouseDownPos = null;
        };

        /* ================= PLAYER MOVEMENT (pokemon-ish step rate) ================= */

        const keys = {};
        let lastStepAt = 0;
        const STEP_MS = 140;

        function updatePlayer() {

            const now = performance.now();
            if (now - lastStepAt < STEP_MS) return;

            let newX = state.player.x;
            let newY = state.player.y;
            let moved = false;

            if (keys['arrowup'] || keys['w']) {
                newY--;
                state.player.dir = 'up';
                moved = true;
            } else if (keys['arrowdown'] || keys['s']) {
                newY++;
                state.player.dir = 'down';
                moved = true;
            } else if (keys['arrowleft'] || keys['a']) {
                newX--;
                state.player.dir = 'left';
                moved = true;
            } else if (keys['arrowright'] || keys['d']) {
                newX++;
                state.player.dir = 'right';
                moved = true;
            }

            if (!moved) {
                animationFrame = 1;
                return;
            }

            if (newX < 0 || newX >= GRID || newY < 0 || newY >= GRID) {
                lastStepAt = now;
                return;
            }

            if (!isSolidTile(newX, newY)) {
                state.player.x = newX;
                state.player.y = newY;
                persistPlayer();
            }

            // Animate if moving
            const now2 = performance.now();
            if (now2 - lastFrameTime > FRAME_SPEED) {
                animationFrame = (animationFrame + 1) % FRAMES_PER_ROW;
                lastFrameTime = now2;
            }

            lastStepAt = now;
        }

        function loop() {
            updatePlayer();
            draw();
            requestAnimationFrame(loop);
        }

        /* ================= AUTH ================= */

        const quiz = createQuizModule({
            database,
            ref,
            onValue,
            set,
            remove,
            state,
            rewardCorrect,
            punishWrong,
            renderHUD,
            persistPlayer,
            basePathGetter: () => DATABASE_BASE_PATH
        });

        onAuthStateChanged(auth, (user) => {
            DATABASE_BASE_PATH = user ? user.uid : 'public';
            const authHintEl = document.getElementById('authHint');
            if (authHintEl) {
                authHintEl.textContent = user
                    ? `Logged in: ${user.email || user.uid}`
                    : 'Guest mode (public)';
            }

            loadPlayer();
            loadRooms();
            loadShop();

            quiz.loadQuizProgress();
            quiz.populateQuizIndex();
        });

        async function handleBackgroundUpload(e) {

            const file = e.target.files[0];
            if (!file) return;

            const ROOT_PATH = auth.currentUser?.uid || "public";
            const cleanName = file.name.replace(/\s+/g, '_').toLowerCase();

            const path =
                `${ROOT_PATH}/gameData/roomAssets/${currentRoom}/bg_${Date.now()}_${cleanName}`;

            const fileRef = storageRef(storage, path);

            await uploadBytes(fileRef, file);
            const url = await getDownloadURL(fileRef);

            await update(
                ref(database, `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}`),
                { bg: url }
            );

            bgLoaded = false;
            bgImage.src = url;
        }

        function handleKeyDown(e) {

            const k = e.key.toLowerCase();
            keys[k] = true;

            if (e.key === 'Escape') {
                setMode('room');
                focusCanvas();
                return;
            }

            if (k === 'e') {
                const obj = getInteractableInFront();
                if (obj) {
                    handleInteraction(obj);
                    return;
                }

                const item = getItemInFront();
                inspectItem(item);
            }
        }

        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        async function handleBlockUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const uid = auth.currentUser?.uid || "public";
            const cleanName = file.name.replace(/\s+/g, '_').toLowerCase();

            const path =
                `${uid}/gameData/blockAssets/${Date.now()}_${cleanName}`;

            const fileRef = storageRef(storage, path);
            await uploadBytes(fileRef, file);
            const url = await getDownloadURL(fileRef);

            const type = document.getElementById("blockTypeSelect").value;

            const shape = document.getElementById("blockShapeSelect").value;
            const [w, h] = shape.split("x").map(n => parseInt(n));

            const baseBlock = {
                type,
                x: Math.min(GRID - 1, state.player.x + 1),
                y: state.player.y,
                w,
                h,
                solid: true,
                draggable: true,
                img: url
            };

            if (type === "app") {
                const appUrl = document.getElementById("appUrlInput").value.trim();
                if (!appUrl) return alert("Enter an app URL first.");

                baseBlock.appUrl = appUrl;
                baseBlock.dialogue = [
                    "This portal connects to an external system.",
                    "Press E again to open it."
                ];
            }
            addBlockToRoom(currentRoom, baseBlock);
        }

        async function handleReplaceBlockImage(e) {

            if (!selectedInteractable) return;

            const file = e.target.files[0];
            if (!file) return;

            const uid = auth.currentUser?.uid || "public";

            const path =
                `${uid}/gameData/blockAssets/${selectedInteractable.id}.png`;

            const fileRef = storageRef(storage, path);

            await uploadBytes(fileRef, file);

            const url = await getDownloadURL(fileRef);

            await update(
                ref(database,
                    `${DATABASE_BASE_PATH}/gameData/rooms/${currentRoom}/interactables/${selectedInteractable.id}`
                ),
                { img: url }
            );

            selectedInteractable.img = url;

            infoPanel.innerHTML = `
                <div class="panel">
                    Image replaced successfully.
                </div>
            `;

            selectedInteractable = null;
        }

        function initEventListeners() {

            const closeButtons = {
                closeQuizBtn: () => setMode('room'),
                closeShopBtn: () => setMode('room'),
                closeMathBtn: () => setMode('room'),
                closeAppBtn: () => {
                    const frame = document.getElementById('appFrame');
                    if (frame) frame.src = '';
                    setMode('room');
                },
                closeEditorBtn: () => setMode('room')
            };

            Object.entries(closeButtons).forEach(([id, handler]) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener('click', () => {
                    handler();
                    focusCanvas();
                });
            });

            // üî• Editor Save
            document.getElementById('saveEditorBtn')
                ?.addEventListener('click', async () => {
                    if (!roomEditor) return;
                    await roomEditor.save();
                    setMode('room');
                    focusCanvas();
                });

            // MATH
            document.getElementById('mathSubmitBtn')
                ?.addEventListener('click', submitMathAnswer);

            document.getElementById('mathResetBtn')
                ?.addEventListener('click', resetMathGame);

            document.getElementById('mathAnswerInput')
                ?.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') submitMathAnswer();
                });

            // UPLOADS
            document.getElementById('bgUpload')
                ?.addEventListener('change', handleBackgroundUpload);

            document.getElementById('blockImageUpload')
                ?.addEventListener('change', handleBlockUpload);

            // GLOBAL KEYS
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
        }

        renderHUD();
        renderInventory();
        initEventListeners();

    </script>
</body>

</html>