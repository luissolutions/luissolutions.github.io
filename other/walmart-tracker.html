<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Walmart Security Technology – Project Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Auth / login -->
  <script type="module" src="../apps/assets/js/login.js" defer></script>

  <style>
    :root {
      color-scheme: dark;
      --bg: #050711;
      --bg-elevated: #0d111c;
      --border-subtle: #202637;
      --accent: #2f81f7;
      --accent-soft: rgba(47, 129, 247, 0.12);
      --text: #e4e8f0;
      --text-muted: #8d96a8;
      --danger: #ff6b81;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111629 0, #050711 55%, #010208 100%);
      color: var(--text);
      min-height: 100vh;
    }

    .app-shell {
      display: grid;
      grid-template-columns: 270px minmax(0, 1fr);
      gap: 12px;
      padding: 12px;
    }

    @media (max-width: 900px) {
      .app-shell {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--bg-elevated);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      box-shadow: 0 26px 80px rgba(0, 0, 0, 0.55);
      padding: 12px 14px;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: calc(100vh - 24px);
      overflow: hidden;
    }

    .sidebar-header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
      letter-spacing: 0.03em;
    }

    .subtitle {
      font-size: 13px;
      color: var(--text-muted);
    }

    .project-row {
      display: flex;
      gap: 6px;
      margin-top: 4px;
    }

    .project-row input {
      flex: 1 1 auto;
      font-size: 14px;
      padding: 4px 6px;
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      background: #050814;
      color: var(--text);
    }

    .project-row button {
      font-size: 13px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      background: #050814;
      color: var(--text);
      cursor: pointer;
      white-space: nowrap;
    }

    .project-row button:hover {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .current-project-tag {
      margin-top: 4px;
      font-size: 13px;
      color: var(--text-muted);
    }

    .current-project-tag code {
      background: #050814;
      padding: 1px 5px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      color: var(--text);
    }

    .progress-row {
      margin-top: 8px;
      font-size: 13px;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }

    .progress-bar-track {
      position: relative;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: #050814;
      border: 1px solid var(--border-subtle);
      overflow: hidden;
    }

    .progress-bar-fill {
      position: absolute;
      inset: 0;
      width: 0;
      background: linear-gradient(90deg, #2f81f7, #59b5ff);
      transition: width 0.25s ease-out;
    }

    .pill-list {
      margin-top: 10px;
      overflow: auto;
      padding-right: 2px;
    }

    .section-pill {
      width: 100%;
      padding: 6px 8px;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      background: #050814;
      color: var(--text);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      margin-bottom: 4px;
      cursor: pointer;
      text-align: left;
    }

    .section-pill .label {
      flex: 1 1 auto;
    }

    .section-pill .pill-progress {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--text-muted);
    }

    .pill-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
    }

    .pill-dot.done {
      background: #3fb950;
      border-color: #3fb950;
    }

    .section-pill.active {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .main {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: calc(100vh - 24px);
    }

    .main-header {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #sectionTitle {
      font-size: 17px;
      font-weight: 600;
    }

    #sectionMeta {
      font-size: 13px;
      color: var(--text-muted);
    }

    .section-progress-wrapper {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .section-progress-label {
      white-space: nowrap;
    }

    .task-list {
      margin: 10px 0 8px;
      padding: 0;
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .task-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 8px;
      border: 1px solid transparent;
      background: #050814;
    }

    .task-item.done {
      border-color: rgba(63, 185, 80, 0.45);
      background: rgba(4, 18, 8, 0.9);
    }

    .task-checkbox {
      margin-top: 3px;
    }

    .task-label {
      display: flex;
      flex-direction: column;
      gap: 1px;
      font-size: 14px;
    }

    .task-label .id {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .task-label .text {
      font-size: 14px;
    }

    .notes-block label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .section-tag {
      font-size: 13px;
      color: var(--text-muted);
    }

    #sectionNotes {
      width: 100%;
      min-height: 70px;
      resize: vertical;
      padding: 6px 7px;
      font-size: 14px;
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      background: #050814;
      color: var(--text);
    }

    .notes-block small {
      font-size: 13px;
      color: var(--text-muted);
      display: block;
      margin-top: 3px;
    }

    .detail-tab {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: #050814;
      color: var(--text);
      font-size: 14px;
      padding: 4px 10px;
      cursor: pointer;
    }

    .detail-tab.active {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .detail-panel {
      font-size: 15px;
      margin-top: 4px;
    }

    .detail-panel.hidden {
      display: none;
    }

    .detail-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .detail-table th,
    .detail-table td {
      border: 1px solid #2a323d;
      padding: 4px 6px;
      text-align: left;
    }

    .detail-table th {
      background: #10141f;
      font-weight: 500;
    }

    .detail-table button {
      font-size: 13px;
      padding: 3px 6px;
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      background: #050814;
      color: var(--text);
      cursor: pointer;
    }

    .detail-table button:hover {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .hidden {
      display: none;
    }

    .thumb-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .thumb-wrapper {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .thumb-img {
      width: 40px;
      height: 40px;
      object-fit: cover;
      border-radius: 4px;
      border: 1px solid #2a323d;
      cursor: pointer;
    }

    .thumb-delete {
      position: absolute;
      top: -6px;
      right: -6px;
      font-size: 11px;
      border-radius: 999px;
      border: 1px solid #ff6b81;
      background: #1a0609;
      color: #ffb3bf;
      cursor: pointer;
      padding: 0 4px;
      line-height: 14px;
    }

    .thumb-note {
      width: 110px;
      max-width: 130px;
      font-size: 12px;
      padding: 2px 3px;
      border-radius: 4px;
      border: 1px solid #2a323d;
      background: #050814;
      color: var(--text);
      resize: vertical;
    }

    .thumb-note[readonly] {
      opacity: 0.6;
      cursor: default;
    }

    header {
      overflow: auto;
      height: 60px;
    }
  </style>
</head>

<body>

  <header>
    <div>
      <section id="login-section">
        <form id="login-form">
          <label for="username" style="width: auto;">Email:</label>
          <input type="email" id="username" required>
          <br>
          <label for="password">Password:</label>
          <input type="password" id="password" required>
          <br>
          <button type="submit">Login</button>
        </form>
        <button id="logout" style="display: none;">Logout</button>
      </section>
    </div>
    <div class="current-project-tag">
      Data owner path: <code id="currentBasePathLabel">public</code>
    </div>

  </header>

  <div class="app-shell">
    <!-- SIDEBAR -->
    <aside class="sidebar card">
      <div class="sidebar-header">
        <h1>Security Tech – Site Tracker</h1>
        <div class="subtitle">
          Track Walmart CCTV & Alarm scope, alarm points, and cameras for this job.
        </div>

        <div class="project-row">
          <input id="projectNameInput" placeholder="Project (e.g. WM1234 – City)">
          <button id="setProjectBtn" type="button">Set</button>
        </div>
        <button id="clearProjectBtn" type="button">Clear</button>
        <div class="current-project-tag">
          Current project: <code id="currentProjectLabel">(none)</code>
        </div>

        <div class="progress-row">
          <span>Overall scope complete</span>
          <span id="overallPercent">0%</span>
        </div>
        <div class="progress-bar-track">
          <div class="progress-bar-fill" id="overallBar"></div>
        </div>
      </div>

      <div class="pill-list" id="sectionList"></div>
    </aside>

    <!-- MAIN CONTENT -->
    <main class="main card">
      <div class="main-header">
        <div id="sectionTitle">Select a section</div>
        <div id="sectionMeta"></div>

        <div class="section-progress-wrapper" id="sectionProgressWrapper" style="display:none;">
          <span class="section-progress-label" id="sectionCountLabel"></span>
          <div class="progress-bar-track" style="flex:1;">
            <div class="progress-bar-fill" id="sectionBar"></div>
          </div>
        </div>
      </div>

      <ul class="task-list" id="taskList"></ul>

      <div class="notes-block" id="notesBlock" style="display:none;">
        <label for="sectionNotes">
          Section notes
          <span class="section-tag">
            Scope ref: <code id="sectionScopeCode"></code>
          </span>
        </label>
        <textarea id="sectionNotes"
          placeholder="Add site-specific details, deviations from prints, AHJ notes, or anything you want to remember for this section..."></textarea>
        <small>Notes are saved automatically to Firebase for the current project.</small>
      </div>

      <hr style="border-color:#232a37;opacity:.6;margin:10px 0;">

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px;">
        <button type="button" class="detail-tab" data-panel="alarm">Alarm Points</button>
        <button type="button" class="detail-tab" data-panel="cameras">Cameras</button>
      </div>

      <div style="font-size:11px;margin:4px 0 6px;color:#9aa3b5;display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="enableImageEditCheckbox">
        <span>Enable editing of image notes (admin only)</span>
      </div>

      <!-- Alarm points panel -->
      <div id="alarmPanel" class="detail-panel hidden">
        <div style="font-size:13px;margin-bottom:6px;color:#9aa3b5;">
          Track each alarm point: number, name, completed, and optional photos with notes.
        </div>

        <form id="alarmForm" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;">
          <input type="number" id="alarmPointNumber" placeholder="Point #" min="0"
            style="flex:0 0 90px;padding:4px 6px;">
          <input type="text" id="alarmPointName" placeholder="Point name / description"
            style="flex:1 1 180px;padding:4px 6px;">
          <button type="submit">Add / Update</button>
        </form>

        <table class="detail-table" id="alarmTable">
          <thead>
            <tr>
              <th>Point #</th>
              <th>Name</th>
              <th>Done</th>
              <th>Image(s)</th>
              <th>Actions</th> <!-- NEW -->
            </tr>
          </thead>
          <tbody></tbody>
        </table>

      </div>

      <!-- Cameras panel -->
      <div id="cameraPanel" class="detail-panel hidden">
        <div style="font-size:13px;margin-bottom:6px;color:#9aa3b5;">
          Track each camera: ID, name/location, completion, and photos with notes.
        </div>

        <form id="cameraForm" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;">
          <input type="text" id="cameraId" placeholder="Camera ID (CAM-01, REG-05, etc.)"
            style="flex:0 0 150px;padding:4px 6px;">
          <input type="text" id="cameraName" placeholder="Camera name / location"
            style="flex:1 1 180px;padding:4px 6px;">
          <button type="submit">Add / Update</button>
        </form>

        <table class="detail-table" id="cameraTable">
          <thead>
            <tr>
              <th>Camera ID</th>
              <th>Name</th>
              <th>Done</th>
              <th>Image(s)</th>
              <th>Actions</th> <!-- NEW -->
            </tr>
          </thead>
          <tbody></tbody>
        </table>

      </div>

      <!-- hidden file input for both alarm + camera uploads -->
      <input type="file" id="imageUploadInput" accept="image/*" class="hidden">
    </main>
  </div>

  <script type="module">
    // -------- Firebase imports --------
    import {
      auth,
      onAuthStateChanged,
      database,
      storage,
      ref,
      set,
      update,
      get,
      storageRef,
      uploadBytes,
      getDownloadURL,
      deleteObject
    } from '../assets/js/firebase-init.js';

    // -------- Dynamic base path --------
    let DATABASE_BASE_PATH = 'public';
    const LAST_PROJECT_STORAGE_KEY = "walmartProjectTracker:lastProject";

    // NEW: localStorage key for section order
    const SECTION_ORDER_STORAGE_KEY = "walmartProjectTracker:sectionOrder";

    function getProjectBasePath() {
      return `${DATABASE_BASE_PATH}/walmartProjectTracker/projects`;
    }

    // -------- Scope-driven sections --------
    const SECTIONS = [
      {
        id: "ap_front_end",
        title: "AP / Front-End",
        scopeRef: "Punch – AP / Front-End",
        tasks: [
          { id: "ap_overview_adjust", text: "AP overview – camera off; adjust manager view" },
          { id: "ap_subject_overview_rename", text: "AP subject overview – rename appropriately" },
          { id: "ap_360_check", text: "Check all 360 cameras – none are pulling up in AP office" },
          { id: "front_pvm_adjust", text: "Front PVM – adjust downward" },
          { id: "beer_pvm_ream", text: "Re-aim beer PVM" }
        ]
      },
      {
        id: "entrances_exits_exterior",
        title: "Entrances / Exits / Exterior",
        scopeRef: "Punch – Entrances / Exits / Exterior",
        tasks: [
          { id: "ent_grc01_down", text: "Entrance GRC 01 – aim down slightly" },
          { id: "ent_gm_merch_01_04_remove", text: "Entrance GM merchandise 01–04 – remove" },
          { id: "ent_gm02_corridor_mode", text: "Entrance GM 02 – fix corridor mode" },
          { id: "exit_gdc01_square", text: "Exit GDC 01 – square up" },
          { id: "exit_grc01_raise", text: "Exit GRC 01 – raise slightly" },
          { id: "exit_grc02_adjust", text: "Exit GRC 02 – adjust as needed" },
          { id: "exit_gdc_square", text: "Exit GDC – square up" },
          { id: "exit_parking_01_missing", text: "Exit parking lot 01 – missing" },
          { id: "parking_05_missing", text: "Parking lot 05 – missing" },
          { id: "exit_rear_verify", text: "Exit rear of building 01 – verify placement" }
        ]
      },
      {
        id: "sales_floor_departments",
        title: "Sales Floor / Departments",
        scopeRef: "Punch – Sales Floor / Departments",
        tasks: [
          { id: "sal_baby_formula_remove_old", text: "Sal baby formula – remove old camera" },
          { id: "code_adam_front_adjust", text: "Code Adam front – shot blocked; adjust" },
          { id: "sal_jewelry_overview_rename", text: "Sal jewelry overview – rename jewelry" },
          { id: "sal_pork_action_alley_ream", text: "Sal pork Action Alley – re-aim" }
        ]
      },
      {
        id: "pos_punch",
        title: "POS",
        scopeRef: "Punch – POS",
        tasks: [
          { id: "pos_13_remove", text: "POS 13 – remove" },
          { id: "pos_14_remove", text: "POS 14 – remove" },
          { id: "pos_23_not_present", text: "POS 23 – not present" },
          { id: "pos_52_remove", text: "POS 52 – remove" },
          { id: "pos_59_60_remove", text: "POS 59–60 – remove" },
          { id: "pos_66_67_remove", text: "POS 66–67 – remove" },
          { id: "pos_73_74_remove", text: "POS 73–74 – remove" },
          { id: "pos_78_79_remove", text: "POS 78–79 – remove" },
          { id: "pos_80_pharmacy_square", text: "POS 80 (Pharmacy) – square up" },
          { id: "pos_79_turn", text: "POS 79 – turn slightly" },
          { id: "pos_81_square", text: "POS 81 – square up" },
          { id: "pos_83_lower", text: "POS 83 – lower (too close to ceiling)" }
        ]
      },
      {
        id: "pharmacy_rx",
        title: "Pharmacy (Rx)",
        scopeRef: "Punch – Pharmacy (Rx)",
        tasks: [
          { id: "rx_fill_01_square", text: "Rx fill station 01 – square up" },
          { id: "rx_fill_05_rename", text: "Rx fill station 05 – rename correctly" },
          { id: "rx_fill_05_incorrect_cam", text: "Rx fill station 05 – incorrect camera; fix" },
          { id: "rx_will_call_troubleshoot", text: "Rx will-call bag – not picking anything up; troubleshoot" }
        ]
      },
      {
        id: "stockroom_pickup",
        title: "Stockroom / Pickup",
        scopeRef: "Punch – Stockroom / Pickup",
        tasks: [
          { id: "stock_aisle_down", text: "Stock aisle – camera off; move field of view down" },
          { id: "stock_pickup_overview_ream", text: "Stock pickup overview – re-aim" }
        ]
      },
      {
        id: "pre_admin",
        title: "Pre-Job & Admin",
        scopeRef: "Ch.1–2",
        tasks: [
          { id: "1.05", text: "Confirm Supplier Master Agreement is in place before work begins." },
          { id: "portal", text: "Verify access to Walmart Web Portal, ST Technical Document Center, and Security Technology Projects site." },
          { id: "docs_pkg", text: "Download and have onsite: device location drawings, wiring details, cable assignment sheet, and BOM for this project." },
          { id: "licenses", text: "Confirm all required state/local licenses & permits are valid and available for review (AHJ & Security Manager)." },
          { id: "training", text: "Verify all onsite personnel have OSHA-10 and onsite supervisor has OSHA-30; carry cards onsite." },
          { id: "manager_rep", text: "Assign a project representative (manager) as the single point of contact with Security Manager & project team." },
          { id: "auth_list", text: "After pre-possession meeting: send Authorized Employee List + licenses + OSHA cards to GC, Store Planner, and Security Manager; upload to Portal." }
        ]
      },
      {
        id: "timeline_updates",
        title: "Timeline & Weekly Updates",
        scopeRef: "3.09–3.14, 5.07–5.11",
        tasks: [
          { id: "timeline_form", text: "Within 5 days of project start, complete Walmart Project Timeline/Gantt form and send to Security Manager + upload to Portal." },
          { id: "substantial_completion", text: "Plan work so substantial completion is 14 days before GO, with AHJ inspections completed 7 days before GO." },
          { id: "weekly_update", text: "Send weekly update email (one per project) to Security Manager and upload to Portal by Thursday 5 PM." },
          { id: "issues_flag", text: "Immediately communicate any issues that could impact progress or completion date in the weekly update." },
          { id: "50pct_pay", text: "Ensure weekly update form is complete and accurate if requesting 50% progress payment at ~60% install completion." }
        ]
      },
      {
        id: "safety_coord",
        title: "Safety, Badging & Coordination",
        scopeRef: "3.00–3.08, 2.06–2.21",
        tasks: [
          { id: "safety_meeting_gc", text: "Meet with GC to review Walmart/site-specific safety requirements before starting work; follow GC safety program." },
          { id: "ppe_spotters", text: "Provide spotters for lifts and ensure all personnel wear required PPE (vest, hard hat, etc.) at all times." },
          { id: "badges", text: "Ensure all techs wear company photo ID and project badge visibly on outer garment while onsite." },
          { id: "daily_meeting", text: "Attend daily morning GC/store planning meetings or check-in call when offsite." },
          { id: "no_wm_equip", text: "Do not use Walmart ladders, lifts, shopping carts, or other store property for installation work." },
          { id: "clean_work", text: "Keep work areas clean and free of debris; clean each workspace and lift/container area daily." },
          { id: "damage_repair", text: "Document and repair any damage caused by installation (walls, paint, ceilings, etc.) as required." }
        ]
      },
      {
        id: "demo_remodel",
        title: "Remodel / Demo Tasks",
        scopeRef: "3.21–3.28",
        tasks: [
          { id: "pre_inspection_cctv", text: "Perform pre-inspection of existing CCTV/alarm system (photos + quick test) before starting work; upload to Portal within 7 days." },
          { id: "demo_scope", text: "Plan demolition of unused system components per drawings; remove unused cameras, racks, and head-end gear." },
          { id: "ceiling_tiles", text: "Be prepared to replace ceiling tiles in pharmacy, service desk, front registers for drop ceiling stores as required." },
          { id: "exterior_cam_paint", text: "If building exterior is painted, clean and readjust exterior cameras as needed." },
          { id: "used_assets", text: "Box or palletize unused equipment and complete ST Used Assets Return Manifest for claims associate." }
        ]
      },
      {
        id: "cabling",
        title: "Cabling & Conduit",
        scopeRef: "3.29–3.68",
        tasks: [
          { id: "supports", text: "Install cable with proper supports (bridle rings/J-hooks/grid wire) and maintain required clearances from roof deck and ceilings." },
          { id: "no_shared_pathways", text: "Keep fire, data, CCTV and other systems in separate conduits/trays/supports; no shared pathways." },
          { id: "conduit_rules", text: "Provide low-voltage conduits where needed, deburred with bushings; seal cooler/freezer/exterior conduits with proper rated sealant." },
          { id: "service_loops", text: "Provide 20 ft service loops for UTP at device, neat 6\" coil; limit alarm device loops to 1 ft max." },
          { id: "cable_length", text: "Keep UTP runs ≤ 90 m (permanent link) and ≤ 100 m including patch cords; keep alarm circuits within 80% of rated length/load." },
          { id: "wire_sizes", text: "Use Cat5e or better for CCTV and 18 AWG minimum for alarm; avoid T-taps on alarm circuits." },
          { id: "labeling", text: "Label both ends of each cable with machine-printed, self-laminating labels (e.g., CCTV-01-GM, device/loop IDs for alarm)." },
          { id: "head_end_dressing", text: "Route all head-end cabling through wire management or conduit, Velcro for UTP, neatly dressed and protected from damage." }
        ]
      },
      {
        id: "cctv_install",
        title: "CCTV Install & Missed Scan",
        scopeRef: "6.00–6.22",
        tasks: [
          { id: "pre_screenshots", text: "Take screenshots of all existing cameras before work; upload PDF to Portal within 7 days." },
          { id: "master_cable_sheet", text: "Maintain Master Cable Assignment Sheet with switch/port/device/IP/MAC and keep updated in DVRPC C:\\data folder." },
          { id: "patch_panels", text: "Terminate all camera UTP to patch panels and use yellow patch cords to switches; no direct-to-switch terminations." },
          { id: "wacher_ports", text: "Coordinate port programming with Wachter NOC via email; plan to minimize number of contacts." },
          { id: "exterior_height", text: "Mount exterior fixed cameras so lens is 12.5 ft AFF; follow conduit and sealing requirements for exterior boxes." },
          { id: "vestibule_rules", text: "Mount vestibule cameras at 6 ft AFF (unless approved otherwise), with ½\" EMT to accessible space and distances from glass (18\" side, 24\" top)." },
          { id: "ptz_mounting", text: "Mount PTZs at bottom of bar joist height with appropriate Unistrut/pendant hardware and verify FOV and control." },
          { id: "missed_scan", text: "Install Missed Scan cameras centered on POS glass, mounted to stable structure, and submit IP map + FOV screenshots (4 per page) within 5 days of final register layout." }
        ]
      },
      {
        id: "pvm_vms",
        title: "PVMs, VMS & DVRPC",
        scopeRef: "6.23–6.32",
        tasks: [
          { id: "pvm_pendant", text: "Install pendant PVMs with secure attachment to bar joists and correct power/decoder connections." },
          { id: "pvm_wall", text: "Install wall PVMs with mounts and HDMI/decoder connections per drawings." },
          { id: "pvm_height", text: "Ensure lowest point of all monitors is 8 ft AFF (10 ft for Sam’s Clubs)." },
          { id: "vms_program", text: "Program cameras into Verint (or March, if applicable) per CSV/cable assignment sheet and Walmart VMS guides." },
          { id: "dvrpc_install", text: "Install DVRPC in AP or UPC office in week 1, run full install script before power-down, and connect all monitors/printers properly." }
        ]
      },
      {
        id: "cctv_closeout",
        title: "CCTV Close-Out & Training",
        scopeRef: "6.33–6.43",
        tasks: [
          { id: "verify_all_cams", text: "Verify every camera is online, properly named, focused, and recording before final punch with Security Manager." },
          { id: "fov_docs", text: "Capture and save FOV screenshots for each camera in required PDF layout (including POS and Missed Scan maps)." },
          { id: "rack_photos", text: "Take photos of front and back of each IDF/TC rack showing neat cabling and labeling." },
          { id: "service_binder", text: "Build and leave CCTV Service Binder in AP office with manuals, redline as-builts, Master Cable Assignment, and checklists." },
          { id: "48hr_test", text: "Run a minimum 48-hour endurance test on the CCTV system and correct any issues before final acceptance." },
          { id: "cctv_training", text: "Provide CCTV operator training for onsite staff (up to 2 sessions, 2 hrs each, normal business hours)." }
        ]
      },
      {
        id: "alarm_install",
        title: "Alarm Install & Testing",
        scopeRef: "7.00–7.16, 7.22–7.23",
        tasks: [
          { id: "alarm_precheck", text: "Perform visual and functional pre-inspection of alarm system (RTUs, faults, supervisory signals) and report non-operable points within 5 days." },
          { id: "on_test", text: "Always place alarm system on test via VRT/management/Alarm Central before work begins and notify store management." },
          { id: "off_test", text: "Remove system from test before leaving each day; verify normal status on keypads and notification circuits." },
          { id: "no_strapping", text: "Do not strap out points to force normal; have Alarm Central D-pop points that will remain abnormal, track all ticket numbers." },
          { id: "fire_backboard", text: "Install or extend fire alarm backboard (fire-rated, painted) and gutters per proto layouts and scope for this store type." },
          { id: "battery_test", text: "Perform stand-alone battery test as part of final 48-hour alarm system test." }
        ]
      },
      {
        id: "alarm_closeout",
        title: "Alarm Close-Out & Docs",
        scopeRef: "7.18–7.29",
        tasks: [
          { id: "as_builts_alarm", text: "Create separate fire and intrusion as-builts with wiring paths, splices, devices, and all deviations from prints." },
          { id: "ahj_docs", text: "Obtain and file closed permits, AHJ sign-off documents, and any required state/jurisdiction tags or certifications." },
          { id: "test_signals", text: "Send and document test signals from Alarm Central showing each point tested; ensure no missing or grouped points." },
          { id: "zone_maps", text: "Install framed alarm zone map at main keypad/annunciator, updated to match as-builts and code; remove intrusion maps if present." },
          { id: "alarm_binder", text: "Place binder in panel document enclosure with all alarm close-out docs, stamped prints, as-builts, manuals, and checklists." },
          { id: "alarm_training", text: "Provide alarm system training to store management per Walmart alarm training guide, with at least two sessions if needed." }
        ]
      },
      {
        id: "logistics_equipment",
        title: "Logistics, Equipment & RMA",
        scopeRef: "Ch.4",
        tasks: [
          { id: "inventory_delivery", text: "Inventory all received equipment against POD, BOM, and prints within 48 hours; upload POD and inventory to Portal within 5 days." },
          { id: "storage", text: "Provide secure storage (no Walmart interior storage) and protect all equipment from weather/theft; confirm pallet count vs container size." },
          { id: "excess_equipment", text: "Review excess equipment with Security Manager and arrange returns via STAR or vendor RMA as required." },
          { id: "loss_reporting", text: "Report any equipment loss/damage to Security Manager; understand replacement costs may be deducted from payment." },
          { id: "container_removal", text: "Ensure storage containers and equipment are removed from site at least one week prior to grand opening." }
        ]
      }
    ];

    // -------- STATE --------
    let state = {
      currentProjectName: "",
      currentProjectKey: "",
      projects: {} // { [projectKey]: { name, tasks, notes, alarmPoints, cameras } }
    };

    // NEW: section order (list of section IDs)
    let sectionOrder = loadSectionOrderFromLocalStorage();

    // DOM refs
    const sectionListEl = document.getElementById("sectionList");
    const overallPercentEl = document.getElementById("overallPercent");
    const overallBarEl = document.getElementById("overallBar");
    const currentProjectLabelEl = document.getElementById("currentProjectLabel");
    const currentBasePathLabelEl = document.getElementById("currentBasePathLabel");
    const sectionTitleEl = document.getElementById("sectionTitle");
    const sectionMetaEl = document.getElementById("sectionMeta");
    const sectionCountLabelEl = document.getElementById("sectionCountLabel");
    const sectionBarEl = document.getElementById("sectionBar");
    const sectionProgressWrapperEl = document.getElementById("sectionProgressWrapper");
    const taskListEl = document.getElementById("taskList");
    const notesBlockEl = document.getElementById("notesBlock");
    const sectionNotesEl = document.getElementById("sectionNotes");
    const sectionScopeCodeEl = document.getElementById("sectionScopeCode");

    const alarmPanelEl = document.getElementById("alarmPanel");
    const cameraPanelEl = document.getElementById("cameraPanel");
    const alarmTableBodyEl = document.querySelector("#alarmTable tbody");
    const cameraTableBodyEl = document.querySelector("#cameraTable tbody");
    const alarmFormEl = document.getElementById("alarmForm");
    const alarmPointNumberEl = document.getElementById("alarmPointNumber");
    const alarmPointNameEl = document.getElementById("alarmPointName");
    const cameraFormEl = document.getElementById("cameraForm");
    const cameraIdEl = document.getElementById("cameraId");
    const cameraNameEl = document.getElementById("cameraName");
    const imageUploadInputEl = document.getElementById("imageUploadInput");
    const detailTabButtons = document.querySelectorAll(".detail-tab");

    const setProjectBtn = document.getElementById("setProjectBtn");
    const clearProjectBtn = document.getElementById("clearProjectBtn");
    const projectNameInput = document.getElementById("projectNameInput");

    const enableImageEditCheckbox = document.getElementById("enableImageEditCheckbox");

    let activeSectionId = null;
    let saveTimeout = null;
    let pendingUploadTarget = null; // { kind: 'alarm' | 'camera', key: string }
    let editingUnlocked = false;
    let draggedSectionId = null; // NEW: for drag & drop

    function sanitizeProjectKey(name) {
      return name
        .trim()
        .toLowerCase()
        .replace(/[.#$/\[\]]/g, "_")
        .replace(/\s+/g, "_");
    }

    // Safe task key for Firebase (handles "1.05" etc.)
    function makeTaskKey(sectionId, taskId) {
      return `${sectionId}:${String(taskId)}`.replace(/[.#$/\[\]]/g, "_");
    }

    // NEW: helper to get a section by its id
    function getSectionById(id) {
      return SECTIONS.find(s => s.id === id) || null;
    }

    // NEW: load section order from localStorage
    function loadSectionOrderFromLocalStorage() {
      try {
        const raw = localStorage.getItem(SECTION_ORDER_STORAGE_KEY);
        const defaultOrder = SECTIONS.map(s => s.id);
        if (!raw) return defaultOrder;

        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return defaultOrder;

        // Only keep IDs that still exist
        const valid = parsed.filter(id => getSectionById(id));
        // Add any new sections that weren't in stored order
        const missing = SECTIONS.map(s => s.id).filter(id => !valid.includes(id));
        return [...valid, ...missing];
      } catch (e) {
        console.warn("Could not load section order from localStorage:", e);
        return SECTIONS.map(s => s.id);
      }
    }

    // NEW: save section order to localStorage
    function saveSectionOrderToLocalStorage() {
      try {
        localStorage.setItem(SECTION_ORDER_STORAGE_KEY, JSON.stringify(sectionOrder));
      } catch (e) {
        console.warn("Could not save section order to localStorage:", e);
      }
    }

    function getCurrentProjectObj() {
      if (!state.currentProjectKey) return null;
      if (!state.projects[state.currentProjectKey]) {
        state.projects[state.currentProjectKey] = {
          name: state.currentProjectName,
          tasks: {},
          notes: {},
          alarmPoints: {},
          cameras: {}
        };
      } else {
        const proj = state.projects[state.currentProjectKey];
        proj.tasks = proj.tasks || {};
        proj.notes = proj.notes || {};
        proj.alarmPoints = proj.alarmPoints || {};
        proj.cameras = proj.cameras || {};
      }
      return state.projects[state.currentProjectKey];
    }

    async function loadProjectFromFirebase(projectKey, displayName) {
      const projectRef = ref(database, `${getProjectBasePath()}/${projectKey}`);
      const snap = await get(projectRef);
      if (snap.exists()) {
        const data = snap.val();
        state.projects[projectKey] = {
          name: data.name || displayName,
          tasks: data.tasks || {},
          notes: data.notes || {},
          alarmPoints: data.alarmPoints || {},
          cameras: data.cameras || {}
        };
      } else {
        const newData = {
          name: displayName,
          tasks: {},
          notes: {},
          alarmPoints: {},
          cameras: {}
        };
        await set(projectRef, newData);
        state.projects[projectKey] = newData;
      }
    }

    async function saveProjectToFirebase() {
      if (!state.currentProjectKey) return;
      const proj = getCurrentProjectObj();
      if (!proj) return;
      const projectRef = ref(database, `${getProjectBasePath()}/${state.currentProjectKey}`);
      await update(projectRef, {
        name: state.currentProjectName,
        tasks: proj.tasks || {},
        notes: proj.notes || {},
        alarmPoints: proj.alarmPoints || {},
        cameras: proj.cameras || {}
      });
    }

    function scheduleSave() {
      if (!state.currentProjectKey) return;
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveTimeout = null;
        saveProjectToFirebase().catch(console.error);
      }, 400);
    }

    function computeOverallProgress() {
      const proj = getCurrentProjectObj();
      if (!proj) return { done: 0, total: 0, percent: 0 };
      let total = 0;
      let done = 0;
      SECTIONS.forEach(sec => {
        sec.tasks.forEach(t => {
          total++;
          const key = makeTaskKey(sec.id, t.id);
          if (proj.tasks[key]) done++;
        });
      });
      return {
        done,
        total,
        percent: total === 0 ? 0 : Math.round((done / total) * 100)
      };
    }

    function computeSectionProgress(sectionId) {
      const proj = getCurrentProjectObj();
      if (!proj) return { done: 0, total: 0, percent: 0 };
      const section = getSectionById(sectionId);
      if (!section) return { done: 0, total: 0, percent: 0 };

      const total = section.tasks.length;
      const done = section.tasks.filter(t => {
        const key = makeTaskKey(section.id, t.id);
        return proj.tasks[key];
      }).length;

      return {
        done,
        total,
        percent: total === 0 ? 0 : Math.round((done / total) * 100)
      };
    }

    function renderSidebar() {
      sectionListEl.innerHTML = "";
      const overall = computeOverallProgress();
      overallPercentEl.textContent = overall.percent + "%";
      overallBarEl.style.width = overall.percent + "%";
      currentProjectLabelEl.textContent = state.currentProjectName || "(none)";
      if (currentBasePathLabelEl) {
        currentBasePathLabelEl.textContent = DATABASE_BASE_PATH;
      }

      // Make sure activeSectionId is valid
      if (!activeSectionId || !getSectionById(activeSectionId)) {
        activeSectionId = sectionOrder[0] || (SECTIONS[0] && SECTIONS[0].id);
      }

      sectionOrder.forEach(secId => {
        const sec = getSectionById(secId);
        if (!sec) return;

        const secProgress = computeSectionProgress(sec.id);
        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "section-pill" + (sec.id === activeSectionId ? " active" : "");
        pill.dataset.sectionId = sec.id;
        pill.draggable = true; // NEW: make draggable

        const labelSpan = document.createElement("span");
        labelSpan.className = "label";
        labelSpan.textContent = sec.title;

        const rightSpan = document.createElement("span");
        rightSpan.className = "pill-progress";

        const dot = document.createElement("span");
        dot.className = "pill-dot" + (secProgress.done === secProgress.total && secProgress.total > 0 ? " done" : "");

        const count = document.createElement("span");
        count.textContent = secProgress.total ? `${secProgress.done}/${secProgress.total}` : "-";

        rightSpan.appendChild(dot);
        rightSpan.appendChild(count);

        pill.appendChild(labelSpan);
        pill.appendChild(rightSpan);

        // Click to select section
        pill.addEventListener("click", () => {
          activeSectionId = sec.id;
          renderSidebar();
          renderSection(sec.id);
        });

        // Drag & drop events
        pill.addEventListener("dragstart", (e) => {
          draggedSectionId = sec.id;
          e.dataTransfer.effectAllowed = "move";
        });

        pill.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
        });

        pill.addEventListener("drop", (e) => {
          e.preventDefault();
          if (!draggedSectionId || draggedSectionId === sec.id) return;

          const fromIndex = sectionOrder.indexOf(draggedSectionId);
          const toIndex = sectionOrder.indexOf(sec.id);
          if (fromIndex === -1 || toIndex === -1) return;

          sectionOrder.splice(fromIndex, 1);
          sectionOrder.splice(toIndex, 0, draggedSectionId);

          saveSectionOrderToLocalStorage();
          draggedSectionId = null;

          renderSidebar();
          renderSection(activeSectionId);
        });

        sectionListEl.appendChild(pill);
      });
    }

    function renderSection(sectionId) {
      const section = getSectionById(sectionId);
      if (!section) {
        sectionTitleEl.textContent = "Select a section";
        sectionMetaEl.textContent = "";
        taskListEl.innerHTML = "";
        sectionProgressWrapperEl.style.display = "none";
        notesBlockEl.style.display = "none";
        return;
      }

      sectionTitleEl.textContent = section.title;
      sectionMetaEl.textContent = "Scope reference: " + section.scopeRef;

      const secProgress = computeSectionProgress(sectionId);
      sectionProgressWrapperEl.style.display = "flex";
      sectionCountLabelEl.textContent = `${secProgress.done} / ${secProgress.total} done`;
      sectionBarEl.style.width = secProgress.percent + "%";

      taskListEl.innerHTML = "";
      const project = getCurrentProjectObj();

      section.tasks.forEach(task => {
        const li = document.createElement("li");
        const key = makeTaskKey(section.id, task.id);
        const done = project && project.tasks[key];

        li.className = "task-item" + (done ? " done" : "");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "task-checkbox";
        checkbox.checked = !!done;

        checkbox.addEventListener("change", () => {
          if (!state.currentProjectKey) {
            alert("Set a project name first so checks can be saved to Firebase.");
            checkbox.checked = false;
            return;
          }
          const proj = getCurrentProjectObj();
          if (checkbox.checked) {
            proj.tasks[key] = true;
          } else {
            delete proj.tasks[key];
          }
          scheduleSave();
          renderSidebar();
          renderSection(sectionId);
        });

        const labelDiv = document.createElement("div");
        labelDiv.className = "task-label";

        const idSpan = document.createElement("span");
        idSpan.className = "id";
        idSpan.textContent = task.id;

        const textSpan = document.createElement("span");
        textSpan.className = "text";
        textSpan.textContent = task.text;

        labelDiv.appendChild(idSpan);
        labelDiv.appendChild(textSpan);

        li.appendChild(checkbox);
        li.appendChild(labelDiv);

        taskListEl.appendChild(li);
      });

      const proj = getCurrentProjectObj();
      notesBlockEl.style.display = proj ? "block" : "none";
      sectionScopeCodeEl.textContent = section.scopeRef;
      sectionNotesEl.value = proj ? (proj.notes[section.id] || "") : "";
    }

    function renderAlarmPanel() {
      const proj = getCurrentProjectObj();
      alarmTableBodyEl.innerHTML = "";
      if (!proj) return;

      const entries = Object.entries(proj.alarmPoints || {}).sort(
        ([a], [b]) => Number(a) - Number(b)
      );

      entries.forEach(([pointNum, info]) => {
        const tr = document.createElement("tr");

        const tdNum = document.createElement("td");
        tdNum.textContent = pointNum;

        const tdName = document.createElement("td");
        tdName.textContent = info.name || "";

        const tdDone = document.createElement("td");
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = !!info.done;
        chk.addEventListener("change", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.alarmPoints[pointNum]) projNow.alarmPoints[pointNum] = {};
          projNow.alarmPoints[pointNum].name = info.name;
          projNow.alarmPoints[pointNum].done = chk.checked;
          scheduleSave();
          renderAlarmPanel();
        });
        tdDone.appendChild(chk);

        const tdImg = document.createElement("td");

        // Add Image button (always available)
        const addBtn = document.createElement("button");
        addBtn.textContent = "Add Image";
        addBtn.addEventListener("click", () => {
          if (!state.currentProjectKey) {
            alert("Set a project first.");
            return;
          }
          pendingUploadTarget = { kind: "alarm", key: pointNum };
          imageUploadInputEl.value = "";
          imageUploadInputEl.click();
        });
        tdImg.appendChild(addBtn);

        // Normalize images to array (legacy support)
        const images = Array.isArray(info.images)
          ? info.images
          : info.imageUrl
            ? [{
              url: info.imageUrl,
              path: info.imagePath || null,
              note: info.imageNote || ""
            }]
            : [];

        if (images.length) {
          const strip = document.createElement("div");
          strip.className = "thumb-strip";

          images.forEach((img, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "thumb-wrapper";

            const thumb = document.createElement("img");
            thumb.className = "thumb-img";
            thumb.src = img.url;
            thumb.alt = `Alarm ${pointNum} image ${index + 1}`;
            thumb.title = "Click to open full image";
            thumb.addEventListener("click", () => {
              window.open(img.url, "_blank");
            });

            const delBtn = document.createElement("button");
            delBtn.className = "thumb-delete";
            delBtn.textContent = "×";
            delBtn.title = "Delete this image";
            delBtn.addEventListener("click", async () => {
              if (!editingUnlocked) {
                alert("Enable admin editing to delete images.");
                return;
              }
              if (!confirm("Delete this image for this alarm point?")) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.alarmPoints[pointNum]) projNow.alarmPoints[pointNum] = {};
              const target = projNow.alarmPoints[pointNum];

              if (!Array.isArray(target.images)) {
                target.images = [];
                if (target.imageUrl) {
                  target.images.push({
                    url: target.imageUrl,
                    path: target.imagePath || null,
                    note: target.imageNote || ""
                  });
                }
              }

              const [removed] = target.images.splice(index, 1);

              // Clear legacy single-image fields
              target.imageUrl = null;
              target.imagePath = null;
              target.imageNote = null;

              scheduleSave();
              renderAlarmPanel();

              if (removed && removed.path) {
                try {
                  await deleteObject(storageRef(storage, removed.path));
                } catch (e) {
                  console.warn("Storage delete failed (maybe already removed):", e);
                }
              }
            });

            const note = document.createElement("textarea");
            note.className = "thumb-note";
            note.rows = 2;
            note.placeholder = "Notes for this image…";
            note.value = img.note || "";
            note.readOnly = !editingUnlocked;
            note.addEventListener("input", () => {
              if (!editingUnlocked) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.alarmPoints[pointNum]) projNow.alarmPoints[pointNum] = {};
              const target = projNow.alarmPoints[pointNum];

              if (!Array.isArray(target.images)) {
                target.images = [];
                if (target.imageUrl) {
                  target.images.push({
                    url: target.imageUrl,
                    path: target.imagePath || null,
                    note: target.imageNote || ""
                  });
                }
              }

              if (!target.images[index]) {
                target.images[index] = {
                  url: img.url,
                  path: img.path || null,
                  note: ""
                };
              }

              target.images[index].note = note.value;
              scheduleSave();
            });

            wrapper.appendChild(thumb);
            wrapper.appendChild(delBtn);
            wrapper.appendChild(note);
            strip.appendChild(wrapper);
          });

          tdImg.appendChild(strip);
        }

        // --- NEW: Actions cell (Delete point) ---
        const tdActions = document.createElement("td");
        const deletePointBtn = document.createElement("button");
        deletePointBtn.textContent = "Delete";
        deletePointBtn.title = "Delete this alarm point and all its images";

        deletePointBtn.addEventListener("click", async () => {
          if (!editingUnlocked) {
            alert("Enable admin editing to delete alarm points.");
            return;
          }

          if (!confirm(`Delete alarm point ${pointNum} and all associated images?`)) return;

          const projNow = getCurrentProjectObj();
          if (!projNow || !projNow.alarmPoints || !projNow.alarmPoints[pointNum]) {
            return;
          }

          const entry = projNow.alarmPoints[pointNum];

          // Collect all storage paths (array + legacy single image)
          const pathsToDelete = [];
          if (Array.isArray(entry.images)) {
            entry.images.forEach(img => {
              if (img && img.path) pathsToDelete.push(img.path);
            });
          }
          if (entry.imagePath) {
            pathsToDelete.push(entry.imagePath);
          }

          // Remove from database state
          delete projNow.alarmPoints[pointNum];
          scheduleSave();
          renderAlarmPanel();

          // Try to delete from Storage (non-blocking for UI)
          for (const p of pathsToDelete) {
            try {
              await deleteObject(storageRef(storage, p));
            } catch (e) {
              console.warn("Failed to delete alarm image from storage:", p, e);
            }
          }
        });

        tdActions.appendChild(deletePointBtn);

        tr.appendChild(tdNum);
        tr.appendChild(tdName);
        tr.appendChild(tdDone);
        tr.appendChild(tdImg);
        tr.appendChild(tdActions);

        alarmTableBodyEl.appendChild(tr);
      });
    }

    function renderCameraPanel() {
      const proj = getCurrentProjectObj();
      cameraTableBodyEl.innerHTML = "";
      if (!proj) return;

      const entries = Object.entries(proj.cameras || {}).sort(([a], [b]) =>
        a.localeCompare(b, undefined, { numeric: true })
      );

      entries.forEach(([camId, info]) => {
        const tr = document.createElement("tr");

        // --- Camera ID ---
        const tdId = document.createElement("td");
        tdId.textContent = camId;

        // --- Name / location ---
        const tdName = document.createElement("td");
        tdName.textContent = info.name || "";

        // --- Done checkbox ---
        const tdDone = document.createElement("td");
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = !!info.done;
        chk.addEventListener("change", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
          projNow.cameras[camId].name = info.name;
          projNow.cameras[camId].done = chk.checked;
          scheduleSave();
          renderCameraPanel();
        });
        tdDone.appendChild(chk);

        // --- Image(s) + Add Image button ---
        const tdImg = document.createElement("td");

        const addBtn = document.createElement("button");
        addBtn.textContent = "Add Image";
        addBtn.addEventListener("click", () => {
          if (!state.currentProjectKey) {
            alert("Set a project first.");
            return;
          }
          pendingUploadTarget = { kind: "camera", key: camId };
          imageUploadInputEl.value = "";
          imageUploadInputEl.click();
        });
        tdImg.appendChild(addBtn);

        // Normalize images to array (backward compatible)
        const images = Array.isArray(info.images)
          ? info.images
          : info.imageUrl
            ? [{
              url: info.imageUrl,
              path: info.imagePath || null,
              note: info.imageNote || ""
            }]
            : [];

        if (images.length) {
          const strip = document.createElement("div");
          strip.className = "thumb-strip";

          images.forEach((img, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "thumb-wrapper";

            const thumb = document.createElement("img");
            thumb.className = "thumb-img";
            thumb.src = img.url;
            thumb.alt = `Camera ${camId} image ${index + 1}`;
            thumb.title = "Click to open full image";
            thumb.addEventListener("click", () => {
              window.open(img.url, "_blank");
            });

            const delBtn = document.createElement("button");
            delBtn.className = "thumb-delete";
            delBtn.textContent = "×";
            delBtn.title = "Delete this image";
            delBtn.addEventListener("click", async () => {
              if (!editingUnlocked) {
                alert("Enable admin editing to delete images.");
                return;
              }
              if (!confirm("Delete this image for this camera?")) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
              const target = projNow.cameras[camId];

              if (!Array.isArray(target.images)) {
                target.images = [];
                if (target.imageUrl) {
                  target.images.push({
                    url: target.imageUrl,
                    path: target.imagePath || null,
                    note: target.imageNote || ""
                  });
                }
              }

              const [removed] = target.images.splice(index, 1);

              // Clear legacy single-image fields
              target.imageUrl = null;
              target.imagePath = null;
              target.imageNote = null;

              scheduleSave();
              renderCameraPanel();

              if (removed && removed.path) {
                try {
                  await deleteObject(storageRef(storage, removed.path));
                } catch (e) {
                  console.warn("Storage delete failed (maybe already removed):", e);
                }
              }
            });

            const note = document.createElement("textarea");
            note.className = "thumb-note";
            note.rows = 2;
            note.placeholder = "Notes for this image…";
            note.value = img.note || "";
            note.readOnly = !editingUnlocked;
            note.addEventListener("input", () => {
              if (!editingUnlocked) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
              const target = projNow.cameras[camId];

              if (!Array.isArray(target.images)) {
                target.images = [];
                if (target.imageUrl) {
                  target.images.push({
                    url: target.imageUrl,
                    path: target.imagePath || null,
                    note: target.imageNote || ""
                  });
                }
              }

              if (!target.images[index]) {
                target.images[index] = {
                  url: img.url,
                  path: img.path || null,
                  note: ""
                };
              }

              target.images[index].note = note.value;
              scheduleSave();
            });

            wrapper.appendChild(thumb);
            wrapper.appendChild(delBtn);
            wrapper.appendChild(note);
            strip.appendChild(wrapper);
          });

          tdImg.appendChild(strip);
        }

        // --- NEW: Actions column – delete camera record ---
        const tdActions = document.createElement("td");
        const deleteCamBtn = document.createElement("button");
        deleteCamBtn.textContent = "Delete";
        deleteCamBtn.title = "Delete this camera and all its images";

        deleteCamBtn.addEventListener("click", async () => {
          if (!editingUnlocked) {
            alert("Enable admin editing to delete cameras.");
            return;
          }

          if (!confirm(`Delete camera ${camId} and all associated images?`)) return;

          const projNow = getCurrentProjectObj();
          if (!projNow || !projNow.cameras || !projNow.cameras[camId]) {
            return;
          }

          const entry = projNow.cameras[camId];

          // Collect all storage paths (array + legacy single image)
          const pathsToDelete = [];
          if (Array.isArray(entry.images)) {
            entry.images.forEach(img => {
              if (img && img.path) pathsToDelete.push(img.path);
            });
          }
          if (entry.imagePath) {
            pathsToDelete.push(entry.imagePath);
          }

          // Remove camera from DB state
          delete projNow.cameras[camId];
          scheduleSave();
          renderCameraPanel();

          // Fire-and-forget delete in Storage
          for (const p of pathsToDelete) {
            try {
              await deleteObject(storageRef(storage, p));
            } catch (e) {
              console.warn("Failed to delete camera image from storage:", p, e);
            }
          }
        });

        tdActions.appendChild(deleteCamBtn);

        // Append all tds
        tr.appendChild(tdId);
        tr.appendChild(tdName);
        tr.appendChild(tdDone);
        tr.appendChild(tdImg);
        tr.appendChild(tdActions);

        cameraTableBodyEl.appendChild(tr);
      });
    }

    // localStorage helpers for last project
    function saveLastProjectToLocalStorage() {
      if (!state.currentProjectKey || !state.currentProjectName) return;
      const payload = {
        key: state.currentProjectKey,
        name: state.currentProjectName,
        basePath: DATABASE_BASE_PATH
      };
      try {
        localStorage.setItem(LAST_PROJECT_STORAGE_KEY, JSON.stringify(payload));
      } catch (e) {
        console.warn("Could not save last project to localStorage:", e);
      }
    }

    async function restoreLastProjectForCurrentBasePath() {
      let raw;
      try {
        raw = localStorage.getItem(LAST_PROJECT_STORAGE_KEY);
      } catch (e) {
        console.warn("Could not read last project from localStorage:", e);
        return;
      }
      if (!raw) return;

      let parsed;
      try {
        parsed = JSON.parse(raw);
      } catch {
        return;
      }

      if (!parsed.key || !parsed.name) return;
      if (parsed.basePath && parsed.basePath !== DATABASE_BASE_PATH) return;

      state.currentProjectKey = parsed.key;
      state.currentProjectName = parsed.name;
      projectNameInput.value = parsed.name;

      try {
        await loadProjectFromFirebase(parsed.key, parsed.name);
        renderSidebar();
        if (!activeSectionId && sectionOrder.length) {
          activeSectionId = sectionOrder[0];
        }
        renderSection(activeSectionId);
        renderAlarmPanel();
        renderCameraPanel();
      } catch (err) {
        console.error("Error restoring last project from Firebase:", err);
      }
    }

    // Image resize helper (HEIC-aware-ish, always JPG)
    function resizeImageToJpeg(file, maxWidth = 2048, quality = 0.9) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          const img = new Image();

          img.onload = () => {
            let w = img.width;
            let h = img.height;

            if (w > maxWidth) {
              const scale = maxWidth / w;
              w = maxWidth;
              h = Math.round(h * scale);
            }

            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, w, h);

            canvas.toBlob(
              (blob) => {
                if (!blob) {
                  reject(new Error("Canvas toBlob() returned null"));
                  return;
                }
                resolve(blob);
              },
              "image/jpeg",
              quality
            );
          };

          img.onerror = () => {
            reject(
              new Error(
                "Browser couldn't decode this file (HEIC may not be supported in this browser)."
              )
            );
          };

          img.src = reader.result;
        };

        reader.onerror = () => {
          reject(reader.error || new Error("FileReader failed while reading image."));
        };

        reader.readAsDataURL(file);
      });
    }

    // Discover all "owner" roots that contain walmartProjectTracker data
    async function fetchAvailableBasePaths() {
      try {
        const rootRef = ref(database);
        const snap = await get(rootRef);
        if (!snap.exists()) return [];

        const data = snap.val();
        const paths = [];

        Object.keys(data).forEach((key) => {
          const node = data[key];
          if (node && typeof node === "object" && node.walmartProjectTracker) {
            paths.push(key);
          }
        });

        // Sort just to keep the prompt readable
        paths.sort();
        return paths;
      } catch (err) {
        console.error("Error fetching available base paths:", err);
        return [];
      }
    }

    // Switch DATABASE_BASE_PATH and reload project data for that owner
    async function switchDatabaseBasePath(newBase) {
      if (!newBase) return;

      DATABASE_BASE_PATH = newBase;
      console.log("[admin] switched DATABASE_BASE_PATH to", DATABASE_BASE_PATH);

      // Reset in-memory cache so we don't mix owners
      state.projects = {};

      // Try to reload current project (if any) from the new base path
      if (state.currentProjectKey && state.currentProjectName) {
        try {
          await loadProjectFromFirebase(state.currentProjectKey, state.currentProjectName);
        } catch (err) {
          console.error("Error loading project for new base path:", err);
        }
      } else {
        await restoreLastProjectForCurrentBasePath();
      }

      renderSidebar();
      renderSection(activeSectionId);
      renderAlarmPanel();
      renderCameraPanel();
    }

    // Tab switching
    detailTabButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        detailTabButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const panel = btn.dataset.panel;
        alarmPanelEl.classList.add("hidden");
        cameraPanelEl.classList.add("hidden");
        if (panel === "alarm") alarmPanelEl.classList.remove("hidden");
        if (panel === "cameras") cameraPanelEl.classList.remove("hidden");
      });
    });

    // Set project
    setProjectBtn.addEventListener("click", async () => {
      const name = projectNameInput.value.trim();
      if (!name) {
        alert("Enter a project name or store ID (e.g. WM1234 – City).");
        return;
      }
      const key = sanitizeProjectKey(name);
      state.currentProjectName = name;
      state.currentProjectKey = key;

      try {
        await loadProjectFromFirebase(key, name);
      } catch (err) {
        console.error("Error loading project from Firebase", err);
        alert("Could not load project from Firebase. Check console/logs.");
        return;
      }

      saveLastProjectToLocalStorage();

      renderSidebar();
      if (!activeSectionId && sectionOrder.length) {
        activeSectionId = sectionOrder[0];
      }
      renderSection(activeSectionId);
      renderAlarmPanel();
      renderCameraPanel();
    });

    // Clear checklist (keep notes + images)
    clearProjectBtn.addEventListener("click", () => {
      if (!state.currentProjectKey) {
        alert("No project selected.");
        return;
      }
      if (!confirm("Clear all scope checklist checkmarks for the current project? Notes, alarm points, and cameras will be kept.")) return;
      const proj = getCurrentProjectObj();
      proj.tasks = {};
      scheduleSave();
      renderSidebar();
      renderSection(activeSectionId);
    });

    // Section notes
    sectionNotesEl.addEventListener("input", () => {
      const proj = getCurrentProjectObj();
      if (!proj || !activeSectionId) return;
      proj.notes[activeSectionId] = sectionNotesEl.value;
      scheduleSave();
    });

    // Alarm form
    alarmFormEl.addEventListener("submit", e => {
      e.preventDefault();
      const proj = getCurrentProjectObj();
      if (!proj) {
        alert("Set a project first.");
        return;
      }
      const num = alarmPointNumberEl.value.trim();
      const name = alarmPointNameEl.value.trim();
      if (!num || !name) {
        alert("Point # and name are required.");
        return;
      }
      if (!proj.alarmPoints[num]) proj.alarmPoints[num] = {};
      proj.alarmPoints[num].name = name;
      proj.alarmPoints[num].done = proj.alarmPoints[num].done || false;
      scheduleSave();
      alarmPointNumberEl.value = "";
      alarmPointNameEl.value = "";
      renderAlarmPanel();
    });

    // Camera form
    cameraFormEl.addEventListener("submit", e => {
      e.preventDefault();
      const proj = getCurrentProjectObj();
      if (!proj) {
        alert("Set a project first.");
        return;
      }
      const id = cameraIdEl.value.trim();
      const name = cameraNameEl.value.trim();
      if (!id || !name) {
        alert("Camera ID and name are required.");
        return;
      }
      if (!proj.cameras[id]) proj.cameras[id] = {};
      proj.cameras[id].name = name;
      proj.cameras[id].done = proj.cameras[id].done || false;
      scheduleSave();
      cameraIdEl.value = "";
      cameraNameEl.value = "";
      renderCameraPanel();
    });

    enableImageEditCheckbox.addEventListener("change", async () => {
      if (enableImageEditCheckbox.checked) {
        const pwd = prompt("Enter admin password to enable editing and select data owner:");
        if (pwd === "telaidadmin") {
          editingUnlocked = true;

          // Fetch available base paths dynamically from Firebase
          let options = await fetchAvailableBasePaths();

          // Fallback if none found (e.g. no data yet or permissions limited)
          if (!options || !options.length) {
            options = [DATABASE_BASE_PATH, "public", "share"];
          }

          const optionsText = options
            .map((opt, idx) => `${idx + 1}) ${opt}`)
            .join("\n");

          const selection = prompt(
            "Select data owner to load job info from:\n" +
            optionsText +
            "\n\nEnter the number (or leave blank to keep current path).",
            ""
          );

          const idx = selection ? parseInt(selection, 10) : NaN;
          if (!isNaN(idx) && idx >= 1 && idx <= options.length) {
            const chosenBase = options[idx - 1];
            await switchDatabaseBasePath(chosenBase);
          } else if (selection) {
            alert("Invalid selection. Keeping current data owner path.");
          }

          renderAlarmPanel();
          renderCameraPanel();
        } else {
          editingUnlocked = false;
          enableImageEditCheckbox.checked = false;
          alert("Incorrect password. Image note editing remains locked.");
        }
      } else {
        // Turn admin mode off – just lock editing; path stays as-is until auth listener runs
        editingUnlocked = false;
        renderAlarmPanel();
        renderCameraPanel();
      }
    });

    // Upload alarm/camera image, with resize + JPG conversion and note support
    imageUploadInputEl.addEventListener("change", async () => {
      const file = imageUploadInputEl.files[0];
      if (!file || !pendingUploadTarget || !state.currentProjectKey) return;

      const projKey = state.currentProjectKey;
      const { kind, key } = pendingUploadTarget;
      pendingUploadTarget = null;

      try {
        console.log("[upload] start", { projKey, kind, key, fileName: file.name, basePath: DATABASE_BASE_PATH });

        const resizedBlob = await resizeImageToJpeg(file, 2048, 0.9);

        const originalBase = file.name.replace(/\.[^/.]+$/, "");
        const fileName = `${key}_${originalBase}.jpg`;
        const path = `${DATABASE_BASE_PATH}/images/walmartProjectTracker/${projKey}/${kind}/${fileName}`;

        console.log("[upload] storage path:", path);

        if (!storage || !storageRef) {
          console.error("[upload] storage or storageRef missing", { storage, storageRef });
          alert("Storage is not initialized correctly. Check firebase-init.js exports.");
          return;
        }

        const sRef = storageRef(storage, path);
        await uploadBytes(sRef, resizedBlob, { contentType: "image/jpeg" });
        const url = await getDownloadURL(sRef);

        console.log("[upload] upload complete, url =", url);

        const proj = getCurrentProjectObj();
        if (kind === "alarm") {
          if (!proj.alarmPoints[key]) proj.alarmPoints[key] = {};
          const target = proj.alarmPoints[key];

          if (!Array.isArray(target.images)) {
            target.images = [];
            if (target.imageUrl) {
              target.images.push({
                url: target.imageUrl,
                path: target.imagePath || null,
                note: target.imageNote || ""
              });
            }
          }
          target.images.push({ url, path, note: "" });

          target.imageUrl = null;
          target.imagePath = null;
          target.imageNote = null;

          renderAlarmPanel();
        } else if (kind === "camera") {
          if (!proj.cameras[key]) proj.cameras[key] = {};
          const target = proj.cameras[key];

          if (!Array.isArray(target.images)) {
            target.images = [];
            if (target.imageUrl) {
              target.images.push({
                url: target.imageUrl,
                path: target.imagePath || null,
                note: target.imageNote || ""
              });
            }
          }
          target.images.push({ url, path, note: "" });

          target.imageUrl = null;
          target.imagePath = null;
          target.imageNote = null;

          renderCameraPanel();
        }

        scheduleSave();
      } catch (err) {
        console.error("Image upload failed", err);

        let msg = "Image upload failed.";
        if (err.code === "storage/unauthorized") {
          msg += " Your Firebase Storage rules may not allow writing to this path.";
        } else if (err.message && err.message.includes("HEIC")) {
          msg += " If this was a HEIC file, your browser might not support decoding that format.";
        }

        alert(msg);
      }
    });

    onAuthStateChanged(auth, async (user) => {
      // Only auto-switch base path when NOT in admin override mode
      if (!editingUnlocked) {
        DATABASE_BASE_PATH = user ? `${user.uid}` : 'public';
      }

      console.log("[auth] DATABASE_BASE_PATH:", DATABASE_BASE_PATH);

      if (state.currentProjectKey && state.currentProjectName) {
        try {
          await loadProjectFromFirebase(state.currentProjectKey, state.currentProjectName);
          renderSidebar();
          renderSection(activeSectionId);
          renderAlarmPanel();
          renderCameraPanel();
        } catch (err) {
          console.error("Error reloading project after auth change:", err);
        }
      } else {
        await restoreLastProjectForCurrentBasePath();
      }
    });

    console.log("[auth] DATABASE_BASE_PATH:", DATABASE_BASE_PATH);

    // Initial render
    if (sectionOrder.length) {
      activeSectionId = sectionOrder[0];
    } else if (SECTIONS.length) {
      activeSectionId = SECTIONS[0].id;
    }
    renderSidebar();
    renderSection(activeSectionId);
    renderAlarmPanel();
    renderCameraPanel();
  </script>
</body>

</html>