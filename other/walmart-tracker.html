<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Walmart Security Technology – Project Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="module" src="../apps/assets/js/login.js" defer></script>
  <link rel="stylesheet" href="./assets/css/walmart-tracker.css" />
</head>

<body>

  <header>
    <img src="assets/img/walmart-logo.webp" alt="">
    <div>
      <br>
      <section id="login-section">
        <form id="login-form">
          <label for="username" style="width: auto;">Email:</label>
          <input type="email" id="username" required>
          <br>
          <label for="password">Password:</label>
          <input type="password" id="password" required>
          <br>
          <button type="submit">Login</button>
        </form>
        <button id="logout" style="display: none;">Logout</button>
      </section>
    </div>
    <div class="current-project-tag">
      Data path: <code id="currentBasePathLabel">public</code>
    </div>
  </header>

  <main>
    <div class="app-shell">
      <!-- SIDEBAR -->
      <aside class="sidebar card">
        <div class="sidebar-header">
          <h1>Tech Sheet – Project Tracker</h1>
          <div class="subtitle">
            Track Walmart CCTV & Alarm scope, alarm points, and cameras for this job.
          </div>

          <div class="project-row">
            <input id="projectNameInput" placeholder="Project (e.g. WM1234 – City)">
            <button id="setProjectBtn" type="button">Set</button>
          </div>
          <button id="clearProjectBtn" type="button">Clear</button>
          <div class="current-project-tag">
            Current project: <code id="currentProjectLabel">(none)</code>
          </div>

          <div class="project-links-card">
            <div class="project-links-header">Project links</div>

            <!-- Always visible -->
            <ul id="projectLinksList" class="project-links-list"></ul>

            <!-- Only visible in admin mode -->
            <form id="projectLinksForm" class="project-links-form hidden">
              <input type="text" id="projectLinkTitle" placeholder="Title" class="project-link-input">
              <input type="url" id="projectLinkUrl" placeholder="URL (https://...)" class="project-link-input">
              <button type="submit" class="project-link-add-btn">Add</button>
            </form>
          </div>

          <div class="progress-row">
            <span>Overall scope complete</span>
            <span id="overallPercent">0%</span>
          </div>
          <div class="progress-bar-track">
            <div class="progress-bar-fill" id="overallBar"></div>
          </div>
          <div class="progress-row">
            <span>Cameras</span>
            <span id="sidebarCameraSummary">0 done / 0 total</span>
          </div>

        </div>

        <div class="pill-list" id="sectionList"></div>
      </aside>

      <!-- MAIN CONTENT -->
      <main class="main card">
        <div class="main-header">
          <div id="sectionTitle">Select a section</div>
          <div id="sectionMeta"></div>

          <div class="section-progress-wrapper" id="sectionProgressWrapper" style="display:none;">
            <span class="section-progress-label" id="sectionCountLabel"></span>
            <div class="progress-bar-track" style="flex:1;">
              <div class="progress-bar-fill" id="sectionBar"></div>
            </div>
          </div>
        </div>

        <ul class="task-list" id="taskList"></ul>

        <div class="notes-block" id="notesBlock" style="display:none;">
          <label for="sectionNotes">
            Section notes
            <span class="section-tag">
              Scope ref: <code id="sectionScopeCode"></code>
            </span>
          </label>
          <textarea id="sectionNotes"
            placeholder="Add site-specific details, deviations from prints, AHJ notes, or anything you want to remember for this section..."></textarea>
          <small>Notes are saved automatically to Firebase for the current project.</small>
        </div>

        <hr style="border-color:#232a37;opacity:.6;margin:10px 0;">

        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px;">
          <button type="button" class="detail-tab" data-panel="alarm">Alarm Points</button>
          <button type="button" class="detail-tab" data-panel="cameras">Cameras</button>
          <button type="button" class="detail-tab" data-panel="speakers">Speakers</button>
        </div>

        <div>
          <input type="checkbox" id="enableImageEditCheckbox">
          <span>Enable editing of image notes (admin only)</span>
        </div>

        <!-- Alarm points panel -->
        <div id="alarmPanel" class="detail-panel hidden">
          <div>
            Track each alarm point: number, name, completed, and optional photos with notes.
          </div>

          <!-- Hide-done checkbox for alarms -->
          <div style="margin:6px 0;">
            <label style="display:flex;align-items:center;gap:4px;color:var(--text-muted);">
              <input type="checkbox" id="hideDoneAlarms">
              <span>Hide done alarm points</span>
            </label>
          </div>

          <form id="alarmForm" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;">
            <input type="number" id="alarmPointNumber" placeholder="Point #" min="0"
              style="flex:0 0 90px;padding:4px 6px;">
            <input type="text" id="alarmPointName" placeholder="Point name / description"
              style="flex:1 1 180px;padding:4px 6px;">
            <button type="submit">Add / Update</button>
          </form>

          <table class="detail-table" id="alarmTable">
            <thead>
              <tr>
                <th>Point #</th>
                <th>Name</th>
                <th>Done</th>
                <th>Image(s)</th>
                <th>Notes</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <!-- Cameras panel -->
        <div id="cameraPanel" class="detail-panel hidden">
          <div>
            Track each camera: ID, name/location, completion, photos, and camera-level notes.
          </div>

          <!-- Hide-done checkbox for cameras -->
          <div style="margin:6px 0;">
            <label style="display:flex;align-items:center;gap:4px;color:var(--text-muted);">
              <input type="checkbox" id="hideDoneCameras">
              <span>Hide done cameras</span>
            </label>
          </div>

          <form id="cameraForm" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;">
            <input type="text" id="cameraId" placeholder="Camera ID (Cable # / CAM-01, etc.)"
              style="flex:0 0 150px;padding:4px 6px;">
            <input type="text" id="cameraName" placeholder="Camera name / location"
              style="flex:1 1 180px;padding:4px 6px;">
            <button type="submit">Add / Update</button>
          </form>

          <!-- NEW: column visibility toggles -->
          <div class="camera-column-toggles">
            <span>Show fields:</span>
            <label><input type="checkbox" id="toggleCameraIp"> IP</label>
            <label><input type="checkbox" id="toggleCameraMac"> MAC</label>
            <label><input type="checkbox" id="toggleCameraSwitch"> Switch / Port</label>
          </div>
          <div style="overflow: auto;">
            <table class="detail-table" id="cameraTable">
              <thead>
                <tr>
                  <th>Camera ID</th>
                  <th>Name</th>
                  <th class="col-camera-ip">IP</th>
                  <th class="col-camera-mac">MAC</th>
                  <th class="col-camera-switch">Switch / Port</th>
                  <th>Done</th>
                  <th>Image(s)</th>
                  <th>Notes</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div style="display:flex;gap:8px;margin:8px 0;">
            <button type="button" id="importCameraCsvBtn">
              Import Camera List (Cable Sheet CSV)
            </button>
            <button type="button" id="exportCameraCsvBtn">
              Export Camera Table (Cable Sheet CSV)
            </button>
          </div>
        </div>

        <!-- Speakers panel -->
        <div id="speakersPanel" class="detail-panel hidden">
          <div>
            Track speakers: number, name/location, and notes.
          </div>

          <form id="speakerForm" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;">
            <input type="number" id="speakerNumber" placeholder="Speaker #" min="0"
              style="flex:0 0 90px;padding:4px 6px;">
            <input type="text" id="speakerName" placeholder="Speaker name / location"
              style="flex:1 1 180px;padding:4px 6px;">
            <button type="submit">Add / Update</button>
          </form>

          <table class="detail-table" id="speakerTable">
            <thead>
              <tr>
                <th>Speaker #</th>
                <th>Name</th>
                <th>Notes</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <!-- hidden file input for both alarm + camera + task uploads -->
        <input type="file" id="imageUploadInput" accept="image/*" class="hidden">

        <!-- hidden file input for camera CSV import -->
        <input type="file" id="cameraCsvInput" accept=".csv" class="hidden">

      </main>
    </div>
  </main>

  <script type="module">
    // -------- Firebase imports --------
    import {
      auth,
      onAuthStateChanged,
      database,
      storage,
      ref,
      set,
      update,
      get,
      storageRef,
      uploadBytes,
      getDownloadURL,
      deleteObject
    } from '../assets/js/firebase-init.js';

    // -------- Dynamic base path --------
    let DATABASE_BASE_PATH = 'public';
    const LAST_PROJECT_STORAGE_KEY = "walmartProjectTracker:lastProject";

    // localStorage key for section order
    const SECTION_ORDER_STORAGE_KEY = "walmartProjectTracker:sectionOrder";

    function getProjectBasePath() {
      return `${DATABASE_BASE_PATH}/walmartProjectTracker/projects`;
    }

    // -------- Scope-driven sections --------
    let SECTIONS = [];

    async function loadSections(isLoggedIn) {
      try {
        // Base sections – always loaded
        const urls = [
          './assets/js/sections-walmart.json'
        ];

        // Extra sections – only for logged-in users
        if (isLoggedIn) {
          urls.push('./assets/js/sections-walmart-private.json');
        }

        // Fetch all JSONs in parallel
        const responses = await Promise.all(urls.map(u => fetch(u)));

        for (const res of responses) {
          if (!res.ok) {
            throw new Error(`HTTP ${res.status} for ${res.url}`);
          }
        }

        const jsonArrays = await Promise.all(responses.map(r => r.json()));

        // Merge all arrays into one big SECTIONS array
        SECTIONS = jsonArrays.flat();

        // Rebuild sectionOrder from SECTIONS (keeping any stored order if possible)
        sectionOrder = loadSectionOrderFromLocalStorage();

        // Set default active section if not already set or invalid
        if (!activeSectionId || !getSectionById(activeSectionId)) {
          if (sectionOrder.length) {
            activeSectionId = sectionOrder[0];
          } else if (SECTIONS.length) {
            activeSectionId = SECTIONS[0].id;
          } else {
            activeSectionId = null;
          }
        }

        // Now redraw UI
        rerenderAll();
      } catch (err) {
        console.error('Failed to load sections JSON:', err);
        alert('Could not load sections configuration. Check the JSON paths / syntax.');
      }
    }

    // -------- STATE --------
    let state = {
      currentProjectName: "",
      currentProjectKey: "",
      projects: {} // { [projectKey]: { name, tasks, notes, alarmPoints, cameras, speakers, links } }
    };

    // section order (list of section IDs)
    let sectionOrder = loadSectionOrderFromLocalStorage();

    // DOM refs
    const sectionListEl = document.getElementById("sectionList");
    const overallPercentEl = document.getElementById("overallPercent");
    const overallBarEl = document.getElementById("overallBar");
    const currentProjectLabelEl = document.getElementById("currentProjectLabel");
    const currentBasePathLabelEl = document.getElementById("currentBasePathLabel");
    const sectionTitleEl = document.getElementById("sectionTitle");
    const sectionMetaEl = document.getElementById("sectionMeta");
    const sectionCountLabelEl = document.getElementById("sectionCountLabel");
    const sectionBarEl = document.getElementById("sectionBar");
    const sectionProgressWrapperEl = document.getElementById("sectionProgressWrapper");
    const taskListEl = document.getElementById("taskList");
    const notesBlockEl = document.getElementById("notesBlock");
    const sectionNotesEl = document.getElementById("sectionNotes");
    const sectionScopeCodeEl = document.getElementById("sectionScopeCode");

    const alarmPanelEl = document.getElementById("alarmPanel");
    const cameraPanelEl = document.getElementById("cameraPanel");
    const alarmTableBodyEl = document.querySelector("#alarmTable tbody");
    const cameraTableBodyEl = document.querySelector("#cameraTable tbody");
    const alarmFormEl = document.getElementById("alarmForm");
    const alarmPointNumberEl = document.getElementById("alarmPointNumber");
    const alarmPointNameEl = document.getElementById("alarmPointName");
    const cameraFormEl = document.getElementById("cameraForm");
    const cameraIdEl = document.getElementById("cameraId");
    const cameraNameEl = document.getElementById("cameraName");
    const imageUploadInputEl = document.getElementById("imageUploadInput");
    const detailTabButtons = document.querySelectorAll(".detail-tab");
    const speakersPanelEl = document.getElementById("speakersPanel");
    const speakerTableBodyEl = document.querySelector("#speakerTable tbody");
    const speakerFormEl = document.getElementById("speakerForm");
    const speakerNumberEl = document.getElementById("speakerNumber");
    const speakerNameEl = document.getElementById("speakerName");

    const setProjectBtn = document.getElementById("setProjectBtn");
    const clearProjectBtn = document.getElementById("clearProjectBtn");
    const projectNameInput = document.getElementById("projectNameInput");

    // Project links DOM
    const projectLinksList = document.getElementById("projectLinksList");
    const projectLinksForm = document.getElementById("projectLinksForm");
    const linkTitleInput = document.getElementById("projectLinkTitle");
    const linkUrlInput = document.getElementById("projectLinkUrl");
    const exportCameraCsvBtn = document.getElementById("exportCameraCsvBtn");
    const importCameraCsvBtn = document.getElementById("importCameraCsvBtn");
    const cameraCsvInputEl = document.getElementById("cameraCsvInput");
    const toggleCameraIpEl = document.getElementById("toggleCameraIp");
    const toggleCameraMacEl = document.getElementById("toggleCameraMac");
    const toggleCameraSwitchEl = document.getElementById("toggleCameraSwitch");

    const CAMERA_COL_VIS_KEY = "walmartProjectTracker:cameraColumns";

    let cameraColumnVisibility = loadCameraColumnVisibility();

    const enableImageEditCheckbox = document.getElementById("enableImageEditCheckbox");

    const hideDoneCamerasCheckbox = document.getElementById("hideDoneCameras");
    const hideDoneAlarmsCheckbox = document.getElementById("hideDoneAlarms");
    let hideDoneCameras = false;
    let hideDoneAlarms = false;

    let activeSectionId = null;
    let saveTimeout = null;
    let pendingUploadTarget = null; // { kind: 'alarm' | 'camera' | 'task', key: string }
    let editingUnlocked = false;
    let draggedSectionId = null; // for drag & drop

    function sanitizeProjectKey(name) {
      return name
        .trim()
        .toLowerCase()
        .replace(/[.#$/\[\]]/g, "_")
        .replace(/\s+/g, "_");
    }

    // Safe task key for Firebase (handles "1.05" etc.)
    function makeTaskKey(sectionId, taskId) {
      return `${sectionId}:${String(taskId)}`.replace(/[.#$/\[\]]/g, "_");
    }

    // helper to get a section by its id
    function getSectionById(id) {
      return SECTIONS.find(s => s.id === id) || null;
    }

    // ------ Generic helpers / UI helpers ------

    function loadSectionOrderFromLocalStorage() {
      try {
        const raw = localStorage.getItem(SECTION_ORDER_STORAGE_KEY);
        const defaultOrder = SECTIONS.map(s => s.id);
        if (!raw) return defaultOrder;

        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return defaultOrder;

        // Only keep IDs that still exist
        const valid = parsed.filter(id => getSectionById(id));
        // Add any new sections that weren't in stored order
        const missing = SECTIONS.map(s => s.id).filter(id => !valid.includes(id));
        return [...valid, ...missing];
      } catch (e) {
        console.warn("Could not load section order from localStorage:", e);
        return SECTIONS.map(s => s.id);
      }
    }

    function saveSectionOrderToLocalStorage() {
      try {
        localStorage.setItem(SECTION_ORDER_STORAGE_KEY, JSON.stringify(sectionOrder));
      } catch (e) {
        console.warn("Could not save section order to localStorage:", e);
      }
    }

    function ensureActiveSection() {
      if (!activeSectionId || !getSectionById(activeSectionId)) {
        if (sectionOrder.length) {
          activeSectionId = sectionOrder[0];
        } else if (SECTIONS.length) {
          activeSectionId = SECTIONS[0].id;
        } else {
          activeSectionId = null;
        }
      }
    }

    function rerenderAll() {
      renderSidebar();
      renderSection(activeSectionId);
      renderAlarmPanel();
      renderCameraPanel();
      renderSpeakersPanel();
      renderProjectLinks();
    }

    function rerenderForCurrentProject() {
      ensureActiveSection();
      rerenderAll();
    }

    function loadCameraColumnVisibility() {
      try {
        const raw = localStorage.getItem(CAMERA_COL_VIS_KEY);
        if (!raw) {
          // defaults: hide all optional cols unless turned on
          return { ip: false, mac: false, sw: false };
        }
        const parsed = JSON.parse(raw);
        return {
          ip: !!parsed.ip,
          mac: !!parsed.mac,
          sw: !!parsed.sw
        };
      } catch (e) {
        console.warn("Could not load camera column visibility:", e);
        return { ip: false, mac: false, sw: false };
      }
    }

    function saveCameraColumnVisibility() {
      try {
        localStorage.setItem(CAMERA_COL_VIS_KEY, JSON.stringify(cameraColumnVisibility));
      } catch (e) {
        console.warn("Could not save camera column visibility:", e);
      }
    }

    function applyCameraColumnVisibility() {
      const vis = cameraColumnVisibility;

      const setDisplay = (selector, show) => {
        document.querySelectorAll(selector).forEach(el => {
          el.style.display = show ? "" : "none";
        });
      };

      setDisplay(".col-camera-ip", !!vis.ip);
      setDisplay(".col-camera-mac", !!vis.mac);
      setDisplay(".col-camera-switch", !!vis.sw);
    }

    function initCameraColumnToggles() {
      if (!toggleCameraIpEl || !toggleCameraMacEl || !toggleCameraSwitchEl) return;

      // initialize checkboxes from state
      toggleCameraIpEl.checked = !!cameraColumnVisibility.ip;
      toggleCameraMacEl.checked = !!cameraColumnVisibility.mac;
      toggleCameraSwitchEl.checked = !!cameraColumnVisibility.sw;

      const updateFromCheckboxes = () => {
        cameraColumnVisibility = {
          ip: !!toggleCameraIpEl.checked,
          mac: !!toggleCameraMacEl.checked,
          sw: !!toggleCameraSwitchEl.checked
        };
        saveCameraColumnVisibility();
        applyCameraColumnVisibility();
      };

      toggleCameraIpEl.addEventListener("change", updateFromCheckboxes);
      toggleCameraMacEl.addEventListener("change", updateFromCheckboxes);
      toggleCameraSwitchEl.addEventListener("change", updateFromCheckboxes);
    }

    // Normalize legacy single-image fields into an array for any alarm/camera entry
    function normalizeImagesArray(target) {
      if (!target) return [];
      if (Array.isArray(target.images)) return target.images;

      const images = [];
      if (target.imageUrl) {
        images.push({
          url: target.imageUrl,
          path: target.imagePath || null,
          note: target.imageNote || ""
        });
      }
      target.images = images;
      target.imageUrl = null;
      target.imagePath = null;
      target.imageNote = null;
      return images;
    }

    // Collect all storage paths to be deleted for a given alarm/camera/task entry
    function collectImagePaths(entry) {
      const paths = [];
      if (!entry) return paths;
      if (Array.isArray(entry.images)) {
        entry.images.forEach(img => {
          if (img && img.path) paths.push(img.path);
        });
      }
      if (entry.imagePath) {
        paths.push(entry.imagePath);
      }
      return paths;
    }

    function getCurrentProjectObj() {
      if (!state.currentProjectKey) return null;
      if (!state.projects[state.currentProjectKey]) {
        state.projects[state.currentProjectKey] = {
          name: state.currentProjectName,
          tasks: {},
          notes: {},
          alarmPoints: {},
          cameras: {},
          speakers: {},
          links: []
        };
      } else {
        const proj = state.projects[state.currentProjectKey];
        proj.tasks = proj.tasks || {};
        proj.notes = proj.notes || {};
        proj.alarmPoints = proj.alarmPoints || {};
        proj.cameras = proj.cameras || {};
        proj.speakers = proj.speakers || {};
        proj.links = proj.links || [];
      }
      return state.projects[state.currentProjectKey];
    }

    if (exportCameraCsvBtn) {
      exportCameraCsvBtn.addEventListener("click", exportCameraCableSheet);
    }

    if (importCameraCsvBtn && cameraCsvInputEl) {
      importCameraCsvBtn.addEventListener("click", () => {
        if (!state.currentProjectKey) {
          alert("Set a project first before importing cameras.");
          return;
        }
        cameraCsvInputEl.value = "";
        cameraCsvInputEl.click();
      });

      cameraCsvInputEl.addEventListener("change", () => {
        const file = cameraCsvInputEl.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = () => {
          try {
            importCamerasFromCsv(reader.result);
          } catch (err) {
            console.error("Camera CSV import failed:", err);
            alert("Could not import camera list. Check console for details.");
          } finally {
            cameraCsvInputEl.value = "";
          }
        };
        reader.onerror = () => {
          alert("Failed to read CSV file.");
        };
        reader.readAsText(file);
      });
    }

    function exportCameraCableSheet() {
      const proj = getCurrentProjectObj();
      if (!proj) {
        alert("Set a project first.");
        return;
      }

      // Header row copied from your Cable Assignment Sheet, with the last column used for Notes
      const header = [
        "Cable #",
        "Location Name",
        "IP Address",
        "Subnet",
        "MAC address",
        "Switch",
        "Switch Port",
        "Camera Model",
        "Camera to be displayed ",
        "Camera Recording Profile",
        "Camera Group",
        "ID",
        "IP",
        "Switch-Port",
        "Named Ranges",
        "",
        "Notes"   // using last column for camera-level notes
      ];

      const rows = [];

      // Sort cameras by ID so the CSV is neat
      const entries = Object.entries(proj.cameras || {}).sort(([a], [b]) =>
        a.localeCompare(b, undefined, { numeric: true })
      );

      entries.forEach(([camId, info]) => {
        const row = new Array(header.length).fill("");

        // Map your fields
        row[0] = camId || "";              // Cable #
        row[1] = info.name || "";          // Location Name

        // Flatten multi-line notes to a single line for CSV
        const flatNote = (info.note || "").replace(/\r?\n|\r/g, " | ");

        // Use the LAST header column as the Notes column
        const notesColIndex = header.length - 1;
        row[notesColIndex] = flatNote;

        rows.push(row);
      });

      // CSV escaping
      function esc(val) {
        const s = String(val ?? "");
        if (s.includes('"') || s.includes(",") || s.includes("\n")) {
          return '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      }

      const lines = [];
      lines.push(header.map(esc).join(","));
      rows.forEach(r => lines.push(r.map(esc).join(",")));

      const csvContent = lines.join("\r\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");

      const baseName =
        (state.currentProjectName || state.currentProjectKey || "project")
          .replace(/[^a-z0-9_\-]+/gi, "_");

      a.href = url;
      a.download = `${baseName}_Camera_Cable_Assignment.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importCamerasFromCsv(csvText) {
      const proj = getCurrentProjectObj();
      if (!proj) {
        alert("Set a project first.");
        return;
      }

      const lines = csvText.split(/\r?\n/).filter(l => l.trim() !== "");
      if (!lines.length) {
        alert("CSV appears to be empty.");
        return;
      }

      // Find the header row that starts the cable assignment table
      // (the row where first cell is 'Cable #')
      let startIdx = -1;
      for (let i = 0; i < lines.length; i++) {
        const firstCell = (lines[i].split(",")[0] || "").trim().toLowerCase();
        if (firstCell === "cable #" || firstCell === "cable#") {
          startIdx = i + 1; // data starts on the next line
          break;
        }
      }

      if (startIdx === -1) {
        alert("Could not find 'Cable #' header in CSV.");
        return;
      }

      let importedCount = 0;
      let updatedCount = 0;

      for (let i = startIdx; i < lines.length; i++) {
        const raw = lines[i].trim();
        if (!raw) continue;

        const cells = raw.split(","); // NOTE: assumes no commas inside fields

        const cableId = (cells[0] || "").trim();
        const locationName = (cells[1] || "").trim();

        // If the first cell stops being a number, we've probably reached the end of the table
        if (!cableId || !/^\d+$/.test(cableId)) {
          break;
        }

        const ip = (cells[2] || "").trim();
        const subnet = (cells[3] || "").trim();
        const mac = (cells[4] || "").trim();
        const switchName = (cells[5] || "").trim();
        const switchPort = (cells[6] || "").trim();
        const cameraModel = (cells[7] || "").trim();
        const displayName = (cells[8] || "").trim();
        const recordingProfile = (cells[9] || "").trim();
        const cameraGroup = (cells[10] || "").trim();

        const existing = proj.cameras[cableId] || {};
        const alreadyExists = !!proj.cameras[cableId];

        // Merge: keep existing done/images/note, overlay new cable sheet fields
        proj.cameras[cableId] = {
          ...existing,
          name: locationName || existing.name || "",
          ip: ip || existing.ip || "",
          subnet: subnet || existing.subnet || "",
          mac: mac || existing.mac || "",
          switchName: switchName || existing.switchName || "",
          switchPort: switchPort || existing.switchPort || "",
          model: cameraModel || existing.model || "",
          displayName: displayName || existing.displayName || "",
          recordingProfile: recordingProfile || existing.recordingProfile || "",
          group: cameraGroup || existing.group || ""
        };

        if (alreadyExists) {
          updatedCount++;
        } else {
          importedCount++;
        }
      }

      scheduleSave();
      renderCameraPanel();

      alert(
        `Camera CSV import finished.\n` +
        `New cameras: ${importedCount}\n` +
        `Updated cameras: ${updatedCount}`
      );
    }

    async function loadProjectFromFirebase(projectKey, displayName) {
      const projectRef = ref(database, `${getProjectBasePath()}/${projectKey}`);
      const snap = await get(projectRef);
      if (snap.exists()) {
        const data = snap.val();
        state.projects[projectKey] = {
          name: data.name || displayName,
          tasks: data.tasks || {},
          notes: data.notes || {},
          alarmPoints: data.alarmPoints || {},
          cameras: data.cameras || {},
          speakers: data.speakers || {},
          links: data.links || []
        };
      } else {
        const newData = {
          name: displayName,
          tasks: {},
          notes: {},
          alarmPoints: {},
          cameras: {},
          speakers: {},
          links: []
        };
        await set(projectRef, newData);
        state.projects[projectKey] = newData;
      }
    }

    async function saveProjectToFirebase() {
      if (!state.currentProjectKey) return;
      const proj = getCurrentProjectObj();
      if (!proj) return;
      const projectRef = ref(database, `${getProjectBasePath()}/${state.currentProjectKey}`);
      await update(projectRef, {
        name: state.currentProjectName,
        tasks: proj.tasks || {},
        notes: proj.notes || {},
        alarmPoints: proj.alarmPoints || {},
        cameras: proj.cameras || {},
        speakers: proj.speakers || {},
        links: proj.links || []
      });
    }

    function scheduleSave() {
      if (!state.currentProjectKey) return;
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveTimeout = null;
        saveProjectToFirebase().catch(console.error);
      }, 400);
    }

    function computeOverallProgress() {
      const proj = getCurrentProjectObj();
      if (!proj) return { done: 0, total: 0, percent: 0 };
      let total = 0;
      let done = 0;
      SECTIONS.forEach(sec => {
        sec.tasks.forEach(t => {
          total++;
          const key = makeTaskKey(sec.id, t.id);
          const entry = proj.tasks[key];
          const isDone = !!(entry && (typeof entry === "object" ? entry.done : entry));
          if (isDone) done++;
        });
      });
      return {
        done,
        total,
        percent: total === 0 ? 0 : Math.round((done / total) * 100)
      };
    }

    function computeSectionProgress(sectionId) {
      const proj = getCurrentProjectObj();
      if (!proj) return { done: 0, total: 0, percent: 0 };
      const section = getSectionById(sectionId);
      if (!section) return { done: 0, total: 0, percent: 0 };

      const total = section.tasks.length;
      const done = section.tasks.filter(t => {
        const key = makeTaskKey(section.id, t.id);
        const entry = proj.tasks[key];
        const isDone = !!(entry && (typeof entry === "object" ? entry.done : entry));
        return isDone;
      }).length;

      return {
        done,
        total,
        percent: total === 0 ? 0 : Math.round((done / total) * 100)
      };
    }

    function renderSidebar() {
      sectionListEl.innerHTML = "";
      const overall = computeOverallProgress();
      overallPercentEl.textContent = overall.percent + "%";
      overallBarEl.style.width = overall.percent + "%";
      currentProjectLabelEl.textContent = state.currentProjectName || "(none)";
      if (currentBasePathLabelEl) {
        currentBasePathLabelEl.textContent = DATABASE_BASE_PATH;
      }

      // Make sure activeSectionId is valid
      if (!activeSectionId || !getSectionById(activeSectionId)) {
        activeSectionId = sectionOrder[0] || (SECTIONS[0] && SECTIONS[0].id);
      }

      sectionOrder.forEach(secId => {
        const sec = getSectionById(secId);
        if (!sec) return;

        const secProgress = computeSectionProgress(sec.id);
        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "section-pill" + (sec.id === activeSectionId ? " active" : "");
        pill.dataset.sectionId = sec.id;
        pill.draggable = true;

        const labelSpan = document.createElement("span");
        labelSpan.className = "label";
        labelSpan.textContent = sec.title;

        const rightSpan = document.createElement("span");
        rightSpan.className = "pill-progress";

        const dot = document.createElement("span");
        dot.className = "pill-dot" + (secProgress.done === secProgress.total && secProgress.total > 0 ? " done" : "");

        const count = document.createElement("span");
        count.textContent = secProgress.total ? `${secProgress.done}/${secProgress.total}` : "-";

        rightSpan.appendChild(dot);
        rightSpan.appendChild(count);

        pill.appendChild(labelSpan);
        pill.appendChild(rightSpan);

        // Click to select section
        pill.addEventListener("click", () => {
          activeSectionId = sec.id;
          renderSidebar();
          renderSection(sec.id);
        });

        // Drag & drop events
        pill.addEventListener("dragstart", (e) => {
          draggedSectionId = sec.id;
          e.dataTransfer.effectAllowed = "move";
        });

        pill.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
        });

        pill.addEventListener("drop", (e) => {
          e.preventDefault();
          if (!draggedSectionId || draggedSectionId === sec.id) return;

          const fromIndex = sectionOrder.indexOf(draggedSectionId);
          const toIndex = sectionOrder.indexOf(sec.id);
          if (fromIndex === -1 || toIndex === -1) return;

          sectionOrder.splice(fromIndex, 1);
          sectionOrder.splice(toIndex, 0, draggedSectionId);

          saveSectionOrderToLocalStorage();
          draggedSectionId = null;

          renderSidebar();
          renderSection(activeSectionId);
        });

        sectionListEl.appendChild(pill);
      });
    }

    function renderSection(sectionId) {
      const section = getSectionById(sectionId);
      if (!section) {
        sectionTitleEl.textContent = "Select a section";
        sectionMetaEl.textContent = "";
        taskListEl.innerHTML = "";
        sectionProgressWrapperEl.style.display = "none";
        notesBlockEl.style.display = "none";
        return;
      }

      sectionTitleEl.textContent = section.title;
      sectionMetaEl.textContent = "Scope reference: " + section.scopeRef;

      const secProgress = computeSectionProgress(sectionId);
      sectionProgressWrapperEl.style.display = "flex";
      sectionCountLabelEl.textContent = `${secProgress.done} / ${secProgress.total} done`;
      sectionBarEl.style.width = secProgress.percent + "%";

      taskListEl.innerHTML = "";
      const project = getCurrentProjectObj();

      section.tasks.forEach(task => {
        const li = document.createElement("li");
        const key = makeTaskKey(section.id, task.id);
        const taskState = project && project.tasks[key];
        const done = !!(taskState && (typeof taskState === "object" ? taskState.done : taskState));

        li.className = "task-item" + (done ? " done" : "");

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "task-checkbox";
        checkbox.checked = done;

        checkbox.addEventListener("change", () => {
          if (!state.currentProjectKey) {
            alert("Set a project name first so checks can be saved to Firebase.");
            checkbox.checked = false;
            return;
          }
          const proj = getCurrentProjectObj();

          const existing = proj.tasks[key];
          const currentDone = !!(existing && (typeof existing === "object" ? existing.done : existing));
          const newDone = checkbox.checked;

          if (!existing || typeof existing !== "object") {
            proj.tasks[key] = { done: newDone };
          } else {
            proj.tasks[key].done = newDone;
          }

          scheduleSave();
          renderSidebar();
          renderSection(sectionId);
        });

        const labelDiv = document.createElement("div");
        labelDiv.className = "task-label";

        const idSpan = document.createElement("span");
        idSpan.className = "id";
        idSpan.textContent = task.id;

        const textSpan = document.createElement("span");
        textSpan.className = "text";
        textSpan.textContent = task.text;

        labelDiv.appendChild(idSpan);
        labelDiv.appendChild(textSpan);

        li.appendChild(checkbox);
        li.appendChild(labelDiv);

        // --- Task images UI ---
        const taskImagesContainer = document.createElement("div");
        taskImagesContainer.className = "task-images";

        const addTaskImgBtn = document.createElement("button");
        addTaskImgBtn.type = "button";
        addTaskImgBtn.textContent = "Add Image";
        addTaskImgBtn.addEventListener("click", () => {
          if (!state.currentProjectKey) {
            alert("Set a project first.");
            return;
          }
          pendingUploadTarget = { kind: "task", key };
          imageUploadInputEl.value = "";
          imageUploadInputEl.click();
        });
        taskImagesContainer.appendChild(addTaskImgBtn);

        if (project && project.tasks[key] && typeof project.tasks[key] === "object") {
          const imagesArr = normalizeImagesArray(project.tasks[key]);
          if (imagesArr.length) {
            const strip = document.createElement("div");
            strip.className = "thumb-strip";

            imagesArr.forEach((img, index) => {
              const wrapper = document.createElement("div");
              wrapper.className = "thumb-wrapper";

              const thumb = document.createElement("img");
              thumb.className = "thumb-img";
              thumb.src = img.url;
              thumb.alt = `Task ${task.id} image ${index + 1}`;
              thumb.title = "Click to open full image";
              thumb.addEventListener("click", () => {
                window.open(img.url, "_blank");
              });

              const delBtn = document.createElement("button");
              delBtn.className = "thumb-delete";
              delBtn.textContent = "×";
              delBtn.title = "Delete this image";
              delBtn.addEventListener("click", async () => {
                if (!editingUnlocked) {
                  alert("Enable admin editing to delete images.");
                  return;
                }
                if (!confirm("Delete this image for this task?")) return;

                const projNow = getCurrentProjectObj();
                if (!projNow.tasks[key] || typeof projNow.tasks[key] !== "object") return;

                const target = projNow.tasks[key];
                const imagesArrNow = normalizeImagesArray(target);
                const [removed] = imagesArrNow.splice(index, 1);

                scheduleSave();
                renderSection(sectionId);

                if (removed && removed.path) {
                  try {
                    await deleteObject(storageRef(storage, removed.path));
                  } catch (e) {
                    console.warn("Storage delete failed (maybe already removed):", e);
                  }
                }
              });

              const note = document.createElement("textarea");
              note.className = "thumb-note";
              note.rows = 2;
              note.placeholder = "Notes for this image…";
              note.value = img.note || "";
              note.readOnly = !editingUnlocked;
              note.addEventListener("blur", () => {
                if (!editingUnlocked) return;
                const projNow = getCurrentProjectObj();
                if (!projNow.tasks[key] || typeof projNow.tasks[key] !== "object") return;
                const target = projNow.tasks[key];
                const imagesArrNow = normalizeImagesArray(target);
                if (!imagesArrNow[index]) {
                  imagesArrNow[index] = {
                    url: img.url,
                    path: img.path || null,
                    note: ""
                  };
                }
                imagesArrNow[index].note = note.value;
                scheduleSave();
              });

              wrapper.appendChild(thumb);
              wrapper.appendChild(delBtn);
              wrapper.appendChild(note);
              strip.appendChild(wrapper);
            });

            taskImagesContainer.appendChild(strip);
          }
        }

        li.appendChild(taskImagesContainer);
        taskListEl.appendChild(li);
      });

      const proj = getCurrentProjectObj();
      notesBlockEl.style.display = proj ? "block" : "none";
      sectionScopeCodeEl.textContent = section.scopeRef;
      sectionNotesEl.value = proj ? (proj.notes[section.id] || "") : "";
    }

    function renderAlarmPanel() {
      const proj = getCurrentProjectObj();
      alarmTableBodyEl.innerHTML = "";
      if (!proj) return;

      let entries = Object.entries(proj.alarmPoints || {}).sort(
        ([a], [b]) => Number(a) - Number(b)
      );

      if (hideDoneAlarms) {
        entries = entries.filter(([, info]) => !info.done);
      }

      entries.forEach(([pointNum, info]) => {
        const tr = document.createElement("tr");

        const tdNum = document.createElement("td");
        tdNum.textContent = pointNum;

        const tdName = document.createElement("td");
        tdName.textContent = info.name || "";

        const tdDone = document.createElement("td");
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = !!info.done;
        chk.addEventListener("change", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.alarmPoints[pointNum]) projNow.alarmPoints[pointNum] = {};
          projNow.alarmPoints[pointNum].name = info.name;
          projNow.alarmPoints[pointNum].done = chk.checked;
          scheduleSave();
          renderAlarmPanel();
        });
        tdDone.appendChild(chk);

        const tdImg = document.createElement("td");

        // Add Image button (always available)
        const addBtn = document.createElement("button");
        addBtn.textContent = "Add Image";
        addBtn.addEventListener("click", () => {
          if (!state.currentProjectKey) {
            alert("Set a project first.");
            return;
          }
          pendingUploadTarget = { kind: "alarm", key: pointNum };
          imageUploadInputEl.value = "";
          imageUploadInputEl.click();
        });
        tdImg.appendChild(addBtn);

        const images = normalizeImagesArray(info);

        if (images.length) {
          const strip = document.createElement("div");
          strip.className = "thumb-strip";

          images.forEach((img, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "thumb-wrapper";

            const thumb = document.createElement("img");
            thumb.className = "thumb-img";
            thumb.src = img.url;
            thumb.alt = `Alarm ${pointNum} image ${index + 1}`;
            thumb.title = "Click to open full image";
            thumb.addEventListener("click", () => {
              window.open(img.url, "_blank");
            });

            const delBtn = document.createElement("button");
            delBtn.className = "thumb-delete";
            delBtn.textContent = "×";
            delBtn.title = "Delete this image";
            delBtn.addEventListener("click", async () => {
              if (!editingUnlocked) {
                alert("Enable admin editing to delete images.");
                return;
              }
              if (!confirm("Delete this image for this alarm point?")) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.alarmPoints[pointNum]) projNow.alarmPoints[pointNum] = {};
              const target = projNow.alarmPoints[pointNum];

              normalizeImagesArray(target);

              const [removed] = target.images.splice(index, 1);

              scheduleSave();
              renderAlarmPanel();

              if (removed && removed.path) {
                try {
                  await deleteObject(storageRef(storage, removed.path));
                } catch (e) {
                  console.warn("Storage delete failed (maybe already removed):", e);
                }
              }
            });

            const note = document.createElement("textarea");
            note.className = "thumb-note";
            note.rows = 2;
            note.placeholder = "Notes for this image…";
            note.value = img.note || "";
            note.readOnly = !editingUnlocked;
            note.addEventListener("blur", () => {
              if (!editingUnlocked) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.alarmPoints[pointNum]) projNow.alarmPoints[pointNum] = {};
              const target = projNow.alarmPoints[pointNum];

              const imagesArr = normalizeImagesArray(target);

              if (!imagesArr[index]) {
                imagesArr[index] = {
                  url: img.url,
                  path: img.path || null,
                  note: ""
                };
              }

              imagesArr[index].note = note.value;
              scheduleSave();
            });

            wrapper.appendChild(thumb);
            wrapper.appendChild(delBtn);
            wrapper.appendChild(note);
            strip.appendChild(wrapper);
          });

          tdImg.appendChild(strip);
        }

        // Notes cell for the alarm point
        const tdNote = document.createElement("td");
        const alarmNoteArea = document.createElement("textarea");
        alarmNoteArea.className = "camera-note"; // reuse styling
        alarmNoteArea.placeholder = "Alarm point notes…";
        alarmNoteArea.value = info.note || "";
        alarmNoteArea.addEventListener("blur", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.alarmPoints[pointNum]) projNow.alarmPoints[pointNum] = {};
          projNow.alarmPoints[pointNum].name = info.name;
          projNow.alarmPoints[pointNum].done = !!info.done;
          projNow.alarmPoints[pointNum].note = alarmNoteArea.value;
          scheduleSave();
        });
        tdNote.appendChild(alarmNoteArea);

        // Actions cell (Delete point)
        const tdActions = document.createElement("td");
        const deletePointBtn = document.createElement("button");
        deletePointBtn.textContent = "Delete";
        deletePointBtn.title = "Delete this alarm point and all its images";

        deletePointBtn.addEventListener("click", async () => {
          if (!editingUnlocked) {
            alert("Enable admin editing to delete alarm points.");
            return;
          }

          if (!confirm(`Delete alarm point ${pointNum} and all associated images?`)) return;

          const projNow = getCurrentProjectObj();
          if (!projNow || !projNow.alarmPoints || !projNow.alarmPoints[pointNum]) {
            return;
          }

          const entry = projNow.alarmPoints[pointNum];

          const pathsToDelete = collectImagePaths(entry);

          // Remove from database state
          delete projNow.alarmPoints[pointNum];
          scheduleSave();
          renderAlarmPanel();

          // Try to delete from Storage (non-blocking for UI)
          for (const p of pathsToDelete) {
            try {
              await deleteObject(storageRef(storage, p));
            } catch (e) {
              console.warn("Failed to delete alarm image from storage:", p, e);
            }
          }
        });

        tdActions.appendChild(deletePointBtn);

        tr.appendChild(tdNum);
        tr.appendChild(tdName);
        tr.appendChild(tdDone);
        tr.appendChild(tdImg);
        tr.appendChild(tdNote);
        tr.appendChild(tdActions);

        alarmTableBodyEl.appendChild(tr);
      });
    }

    function renderSpeakersPanel() {
      const proj = getCurrentProjectObj();
      speakerTableBodyEl.innerHTML = "";
      if (!proj) return;

      const entries = Object.entries(proj.speakers || {}).sort(
        ([a], [b]) => Number(a) - Number(b)
      );

      entries.forEach(([num, info]) => {
        const tr = document.createElement("tr");

        const tdNum = document.createElement("td");
        tdNum.textContent = num;

        const tdName = document.createElement("td");
        tdName.textContent = info.name || "";

        const tdNote = document.createElement("td");
        const noteArea = document.createElement("textarea");
        noteArea.className = "camera-note"; // reuse styling
        noteArea.placeholder = "Speaker notes…";
        noteArea.value = info.note || "";
        noteArea.addEventListener("blur", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.speakers[num]) projNow.speakers[num] = {};
          projNow.speakers[num].name = info.name;
          projNow.speakers[num].note = noteArea.value;
          scheduleSave();
        });
        tdNote.appendChild(noteArea);

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.title = "Delete this speaker";

        delBtn.addEventListener("click", () => {
          if (!editingUnlocked) {
            alert("Enable admin editing to delete speakers.");
            return;
          }
          if (!confirm(`Delete speaker ${num}?`)) return;

          const projNow = getCurrentProjectObj();
          if (!projNow || !projNow.speakers) return;
          delete projNow.speakers[num];
          scheduleSave();
          renderSpeakersPanel();
        });

        tdActions.appendChild(delBtn);

        tr.appendChild(tdNum);
        tr.appendChild(tdName);
        tr.appendChild(tdNote);
        tr.appendChild(tdActions);

        speakerTableBodyEl.appendChild(tr);
      });
    }

    function renderCameraPanel() {
      const proj = getCurrentProjectObj();
      cameraTableBodyEl.innerHTML = "";
      if (!proj) return;

      let entries = Object.entries(proj.cameras || {}).sort(([a], [b]) =>
        a.localeCompare(b, undefined, { numeric: true })
      );

      if (hideDoneCameras) {
        entries = entries.filter(([, info]) => !info.done);
      }

      entries.forEach(([camId, info]) => {
        const tr = document.createElement("tr");

        // Camera ID
        const tdId = document.createElement("td");
        tdId.textContent = camId;

        // Name / location
        const tdName = document.createElement("td");
        tdName.textContent = info.name || "";

        // IP column (editable)
        const tdIp = document.createElement("td");
        tdIp.classList.add("col-camera-ip");
        const ipInput = document.createElement("input");
        ipInput.type = "text";
        ipInput.value = info.ip || "";
        ipInput.placeholder = "IP";
        ipInput.className = "camera-ip-input";
        ipInput.addEventListener("blur", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
          projNow.cameras[camId].ip = ipInput.value.trim();
          scheduleSave();
        });
        tdIp.appendChild(ipInput);

        // MAC column (editable)
        const tdMac = document.createElement("td");
        tdMac.classList.add("col-camera-mac");
        const macInput = document.createElement("input");
        macInput.type = "text";
        macInput.value = info.mac || "";
        macInput.placeholder = "MAC";
        macInput.className = "camera-mac-input";
        macInput.addEventListener("blur", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
          projNow.cameras[camId].mac = macInput.value.trim();
          scheduleSave();
        });
        tdMac.appendChild(macInput);

        // Switch / Port column (editable)
        const tdSwitch = document.createElement("td");
        tdSwitch.classList.add("col-camera-switch", "camera-switch-cell");

        const switchName = info.switchName || "";
        const switchPort = info.switchPort || "";

        const switchNameInput = document.createElement("input");
        switchNameInput.type = "text";
        switchNameInput.value = switchName;
        switchNameInput.placeholder = "Switch";
        switchNameInput.className = "camera-switch-input";

        const switchPortInput = document.createElement("input");
        switchPortInput.type = "text";
        switchPortInput.value = switchPort;
        switchPortInput.placeholder = "Port";
        switchPortInput.className = "camera-port-input";

        function saveSwitchFields() {
          const projNow = getCurrentProjectObj();
          if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
          projNow.cameras[camId].switchName = switchNameInput.value.trim();
          projNow.cameras[camId].switchPort = switchPortInput.value.trim();
          scheduleSave();
        }

        switchNameInput.addEventListener("blur", saveSwitchFields);
        switchPortInput.addEventListener("blur", saveSwitchFields);

        tdSwitch.appendChild(switchNameInput);
        tdSwitch.appendChild(switchPortInput);

        // Done checkbox
        const tdDone = document.createElement("td");
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = !!info.done;
        chk.addEventListener("change", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
          projNow.cameras[camId].name = info.name;
          projNow.cameras[camId].done = chk.checked;
          scheduleSave();
          renderCameraPanel();
        });
        tdDone.appendChild(chk);

        // Image(s) + Add Image button
        const tdImg = document.createElement("td");

        const addBtn = document.createElement("button");
        addBtn.textContent = "Add Image";
        addBtn.addEventListener("click", () => {
          if (!state.currentProjectKey) {
            alert("Set a project first.");
            return;
          }
          pendingUploadTarget = { kind: "camera", key: camId };
          imageUploadInputEl.value = "";
          imageUploadInputEl.click();
        });
        tdImg.appendChild(addBtn);

        const images = normalizeImagesArray(info);

        if (images.length) {
          const strip = document.createElement("div");
          strip.className = "thumb-strip";

          images.forEach((img, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "thumb-wrapper";

            const thumb = document.createElement("img");
            thumb.className = "thumb-img";
            thumb.src = img.url;
            thumb.alt = `Camera ${camId} image ${index + 1}`;
            thumb.title = "Click to open full image";
            thumb.addEventListener("click", () => {
              window.open(img.url, "_blank");
            });

            const delBtn = document.createElement("button");
            delBtn.className = "thumb-delete";
            delBtn.textContent = "×";
            delBtn.title = "Delete this image";
            delBtn.addEventListener("click", async () => {
              if (!editingUnlocked) {
                alert("Enable admin editing to delete images.");
                return;
              }
              if (!confirm("Delete this image for this camera?")) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
              const target = projNow.cameras[camId];

              const imagesArr = normalizeImagesArray(target);

              const [removed] = imagesArr.splice(index, 1);

              scheduleSave();
              renderCameraPanel();

              if (removed && removed.path) {
                try {
                  await deleteObject(storageRef(storage, removed.path));
                } catch (e) {
                  console.warn("Storage delete failed (maybe already removed):", e);
                }
              }
            });

            const note = document.createElement("textarea");
            note.className = "thumb-note";
            note.rows = 2;
            note.placeholder = "Notes for this image…";
            note.value = img.note || "";
            note.readOnly = !editingUnlocked;
            note.addEventListener("blur", () => {
              if (!editingUnlocked) return;

              const projNow = getCurrentProjectObj();
              if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
              const target = projNow.cameras[camId];

              const imagesArr = normalizeImagesArray(target);

              if (!imagesArr[index]) {
                imagesArr[index] = {
                  url: img.url,
                  path: img.path || null,
                  note: ""
                };
              }

              imagesArr[index].note = note.value;
              scheduleSave();
            });

            wrapper.appendChild(thumb);
            wrapper.appendChild(delBtn);
            wrapper.appendChild(note);
            strip.appendChild(wrapper);
          });

          tdImg.appendChild(strip);
        }

        // Camera-level notes cell
        const tdNote = document.createElement("td");
        const cameraNoteArea = document.createElement("textarea");
        cameraNoteArea.className = "camera-note";
        cameraNoteArea.placeholder = "Camera-level notes…";
        cameraNoteArea.value = info.note || "";
        cameraNoteArea.addEventListener("blur", () => {
          const projNow = getCurrentProjectObj();
          if (!projNow.cameras[camId]) projNow.cameras[camId] = {};
          projNow.cameras[camId].name = info.name;
          projNow.cameras[camId].done = !!info.done;
          projNow.cameras[camId].note = cameraNoteArea.value;
          scheduleSave();
        });
        tdNote.appendChild(cameraNoteArea);

        // Actions column – delete camera record
        const tdActions = document.createElement("td");
        const deleteCamBtn = document.createElement("button");
        deleteCamBtn.textContent = "Delete";
        deleteCamBtn.title = "Delete this camera and all its images";

        deleteCamBtn.addEventListener("click", async () => {
          if (!editingUnlocked) {
            alert("Enable admin editing to delete cameras.");
            return;
          }

          if (!confirm(`Delete camera ${camId} and all associated images?`)) return;

          const projNow = getCurrentProjectObj();
          if (!projNow || !projNow.cameras || !projNow.cameras[camId]) {
            return;
          }

          const entry = projNow.cameras[camId];

          const pathsToDelete = collectImagePaths(entry);

          // Remove camera from DB state (including its camera-level note)
          delete projNow.cameras[camId];
          scheduleSave();
          renderCameraPanel();

          // Fire-and-forget delete in Storage
          for (const p of pathsToDelete) {
            try {
              await deleteObject(storageRef(storage, p));
            } catch (e) {
              console.warn("Failed to delete camera image from storage:", p, e);
            }
          }
        });

        tdActions.appendChild(deleteCamBtn);

        // Append all tds in order (must match <thead>)
        tr.appendChild(tdId);
        tr.appendChild(tdName);
        tr.appendChild(tdIp);
        tr.appendChild(tdMac);
        tr.appendChild(tdSwitch);
        tr.appendChild(tdDone);
        tr.appendChild(tdImg);
        tr.appendChild(tdNote);
        tr.appendChild(tdActions);

        cameraTableBodyEl.appendChild(tr);
      });

      // Apply current column visibility AFTER building the table
      applyCameraColumnVisibility();
      updateCameraStats();
    }

    // Render project links
    function renderProjectLinks() {
      projectLinksList.innerHTML = "";
      const proj = getCurrentProjectObj();
      if (!proj) {
        const li = document.createElement("li");
        li.style.color = "var(--text-muted)";
        li.textContent = "(No project selected)";
        projectLinksList.appendChild(li);
        return;
      }

      const links = Array.isArray(proj.links) ? proj.links : [];
      if (!links.length) {
        const li = document.createElement("li");
        li.style.color = "var(--text-muted)";
        li.textContent = "(No links added yet)";
        projectLinksList.appendChild(li);
        return;
      }

      const sortedLinks = links.slice().sort((a, b) => {
        const at = (a.title || "").toLowerCase();
        const bt = (b.title || "").toLowerCase();
        if (at < bt) return -1;
        if (at > bt) return 1;
        return 0;
      });

      sortedLinks.forEach((link) => {
        const li = document.createElement("li");
        li.style.display = "flex";
        li.style.alignItems = "center";
        li.style.justifyContent = "space-between";
        li.style.gap = "6px";
        li.style.marginBottom = "2px";

        const a = document.createElement("a");
        a.href = link.url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = link.title || link.url;
        a.style.color = "var(--accent)";
        a.style.textDecoration = "none";

        const btnWrap = document.createElement("span");

        if (editingUnlocked) {
          const delBtn = document.createElement("button");
          delBtn.textContent = "×";
          delBtn.title = "Remove this link";
          delBtn.style.borderRadius = "999px";
          delBtn.style.border = "1px solid var(--border-subtle)";
          delBtn.style.background = "#050814";
          delBtn.style.color = "var(--text)";
          delBtn.style.cursor = "pointer";
          delBtn.style.padding = "0 6px";
          delBtn.style.lineHeight = "16px";

          delBtn.addEventListener("click", () => {
            const projNow = getCurrentProjectObj();
            if (!projNow) return;

            const originalIndex = (projNow.links || []).findIndex(
              l => l.title === link.title && l.url === link.url
            );
            if (originalIndex >= 0) {
              projNow.links = projNow.links.slice();
              projNow.links.splice(originalIndex, 1);
              scheduleSave();
              renderProjectLinks();
            }
          });

          btnWrap.appendChild(delBtn);
        }

        li.appendChild(a);
        li.appendChild(btnWrap);
        projectLinksList.appendChild(li);
      });
    }

    // localStorage helpers for last project
    function saveLastProjectToLocalStorage() {
      if (!state.currentProjectKey || !state.currentProjectName) return;
      const payload = {
        key: state.currentProjectKey,
        name: state.currentProjectName,
        basePath: DATABASE_BASE_PATH
      };
      try {
        localStorage.setItem(LAST_PROJECT_STORAGE_KEY, JSON.stringify(payload));
      } catch (e) {
        console.warn("Could not save last project to localStorage:", e);
      }
    }

    async function restoreLastProjectForCurrentBasePath() {
      let raw;
      try {
        raw = localStorage.getItem(LAST_PROJECT_STORAGE_KEY);
      } catch (e) {
        console.warn("Could not read last project from localStorage:", e);
        return;
      }
      if (!raw) return;

      let parsed;
      try {
        parsed = JSON.parse(raw);
      } catch {
        return;
      }

      if (!parsed.key || !parsed.name) return;
      if (parsed.basePath && parsed.basePath !== DATABASE_BASE_PATH) return;

      state.currentProjectKey = parsed.key;
      state.currentProjectName = parsed.name;
      projectNameInput.value = parsed.name;

      try {
        await loadProjectFromFirebase(parsed.key, parsed.name);
        rerenderForCurrentProject();
      } catch (err) {
        console.error("Error restoring last project from Firebase:", err);
      }
    }

    // Image resize helper (HEIC-aware-ish, always JPG)
    function resizeImageToJpeg(file, maxWidth = 2048, quality = 0.9) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = () => {
          const img = new Image();

          img.onload = () => {
            let w = img.width;
            let h = img.height;

            if (w > maxWidth) {
              const scale = maxWidth / w;
              w = maxWidth;
              h = Math.round(h * scale);
            }

            const canvas = document.createElement("canvas");
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, w, h);

            canvas.toBlob(
              (blob) => {
                if (!blob) {
                  reject(new Error("Canvas toBlob() returned null"));
                  return;
                }
                resolve(blob);
              },
              "image/jpeg",
              quality
            );
          };

          img.onerror = () => {
            reject(
              new Error(
                "Browser couldn't decode this file (HEIC may not be supported in this browser)."
              )
            );
          };

          img.src = reader.result;
        };

        reader.onerror = () => {
          reject(reader.error || new Error("FileReader failed while reading image."));
        };

        reader.readAsDataURL(file);
      });
    }

    // Discover all "owner" roots that contain walmartProjectTracker data
    async function fetchAvailableBasePaths() {
      try {
        const rootRef = ref(database);
        const snap = await get(rootRef);
        if (!snap.exists()) return [];

        const data = snap.val();
        const paths = [];

        Object.keys(data).forEach((key) => {
          const node = data[key];
          if (node && typeof node === "object" && node.walmartProjectTracker) {
            paths.push(key);
          }
        });

        // Sort just to keep the prompt readable
        paths.sort();
        return paths;
      } catch (err) {
        console.error("Error fetching available base paths:", err);
        return [];
      }
    }

    // Switch DATABASE_BASE_PATH and reload project data for that owner
    async function switchDatabaseBasePath(newBase) {
      if (!newBase) return;

      DATABASE_BASE_PATH = newBase;
      console.log("[admin] switched DATABASE_BASE_PATH to", DATABASE_BASE_PATH);

      // Reset in-memory cache so we don't mix owners
      state.projects = {};

      // Try to reload current project (if any) from the new base path
      if (state.currentProjectKey && state.currentProjectName) {
        try {
          await loadProjectFromFirebase(state.currentProjectKey, state.currentProjectName);
        } catch (err) {
          console.error("Error loading project for new base path:", err);
        }
      } else {
        await restoreLastProjectForCurrentBasePath();
      }

      rerenderForCurrentProject();
    }

    function updateCameraStats() {
      const proj = getCurrentProjectObj();

      // Grab DOM elements (some may not exist depending on where we are)
      const camDoneSpan = document.getElementById("camDoneCount");
      const camNotDoneSpan = document.getElementById("camNotDoneCount");
      const sidebarSummarySpan = document.getElementById("sidebarCameraSummary");

      if (!proj) {
        if (camDoneSpan) camDoneSpan.textContent = "0";
        if (camNotDoneSpan) camNotDoneSpan.textContent = "0";
        if (sidebarSummarySpan) sidebarSummarySpan.textContent = "0 done / 0 total";
        return;
      }

      const cameras = proj.cameras || {};
      let done = 0;
      let notDone = 0;

      Object.values(cameras).forEach(cam => {
        if (cam && cam.done) done++;
        else notDone++;
      });

      const total = done + notDone;

      if (camDoneSpan) camDoneSpan.textContent = done;
      if (camNotDoneSpan) camNotDoneSpan.textContent = notDone;

      if (sidebarSummarySpan) {
        sidebarSummarySpan.textContent = `${done} done / ${total} total`;
      }
    }

    // ----- Event bindings -----

    // Allow pressing Enter to trigger "Set"
    projectNameInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        setProjectBtn.click();
      }
    });

    detailTabButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        detailTabButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const panel = btn.dataset.panel;
        alarmPanelEl.classList.add("hidden");
        cameraPanelEl.classList.add("hidden");
        speakersPanelEl.classList.add("hidden");
        if (panel === "alarm") alarmPanelEl.classList.remove("hidden");
        if (panel === "cameras") cameraPanelEl.classList.remove("hidden");
        if (panel === "speakers") speakersPanelEl.classList.remove("hidden");
      });
    });

    if (hideDoneCamerasCheckbox) {
      hideDoneCamerasCheckbox.addEventListener("change", () => {
        hideDoneCameras = hideDoneCamerasCheckbox.checked;
        renderCameraPanel();
      });
    }

    if (hideDoneAlarmsCheckbox) {
      hideDoneAlarmsCheckbox.addEventListener("change", () => {
        hideDoneAlarms = hideDoneAlarmsCheckbox.checked;
        renderAlarmPanel();
      });
    }

    // Set project
    setProjectBtn.addEventListener("click", async () => {
      const name = projectNameInput.value.trim();
      if (!name) {
        alert("Enter a project name or store ID (e.g. WM1234 – City).");
        return;
      }
      const key = sanitizeProjectKey(name);
      state.currentProjectName = name;
      state.currentProjectKey = key;

      try {
        await loadProjectFromFirebase(key, name);
      } catch (err) {
        console.error("Error loading project from Firebase", err);
        alert("Could not load project from Firebase. Check console/logs.");
        return;
      }

      saveLastProjectToLocalStorage();

      rerenderForCurrentProject();
    });

    // Clear checklist (keep notes + images)
    clearProjectBtn.addEventListener("click", () => {
      if (!state.currentProjectKey) {
        alert("No project selected.");
        return;
      }
      if (!confirm("Clear all scope checklist checkmarks for the current project? Notes, alarm points, and cameras will be kept.")) return;
      const proj = getCurrentProjectObj();
      proj.tasks = {};
      scheduleSave();
      rerenderForCurrentProject();
    });

    // Section notes – save on blur (click-out)
    sectionNotesEl.addEventListener("blur", () => {
      const proj = getCurrentProjectObj();
      if (!proj || !activeSectionId) return;
      proj.notes[activeSectionId] = sectionNotesEl.value;
      scheduleSave();
    });

    // Alarm form
    alarmFormEl.addEventListener("submit", e => {
      e.preventDefault();
      const proj = getCurrentProjectObj();
      if (!proj) {
        alert("Set a project first.");
        return;
      }
      const num = alarmPointNumberEl.value.trim();
      const name = alarmPointNameEl.value.trim();
      if (!num || !name) {
        alert("Point # and name are required.");
        return;
      }
      if (!proj.alarmPoints[num]) proj.alarmPoints[num] = {};
      proj.alarmPoints[num].name = name;
      proj.alarmPoints[num].done = proj.alarmPoints[num].done || false;
      scheduleSave();
      alarmPointNumberEl.value = "";
      alarmPointNameEl.value = "";
      renderAlarmPanel();
    });

    // Camera form
    cameraFormEl.addEventListener("submit", e => {
      e.preventDefault();
      const proj = getCurrentProjectObj();
      if (!proj) {
        alert("Set a project first.");
        return;
      }
      const id = cameraIdEl.value.trim();
      const name = cameraNameEl.value.trim();
      if (!id || !name) {
        alert("Camera ID and name are required.");
        return;
      }
      if (!proj.cameras[id]) proj.cameras[id] = {};
      proj.cameras[id].name = name;
      proj.cameras[id].done = proj.cameras[id].done || false;
      scheduleSave();
      cameraIdEl.value = "";
      cameraNameEl.value = "";
      renderCameraPanel();
    });

    // Speaker form
    speakerFormEl.addEventListener("submit", e => {
      e.preventDefault();
      const proj = getCurrentProjectObj();
      if (!proj) {
        alert("Set a project first.");
        return;
      }

      const num = speakerNumberEl.value.trim();
      const name = speakerNameEl.value.trim();

      if (!num || !name) {
        alert("Speaker # and name are required.");
        return;
      }

      if (!proj.speakers[num]) proj.speakers[num] = {};
      proj.speakers[num].name = name;
      proj.speakers[num].note = proj.speakers[num].note || "";

      scheduleSave();

      speakerNumberEl.value = "";
      speakerNameEl.value = "";
      renderSpeakersPanel();
    });

    // Project links form – add link (admin only)
    if (projectLinksForm) {
      projectLinksForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const proj = getCurrentProjectObj();
        if (!proj) {
          alert("Set a project first.");
          return;
        }
        const title = linkTitleInput.value.trim();
        const url = linkUrlInput.value.trim();
        if (!title || !url) {
          alert("Title and URL are required.");
          return;
        }

        try {
          new URL(url);
        } catch {
          alert("Please enter a valid URL (include https://).");
          return;
        }

        proj.links = proj.links || [];
        proj.links.push({ title, url });
        linkTitleInput.value = "";
        linkUrlInput.value = "";
        scheduleSave();
        renderProjectLinks();
      });
    }

    enableImageEditCheckbox.addEventListener("change", async () => {
      if (enableImageEditCheckbox.checked) {
        const pwd = prompt("Enter admin password to enable editing and select data owner:");
        if (pwd === "telaidadmin") {
          editingUnlocked = true;

          // Show the project links input section in admin mode
          if (projectLinksForm) {
            projectLinksForm.classList.remove("hidden");
          }

          // Fetch available base paths dynamically from Firebase
          let options = await fetchAvailableBasePaths();

          // Fallback if none found (e.g. no data yet or permissions limited)
          if (!options || !options.length) {
            options = [DATABASE_BASE_PATH, "public", "share"];
          }

          const optionsText = options
            .map((opt, idx) => `${idx + 1}) ${opt}`)
            .join("\n");

          const selection = prompt(
            "Select data owner to load job info from:\n" +
            optionsText +
            "\n\nEnter the number (or leave blank to keep current path).",
            ""
          );

          const idx = selection ? parseInt(selection, 10) : NaN;
          if (!isNaN(idx) && idx >= 1 && idx <= options.length) {
            const chosenBase = options[idx - 1];
            await switchDatabaseBasePath(chosenBase);
          } else if (selection) {
            alert("Invalid selection. Keeping current data owner path.");
          }

          renderAlarmPanel();
          renderCameraPanel();
          renderSpeakersPanel();
          renderProjectLinks();
        } else {
          editingUnlocked = false;
          enableImageEditCheckbox.checked = false;

          // Hide the form again on wrong password
          if (projectLinksForm) {
            projectLinksForm.classList.add("hidden");
          }

          alert("Incorrect password. Image note editing remains locked.");
        }
      } else {
        // Turn admin mode off – just lock editing; path stays as-is until auth listener runs
        editingUnlocked = false;

        // Hide the project links input section when admin is off
        if (projectLinksForm) {
          projectLinksForm.classList.add("hidden");
        }

        renderAlarmPanel();
        renderCameraPanel();
        renderSpeakersPanel();
        renderProjectLinks();
      }
    });

    // Upload alarm/camera/task image, with resize + JPG conversion and note support
    imageUploadInputEl.addEventListener("change", async () => {
      const file = imageUploadInputEl.files[0];
      if (!file || !pendingUploadTarget || !state.currentProjectKey) return;

      const projKey = state.currentProjectKey;
      const { kind, key } = pendingUploadTarget;
      pendingUploadTarget = null;

      try {
        console.log("[upload] start", { projKey, kind, key, fileName: file.name, basePath: DATABASE_BASE_PATH });

        const resizedBlob = await resizeImageToJpeg(file, 2048, 0.9);

        const proj = getCurrentProjectObj();

        let target;

        if (kind === "alarm") {
          if (!proj.alarmPoints[key]) proj.alarmPoints[key] = {};
          target = proj.alarmPoints[key];
        } else if (kind === "camera") {
          if (!proj.cameras[key]) proj.cameras[key] = {};
          target = proj.cameras[key];
        } else if (kind === "task") {
          if (!proj.tasks[key] || typeof proj.tasks[key] !== "object") {
            const existingVal = proj.tasks[key];
            proj.tasks[key] = {
              done: !!(existingVal && (typeof existingVal === "object" ? existingVal.done : existingVal))
            };
          }
          target = proj.tasks[key];
        } else {
          alert("Unknown upload target type.");
          return;
        }

        const existingImages = normalizeImagesArray(target);
        const existingCount = existingImages.length;

        const originalBase = file.name.replace(/\.[^/.]+$/, "");

        const indexSuffix = existingCount > 0 ? `_${existingCount + 1}` : "";
        const fileName = `${key}_${originalBase}${indexSuffix}.jpg`;

        const path = `${DATABASE_BASE_PATH}/images/walmartProjectTracker/${projKey}/${kind}/${fileName}`;

        console.log("[upload] storage path:", path);

        if (!storage || !storageRef) {
          console.error("[upload] storage or storageRef missing", { storage, storageRef });
          alert("Storage is not initialized correctly. Check firebase-init.js exports.");
          return;
        }

        const sRef = storageRef(storage, path);
        await uploadBytes(sRef, resizedBlob, { contentType: "image/jpeg" });
        const url = await getDownloadURL(sRef);

        console.log("[upload] upload complete, url =", url);

        const imagesArr = normalizeImagesArray(target);
        imagesArr.push({ url, path, note: "" });

        if (kind === "alarm") {
          renderAlarmPanel();
        } else if (kind === "camera") {
          renderCameraPanel();
        } else if (kind === "task") {
          renderSection(activeSectionId);
        }

        scheduleSave();
      } catch (err) {
        console.error("Image upload failed", err);

        let msg = "Image upload failed.";
        if (err.code === "storage/unauthorized") {
          msg += " Your Firebase Storage rules may not allow writing to this path.";
        } else if (err.message && err.message.includes("HEIC")) {
          msg += " If this was a HEIC file, your browser might not support decoding that format.";
        }

        alert(msg);
      }
    });

    // ----- Init camera column toggles -----
    initCameraColumnToggles();

    // ----- Auth / init -----
    onAuthStateChanged(auth, async (user) => {
      // Only auto-switch base path when NOT in admin override mode
      if (!editingUnlocked) {
        DATABASE_BASE_PATH = user ? `${user.uid}` : 'public';
      }

      console.log("[auth] DATABASE_BASE_PATH:", DATABASE_BASE_PATH);

      // Reload project data for this base path
      if (state.currentProjectKey && state.currentProjectName) {
        try {
          await loadProjectFromFirebase(state.currentProjectKey, state.currentProjectName);
        } catch (err) {
          console.error("Error reloading project after auth change:", err);
        }
      } else {
        await restoreLastProjectForCurrentBasePath();
      }

      // Now load correct section set:
      await loadSections(!!user);
    });

    console.log("[auth] DATABASE_BASE_PATH:", DATABASE_BASE_PATH);
  </script>
</body>

</html>