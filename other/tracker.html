<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Job Information Manager</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Auth / login UI -->
  <script type="module" src="../apps/assets/js/login.js" defer></script>

  <!-- Your existing CSS (walmart-tracker look) -->
  <link rel="stylesheet" href="./assets/css/tracker.css" />
</head>

<body>

  <header>
    <h1>Job Tracker</h1>

    <div class="header-login">
      <div id="login-section">
        <form id="login-form" class="login-form">
          <input type="email" id="username" placeholder="Email" required>
          <input type="password" id="password" placeholder="Password" required>
          <button type="submit" class="login-btn">Login</button>
        </form>
        <button id="logout" class="logout-btn" style="display:none;">Logout</button>
      </div>
    </div>
  </header>

  <main>
    <div class="app-shell">

      <!-- SIDEBAR -->
      <aside class="sidebar card">

        <div class="main-header">
          <div id="sectionTitle">Select a project</div>
          <div id="sectionMeta"></div>
        </div>

        <!-- Site name (saved to record.customerName) -->
        <div class="row">
          <div class="field" style="flex:1;">
            <label for="siteNameInput">Site Name</label>
            <input type="text" id="siteNameInput" placeholder="Enter site name..." />
          </div>
        </div>

        <div class="sidebar-header">

          <div class="field">
            <label for="projectDropdown">Select existing project:</label>
            <select id="projectDropdown" class="project-link-input">
              <option value="">(loading...)</option>
            </select>
          </div>

          <div class="project-row">
            <input id="projectNameInput" placeholder="New project" />
            <button id="setProjectBtn" type="button">Create</button>
          </div>

          <br>

          <!-- ✅ Export / Import -->
          <div class="row" style="gap:8px; flex-wrap:wrap;">
            <button id="exportCsvBtn" type="button">Export CSV</button>
            <button id="importCsvBtn" type="button">Import CSV</button>
          </div>
          <input type="file" id="csvImportInput" accept=".csv,text/csv" class="hidden" />

          <br>

          <div class="row">
            <button id="clearAppDataBtn" type="button" class="danger-btn">Clear App Data</button>
          </div>

          <br>

          <div class="pill-sub">
            Data path: <code id="dataPathLabel">public</code>
          </div>

          <!-- Project links -->
          <div class="project-links-card">
            <div class="project-links-header">Project links</div>
            <ul id="projectLinksList" class="project-links-list"></ul>

            <form id="projectLinksForm" class="project-links-form">
              <input type="text" id="projectLinkTitle" placeholder="Title" class="project-link-input">
              <input type="url" id="projectLinkUrl" placeholder="URL (https://...)" class="project-link-input">
              <button type="submit" class="project-link-add-btn">Add</button>
            </form>
          </div>

          <div class="progress-row">
            <span>Items summary</span>
            <span id="sidebarSummary">0 daily tasks • 0 lists • 0 items</span>
          </div>
        </div>

        <!-- Pills -->
        <div class="pill-list" id="sectionList"></div>
      </aside>

      <!-- MAIN CONTENT -->
      <main class="main card">

        <!-- Global search -->
        <div class="camera-search-row">
          <input type="text" id="globalSearchInput"
            placeholder="Search daily tasks + list items (id, model, type, location, status, IP, MAC, notes)…">
        </div>

        <!-- DAILY TASKS PANEL -->
        <div id="dailyTasksPanel" class="detail-panel hidden">
          <div class="card">
            <div class="panel-toolbar">
              <div><strong>Daily Tasks / Notes</strong> <span class="small-muted" id="dailyTasksCountLabel"></span>
              </div>
            </div>

            <div style="overflow:auto;">
              <table class="detail-table" id="dailyTasksTable">
                <thead>
                  <tr>
                    <th style="width:180px;">Date/Time</th>
                    <th>Notes</th>
                    <th style="width:240px;">Images</th>
                    <th style="width:160px;">Actions</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>

            <hr />

            <div class="panel-toolbar">
              <div><strong>Add new daily task</strong></div>
            </div>

            <div class="row">
              <input type="datetime-local" id="newDailyTaskDate" />
              <input type="text" id="newDailyTaskNotes" placeholder="Notes..." />
              <button id="addDailyTaskBtn" type="button">Add</button>
            </div>
          </div>
        </div>

        <!-- LISTS PANEL -->
        <div id="listsPanel" class="detail-panel hidden">
          <div class="card">

            <div class="panel-toolbar">
              <div>
                <strong id="activeListTitle">List</strong>
                <span class="small-muted" id="activeListCountLabel"></span>
              </div>

              <div class="inline-btns">
                <button id="deleteListBtn" type="button" class="danger-btn">Delete List</button>
              </div>
            </div>

            <div class="row" style="align-items:flex-end;">
              <div class="field" style="flex:1;">
                <label for="newListName">Create new list</label>
                <input id="newListName" placeholder="e.g. Cameras, Controllers, Maglocks..." />
              </div>
              <button id="createListBtn" type="button">Create</button>
            </div>

            <hr />

            <div class="panel-toolbar">
              <div><strong>Add item to this list</strong></div>
            </div>

            <div class="row" style="flex-wrap:wrap;">
              <input id="item_id" placeholder="ID (key)" style="width:140px;" />
              <input id="item_model" placeholder="Model" />
              <input id="item_type" placeholder="Type" />
              <input id="item_location" placeholder="Location" />
              <input id="item_status" placeholder="Status" />
              <input id="item_ip" placeholder="IP" style="width:160px;" />
              <input id="item_mac" placeholder="MAC" style="width:190px;" />
              <button id="addItemBtn" type="button">Add Item</button>
            </div>

            <div style="overflow:auto; margin-top:8px;">
              <table class="detail-table" id="activeListTable">
                <thead>
                  <tr>
                    <th style="width:120px;">ID</th>
                    <th>Model</th>
                    <th>Type</th>
                    <th>Location</th>
                    <th>Status</th>
                    <th style="width:150px;">IP</th>
                    <th style="width:170px;">MAC</th>
                    <th style="width:240px;">Images</th>
                    <th style="width:210px;">Actions</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>

          </div>
        </div>

        <!-- Shared hidden file input (images) -->
        <input type="file" id="imageUploadInput" accept="image/*" class="hidden" />
      </main>

    </div>
  </main>

  <script type="module">
    import {
      auth,
      onAuthStateChanged,
      database,
      storage,
      ref,
      set,
      update,
      remove,
      get,
      onValue,
      off,
      storageRef,
      uploadBytes,
      getDownloadURL,
      deleteObject
    } from "../apps/assets/js/firebase-init.js";

    // ============================
    // Config / Paths
    // ============================
    let DATABASE_BASE_PATH = "public";
    const TASKS_ROOT = () => `${DATABASE_BASE_PATH}/tasks`;
    const RECORD_PATH = (id) => `${TASKS_ROOT()}/${id}`;

    // ============================
    // State
    // ============================
    const state = {
      recordId: "",
      activePanel: "daily", // daily | lists
      activeListId: "",
      globalQuery: "",

      projectFieldName: "",
      customerName: "",
      meta: { updatedAt: 0 },
      links: [],
      lists: {},
      daily: {},

      listeners: {
        recordRef: null,
        recordCb: null,
        dropdownRef: null,
        dropdownCb: null
      }
    };

    // ============================
    // DOM
    // ============================
    const $ = (id) => document.getElementById(id);

    const sectionListEl = $("sectionList");
    const sectionTitleEl = $("sectionTitle");
    const sectionMetaEl = $("sectionMeta");

    const projectDropdown = $("projectDropdown");
    const projectNameInput = $("projectNameInput");
    const setProjectBtn = $("setProjectBtn");
    const clearAppDataBtn = $("clearAppDataBtn");

    const exportCsvBtn = $("exportCsvBtn");
    const importCsvBtn = $("importCsvBtn");
    const csvImportInput = $("csvImportInput");

    const sidebarSummary = $("sidebarSummary");
    const dataPathLabel = $("dataPathLabel");
    const globalSearchInput = $("globalSearchInput");

    const siteNameInput = $("siteNameInput");

    const dailyTasksPanel = $("dailyTasksPanel");
    const listsPanel = $("listsPanel");

    const dailyTasksTableBody = document.querySelector("#dailyTasksTable tbody");
    const dailyTasksCountLabel = $("dailyTasksCountLabel");
    const newDailyTaskDate = $("newDailyTaskDate");
    const newDailyTaskNotes = $("newDailyTaskNotes");
    const addDailyTaskBtn = $("addDailyTaskBtn");

    const projectLinksList = $("projectLinksList");
    const projectLinksForm = $("projectLinksForm");
    const projectLinkTitle = $("projectLinkTitle");
    const projectLinkUrl = $("projectLinkUrl");

    const activeListTitle = $("activeListTitle");
    const activeListCountLabel = $("activeListCountLabel");
    const newListName = $("newListName");
    const createListBtn = $("createListBtn");
    const deleteListBtn = $("deleteListBtn");

    const itemInputs = {
      id: $("item_id"),
      model: $("item_model"),
      type: $("item_type"),
      location: $("item_location"),
      status: $("item_status"),
      ip: $("item_ip"),
      mac: $("item_mac"),
    };
    const addItemBtn = $("addItemBtn");
    const activeListTableBody = document.querySelector("#activeListTable tbody");

    const imageUploadInput = $("imageUploadInput");
    let pendingUploadTarget = null; // { kind:'daily'|'listItem', dailyKey?, listId?, itemId? }

    // ============================
    // LocalStorage (per base path)
    // ============================
    const LS_KEY = () => `jobInfoManager:lastOpen:${DATABASE_BASE_PATH}`;

    function loadLastOpenState() {
      try {
        const raw = localStorage.getItem(LS_KEY());
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch {
        return {};
      }
    }

    function saveLastOpenState(patch = {}) {
      try {
        const current = loadLastOpenState();
        const next = {
          recordId: state.recordId || "",
          activePanel: state.activePanel || "daily",
          activeListId: state.activeListId || "",
          globalQuery: state.globalQuery || "",
          ...current,
          ...patch,
          savedAt: Date.now()
        };
        localStorage.setItem(LS_KEY(), JSON.stringify(next));
      } catch (e) {
        console.warn("localStorage save failed:", e);
      }
    }

    function clearLastOpenState() {
      try { localStorage.removeItem(LS_KEY()); } catch { }
    }

    // ============================
    // Utils
    // ============================
    const RESERVED_LIST_KEYS = new Set(["_name", "createdAt", "meta", "items"]);

    function dbRef(path) { return ref(database, path); }

    function sanitizeKey(name) {
      return String(name || "")
        .trim()
        .toLowerCase()
        .replace(/[.#$/\[\]]/g, "_")
        .replace(/\s+/g, "_");
    }

    function getListItems(listObj) {
      if (!listObj || typeof listObj !== "object") return {};
      const out = {};
      for (const [k, v] of Object.entries(listObj)) {
        if (RESERVED_LIST_KEYS.has(k)) continue;
        out[k] = v;
      }
      return out;
    }

    function ensureImagesArray(obj) {
      if (!obj) return [];
      if (!Array.isArray(obj.images)) obj.images = [];
      return obj.images;
    }

    function collectImagePaths(obj) {
      const out = [];
      if (!obj) return out;
      if (Array.isArray(obj.images)) obj.images.forEach(img => { if (img?.path) out.push(img.path); });
      return out;
    }

    function matchesAny(...vals) {
      const q = (state.globalQuery || "").trim().toLowerCase();
      if (!q) return true;
      return vals.some(v => String(v || "").toLowerCase().includes(q));
    }

    function debounce(fn, wait = 120) {
      let t = null;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    function storageImagePath({ kind, dailyKey, listId, itemId }) {
      const ts = Date.now();
      if (kind === "daily") {
        return `${DATABASE_BASE_PATH}/tasks/${state.recordId}/daily/${encodeURIComponent(dailyKey)}/${ts}.jpg`;
      }
      return `${DATABASE_BASE_PATH}/tasks/${state.recordId}/lists/${listId}/${itemId}/${ts}.jpg`;
    }

    function resizeImageToJpeg(file, maxWidth = 2048, quality = 0.9) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => {
            let w = img.width, h = img.height;
            if (w > maxWidth) {
              const s = maxWidth / w;
              w = maxWidth;
              h = Math.round(h * s);
            }
            const canvas = document.createElement("canvas");
            canvas.width = w; canvas.height = h;
            canvas.getContext("2d").drawImage(img, 0, 0, w, h);
            canvas.toBlob(
              (blob) => blob ? resolve(blob) : reject(new Error("toBlob returned null")),
              "image/jpeg",
              quality
            );
          };
          img.onerror = () => reject(new Error("Image decode failed"));
          img.src = reader.result;
        };
        reader.onerror = () => reject(reader.error || new Error("FileReader failed"));
        reader.readAsDataURL(file);
      });
    }

    async function touchRecord() {
      if (!state.recordId) return;
      await update(dbRef(`${RECORD_PATH(state.recordId)}/meta`), { updatedAt: Date.now() });
    }

    async function dbUpdate(path, patch, touch = true) {
      await update(dbRef(path), patch);
      if (touch) await touchRecord();
    }

    async function dbSet(path, value, touch = true) {
      await set(dbRef(path), value);
      if (touch) await touchRecord();
    }

    async function dbRemove(path, touch = true) {
      await remove(dbRef(path));
      if (touch) await touchRecord();
    }

    // ============================
    // CSV helpers + Export / Import
    // ============================
    function csvEscape(val) {
      const s = String(val ?? "");
      if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }

    function toCsv(rows, header) {
      const lines = [];
      lines.push(header.map(csvEscape).join(","));
      for (const r of rows) {
        lines.push(header.map(h => csvEscape(r[h])).join(","));
      }
      return lines.join("\n");
    }

    // Minimal CSV parser that handles quotes/commas/newlines
    function parseCsv(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let i = 0;
      let inQuotes = false;

      while (i < text.length) {
        const ch = text[i];

        if (inQuotes) {
          if (ch === '"') {
            if (text[i + 1] === '"') { cur += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          cur += ch; i++; continue;
        }

        if (ch === '"') { inQuotes = true; i++; continue; }
        if (ch === ",") { row.push(cur); cur = ""; i++; continue; }
        if (ch === "\n") { row.push(cur); rows.push(row); row = []; cur = ""; i++; continue; }
        if (ch === "\r") { i++; continue; }

        cur += ch; i++;
      }

      row.push(cur);
      rows.push(row);
      return rows;
    }

    function downloadTextFile(filename, text) {
      const blob = new Blob([text], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function buildExportRows() {
      const rows = [];

      // DAILY TASKS
      for (const [key, v] of Object.entries(state.daily || {})) {
        const images = Array.isArray(v?.images) ? v.images : [];
        rows.push({
          kind: "daily",
          projectId: state.recordId,
          project: state.projectFieldName || "",
          customerName: state.customerName || "",
          listId: "",
          itemKey: key,
          id: "",
          date: v?.date || key || "",
          notes: v?.notes || "",
          model: "",
          type: "",
          location: "",
          status: "",
          ip: "",
          mac: "",
          itemNotes: "",
          imageUrls: images.map(x => x?.url || "").filter(Boolean).join("|"),
          imageNotes: images.map(x => x?.note || "").join("|")
        });
      }

      // LIST ITEMS (all lists)
      for (const [listId, listObj] of Object.entries(state.lists || {})) {
        const items = getListItems(listObj);
        for (const [itemKey, v] of Object.entries(items)) {
          const images = Array.isArray(v?.images) ? v.images : [];
          rows.push({
            kind: "listItem",
            projectId: state.recordId,
            project: state.projectFieldName || "",
            customerName: state.customerName || "",
            listId,
            itemKey,
            id: v?.id ?? itemKey,
            date: "",
            notes: "",
            model: v?.model || "",
            type: v?.type || "",
            location: v?.location || "",
            status: v?.status || "",
            ip: v?.ip || "",
            mac: v?.mac || "",
            itemNotes: v?.notes || "",
            imageUrls: images.map(x => x?.url || "").filter(Boolean).join("|"),
            imageNotes: images.map(x => x?.note || "").join("|")
          });
        }
      }

      return rows;
    }

    async function exportCsv() {
      if (!state.recordId) return alert("Select a project first.");

      const header = [
        "kind",
        "projectId",
        "project",
        "customerName",
        "listId",
        "itemKey",
        "id",
        "date",
        "notes",
        "model",
        "type",
        "location",
        "status",
        "ip",
        "mac",
        "itemNotes",
        "imageUrls",
        "imageNotes"
      ];

      const rows = buildExportRows();
      const csv = toCsv(rows, header);

      const safeName = (state.projectFieldName || state.recordId || "project")
        .replace(/[^\w\-]+/g, "_")
        .slice(0, 60);

      downloadTextFile(`job_tracker_${safeName}.csv`, csv);
    }

    async function importCsvText(csvText) {
      if (!state.recordId) return alert("Select a project first.");

      const parsed = parseCsv(csvText.trim());
      if (!parsed.length) return alert("CSV looks empty.");

      const header = parsed[0].map(h => String(h || "").trim());
      const idx = (name) => header.indexOf(name);

      if (idx("kind") < 0) return alert('CSV missing required column: "kind".');

      const basePath = RECORD_PATH(state.recordId);
      let importedDaily = 0;
      let importedItems = 0;

      const patch = {};

      // Optional: let the CSV set customerName/project if provided (non-blank)
      const firstDataRow = parsed[1] || [];
      const csvProject = firstDataRow[idx("project")] || "";
      const csvCustomer = firstDataRow[idx("customerName")] || "";
      if (csvProject && !state.projectFieldName) patch["project"] = csvProject;
      if (csvCustomer) patch["customerName"] = csvCustomer;

      for (let r = 1; r < parsed.length; r++) {
        const row = parsed[r];
        if (!row || (row.length === 1 && !row[0])) continue;

        const kind = row[idx("kind")] || "";

        if (kind === "daily") {
          const itemKey = row[idx("itemKey")] || row[idx("date")] || "";
          if (!itemKey) continue;

          const date = row[idx("date")] || itemKey;
          const notes = row[idx("notes")] || "";

          const urls = (row[idx("imageUrls")] || "").split("|").filter(Boolean);
          const notesArr = (row[idx("imageNotes")] || "").split("|");
          const images = urls.map((u, i) => ({ url: u, path: "", note: notesArr[i] || "" }));

          patch[`tasks/${itemKey}`] = { date, notes, images };
          importedDaily++;
        }

        if (kind === "listItem") {
          const listId = row[idx("listId")] || "";
          const itemKey = row[idx("itemKey")] || row[idx("id")] || "";
          if (!listId || !itemKey) continue;

          const idVal = row[idx("id")] || itemKey;

          const urls = (row[idx("imageUrls")] || "").split("|").filter(Boolean);
          const notesArr = (row[idx("imageNotes")] || "").split("|");
          const images = urls.map((u, i) => ({ url: u, path: "", note: notesArr[i] || "" }));

          patch[`lists/${listId}/${itemKey}`] = {
            id: idVal,
            model: row[idx("model")] || "",
            type: row[idx("type")] || "",
            location: row[idx("location")] || "",
            status: row[idx("status")] || "",
            ip: row[idx("ip")] || "",
            mac: row[idx("mac")] || "",
            notes: row[idx("itemNotes")] || "",
            images
          };

          // ensure list meta exists if it doesn't (won't overwrite existing)
          if (!state.lists?.[listId]) {
            patch[`lists/${listId}/_name`] = listId;
            patch[`lists/${listId}/createdAt`] = Date.now();
          }

          importedItems++;
        }
      }

      await update(dbRef(basePath), patch);
      await touchRecord();

      alert(`Imported: ${importedDaily} daily task(s), ${importedItems} list item(s).`);
    }

    // ============================
    // Listener management
    // ============================
    function detachRecordListener() {
      const { recordRef, recordCb } = state.listeners;
      if (recordRef && recordCb) {
        try { off(recordRef, "value", recordCb); } catch { }
      }
      state.listeners.recordRef = null;
      state.listeners.recordCb = null;
    }

    function detachDropdownListener() {
      const { dropdownRef, dropdownCb } = state.listeners;
      if (dropdownRef && dropdownCb) {
        try { off(dropdownRef, "value", dropdownCb); } catch { }
      }
      state.listeners.dropdownRef = null;
      state.listeners.dropdownCb = null;
    }

    // ============================
    // Panels / Header
    // ============================
    function setActivePanel(panel) {
      state.activePanel = panel;

      dailyTasksPanel.classList.toggle("hidden", panel !== "daily");
      listsPanel.classList.toggle("hidden", panel !== "lists");

      saveLastOpenState({ activePanel: panel, activeListId: state.activeListId || "" });

      renderHeader();
      renderSidebarPills();
      renderAll();
    }

    function renderHeader() {
      if (!state.recordId) {
        sectionTitleEl.textContent = "Select a project";
        sectionMetaEl.textContent = "";
        return;
      }

      const displayName = state.projectFieldName || state.recordId;
      const dailyCount = Object.keys(state.daily || {}).length;
      const listCount = Object.keys(state.lists || {}).length;

      if (state.activePanel === "daily") {
        sectionTitleEl.textContent = "Daily Tasks / Notes";
        sectionMetaEl.textContent = `Project: ${displayName} • ${dailyCount} daily task(s)`;
      } else {
        const listId = state.activeListId;
        const list = state.lists[listId] || {};
        const itemCount = Object.keys(getListItems(list)).length;
        sectionTitleEl.textContent = list?._name || listId || "List";
        sectionMetaEl.textContent = `Project: ${displayName} • ${itemCount} item(s) • ${listCount} list(s)`;
      }
    }

    function renderSidebarSummary() {
      const dailyCount = Object.keys(state.daily || {}).length;
      const listIds = Object.keys(state.lists || {});
      const listCount = listIds.length;
      const itemCount = listIds.reduce((acc, id) => acc + Object.keys(getListItems(state.lists[id])).length, 0);
      sidebarSummary.textContent = `${dailyCount} daily tasks • ${listCount} lists • ${itemCount} items`;
    }

    function renderSidebarPills() {
      sectionListEl.innerHTML = "";
      renderSidebarSummary();

      const makePill = ({ title, right, isActive, onClick }) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "section-pill" + (isActive ? " active" : "");
        btn.innerHTML = `
          <span class="label">${title}</span>
          <span class="pill-progress">
            <span class="pill-dot ${right === "✓" ? "done" : ""}"></span>
            <span>${right}</span>
          </span>
        `;
        btn.addEventListener("click", onClick);
        sectionListEl.appendChild(btn);
      };

      makePill({
        title: "Daily Tasks",
        right: String(Object.keys(state.daily || {}).length),
        isActive: state.activePanel === "daily",
        onClick: () => setActivePanel("daily")
      });

      const listIds = Object.keys(state.lists || {})
        .sort((a, b) => {
          const A = state.lists[a]?._name || a;
          const B = state.lists[b]?._name || b;
          return String(A).localeCompare(String(B), undefined, { sensitivity: "base" });
        });

      listIds.forEach(listId => {
        const listObj = state.lists[listId] || {};
        const count = Object.keys(getListItems(listObj)).length;
        makePill({
          title: listObj._name || listId,
          right: String(count),
          isActive: state.activePanel === "lists" && state.activeListId === listId,
          onClick: () => {
            state.activeListId = listId;
            saveLastOpenState({ activePanel: "lists", activeListId: listId });
            setActivePanel("lists");
          }
        });
      });

      if (!listIds.length) {
        makePill({
          title: "Lists",
          right: "0",
          isActive: state.activePanel === "lists",
          onClick: () => setActivePanel("lists")
        });
      }
    }

    // ============================
    // Project links
    // ============================
    function renderProjectLinks() {
      projectLinksList.innerHTML = "";

      if (!state.recordId) {
        const li = document.createElement("li");
        li.style.color = "var(--text-muted,#8d96a8)";
        li.textContent = "(No project selected)";
        projectLinksList.appendChild(li);
        return;
      }

      const links = Array.isArray(state.links) ? state.links : [];
      if (!links.length) {
        const li = document.createElement("li");
        li.style.color = "var(--text-muted,#8d96a8)";
        li.textContent = "(No links yet)";
        projectLinksList.appendChild(li);
        return;
      }

      const sorted = links.slice().sort((a, b) =>
        (a.title || "").localeCompare((b.title || ""), undefined, { sensitivity: "base" })
      );

      sorted.forEach((link) => {
        const li = document.createElement("li");
        li.style.display = "flex";
        li.style.alignItems = "center";
        li.style.justifyContent = "space-between";
        li.style.gap = "6px";

        const a = document.createElement("a");
        a.href = link.url;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = link.title || link.url;
        a.style.color = "var(--accent,#2f81f7)";
        a.style.textDecoration = "none";

        const del = document.createElement("button");
        del.textContent = "×";
        del.title = "Remove link";
        del.style.borderRadius = "999px";
        del.style.border = "1px solid var(--border-subtle,#202637)";
        del.style.background = "#050814";
        del.style.color = "var(--text,#e4e8f0)";
        del.style.cursor = "pointer";
        del.style.padding = "0 8px";

        del.addEventListener("click", async () => {
          const idx = (state.links || []).findIndex(l => l.title === link.title && l.url === link.url);
          if (idx < 0) return;
          const next = state.links.slice();
          next.splice(idx, 1);
          await dbUpdate(RECORD_PATH(state.recordId), { links: next });
        });

        li.appendChild(a);
        li.appendChild(del);
        projectLinksList.appendChild(li);
      });
    }

    // ============================
    // Thumb strip
    // ============================
    function renderThumbStrip({ images, onOpen, onDelete, onNoteBlur }) {
      const wrap = document.createElement("div");
      wrap.className = "thumb-strip";

      (Array.isArray(images) ? images : []).forEach((img, idx) => {
        const w = document.createElement("div");
        w.className = "thumb-wrapper";

        const thumb = document.createElement("img");
        thumb.className = "thumb-img";
        thumb.src = img.url;
        thumb.addEventListener("click", () => onOpen(img.url));

        const del = document.createElement("button");
        del.className = "thumb-delete";
        del.textContent = "×";
        del.addEventListener("click", () => onDelete(idx));

        const note = document.createElement("textarea");
        note.className = "thumb-note";
        note.rows = 2;
        note.placeholder = "Notes…";
        note.value = img.note || "";
        note.addEventListener("blur", () => onNoteBlur(idx, note.value));

        w.appendChild(thumb);
        w.appendChild(del);
        w.appendChild(note);
        wrap.appendChild(w);
      });

      return wrap;
    }

    // ============================
    // Daily tasks
    // ============================
    function renderDailyTasks() {
      dailyTasksTableBody.innerHTML = "";
      if (!state.recordId) return;

      const entries = Object.entries(state.daily || {})
        .map(([k, v]) => ({
          key: k,
          date: v?.date || "",
          notes: v?.notes || "",
          images: Array.isArray(v?.images) ? v.images : []
        }))
        .filter(t => matchesAny(t.key, t.date, t.notes))
        .sort((a, b) => String(b.date).localeCompare(String(a.date)));

      dailyTasksCountLabel.textContent = `(${entries.length})`;

      const basePath = RECORD_PATH(state.recordId);

      entries.forEach((t) => {
        const tr = document.createElement("tr");

        const tdDate = document.createElement("td");
        const dateInput = document.createElement("input");
        dateInput.type = "datetime-local";
        dateInput.value = t.date || "";
        dateInput.addEventListener("blur", async () => {
          await dbUpdate(`${basePath}/tasks/${t.key}`, { date: dateInput.value || "" });
        });
        tdDate.appendChild(dateInput);

        const tdNotes = document.createElement("td");
        const notesArea = document.createElement("textarea");
        notesArea.value = t.notes || "";
        notesArea.placeholder = "Notes...";
        notesArea.addEventListener("blur", async () => {
          await dbUpdate(`${basePath}/tasks/${t.key}`, { notes: notesArea.value || "" });
        });
        tdNotes.appendChild(notesArea);

        const tdImg = document.createElement("td");
        const addImgBtn = document.createElement("button");
        addImgBtn.textContent = "Add Image";
        addImgBtn.addEventListener("click", () => {
          pendingUploadTarget = { kind: "daily", dailyKey: t.key };
          imageUploadInput.value = "";
          imageUploadInput.click();
        });
        tdImg.appendChild(addImgBtn);

        tdImg.appendChild(renderThumbStrip({
          images: t.images,
          onOpen: (url) => window.open(url, "_blank"),
          onDelete: async (index) => {
            if (!confirm("Delete this image?")) return;

            const currentObj = state.daily[t.key] || {};
            const imgs = ensureImagesArray(currentObj).slice();
            const [removed] = imgs.splice(index, 1);

            await dbUpdate(`${basePath}/tasks/${t.key}`, { images: imgs });

            if (removed?.path) {
              try { await deleteObject(storageRef(storage, removed.path)); } catch (e) { console.warn(e); }
            }
          },
          onNoteBlur: async (index, noteVal) => {
            const currentObj = state.daily[t.key] || {};
            const imgs = ensureImagesArray(currentObj).slice();
            if (!imgs[index]) return;
            imgs[index].note = noteVal || "";
            await dbUpdate(`${basePath}/tasks/${t.key}`, { images: imgs });
          }
        }));

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.className = "danger-btn";
        delBtn.addEventListener("click", async () => {
          if (!confirm("Delete this daily task (and its images)?")) return;

          const currentObj = state.daily[t.key] || {};
          const paths = collectImagePaths(currentObj);

          await dbRemove(`${basePath}/tasks/${t.key}`);

          for (const p of paths) {
            try { await deleteObject(storageRef(storage, p)); } catch (e) { console.warn(e); }
          }
        });
        tdActions.appendChild(delBtn);

        tr.appendChild(tdDate);
        tr.appendChild(tdNotes);
        tr.appendChild(tdImg);
        tr.appendChild(tdActions);
        dailyTasksTableBody.appendChild(tr);
      });
    }

    async function addDailyTask() {
      if (!state.recordId) return alert("Select a project first.");

      const dt = (newDailyTaskDate.value || "").trim();
      const notes = (newDailyTaskNotes.value || "").trim();
      if (!dt || !notes) return alert("Enter a date/time and notes.");

      // If you ever want safer keys, swap to: const key = String(Date.now());
      const key = dt;

      await dbSet(`${RECORD_PATH(state.recordId)}/tasks/${key}`, { date: dt, notes, images: [] });

      newDailyTaskDate.value = "";
      newDailyTaskNotes.value = "";
    }

    // ============================
    // Lists
    // ============================
    function renderActiveList() {
      activeListTableBody.innerHTML = "";

      if (!state.recordId) {
        activeListTitle.textContent = "List";
        activeListCountLabel.textContent = "";
        return;
      }

      const listId = state.activeListId;
      const listObj = state.lists[listId];

      if (!listId || !listObj) {
        activeListTitle.textContent = "Lists";
        activeListCountLabel.textContent = " (create a list to begin)";
        return;
      }

      activeListTitle.textContent = listObj._name || listId;

      const itemsNode = getListItems(listObj);
      const rows = Object.entries(itemsNode)
        .map(([k, v]) => ({
          key: k,
          id: v?.id ?? k,
          model: v?.model || "",
          type: v?.type || "",
          location: v?.location || "",
          status: v?.status || "",
          ip: v?.ip || "",
          mac: v?.mac || "",
          notes: v?.notes || "",
          images: Array.isArray(v?.images) ? v.images : []
        }))
        .filter(r => matchesAny(r.key, r.id, r.model, r.type, r.location, r.status, r.ip, r.mac, r.notes))
        .sort((a, b) => String(a.id).localeCompare(String(b.id), undefined, { numeric: true }));

      activeListCountLabel.textContent = `(${rows.length})`;

      const basePath = RECORD_PATH(state.recordId);

      rows.forEach((r) => {
        const tr = document.createElement("tr");

        const mkTdInput = (val, onBlur) => {
          const td = document.createElement("td");
          const input = document.createElement("input");
          input.type = "text";
          input.value = val || "";
          input.addEventListener("blur", onBlur);
          td.appendChild(input);
          return { td, input };
        };

        const baseItemPath = `${basePath}/lists/${listId}/${r.key}`;

        const { td: tdId, input: idInput } = mkTdInput(r.id, async () => {
          await dbUpdate(baseItemPath, { id: idInput.value.trim() });
        });
        const { td: tdModel, input: modelInput } = mkTdInput(r.model, async () => {
          await dbUpdate(baseItemPath, { model: modelInput.value });
        });
        const { td: tdType, input: typeInput } = mkTdInput(r.type, async () => {
          await dbUpdate(baseItemPath, { type: typeInput.value });
        });
        const { td: tdLoc, input: locInput } = mkTdInput(r.location, async () => {
          await dbUpdate(baseItemPath, { location: locInput.value });
        });
        const { td: tdStatus, input: statusInput } = mkTdInput(r.status, async () => {
          await dbUpdate(baseItemPath, { status: statusInput.value });
        });
        const { td: tdIp, input: ipInput } = mkTdInput(r.ip, async () => {
          await dbUpdate(baseItemPath, { ip: ipInput.value });
        });
        const { td: tdMac, input: macInput } = mkTdInput(r.mac, async () => {
          await dbUpdate(baseItemPath, { mac: macInput.value });
        });

        const tdImg = document.createElement("td");
        const addImgBtn = document.createElement("button");
        addImgBtn.textContent = "Add Image";
        addImgBtn.addEventListener("click", () => {
          pendingUploadTarget = { kind: "listItem", listId, itemId: r.key };
          imageUploadInput.value = "";
          imageUploadInput.click();
        });
        tdImg.appendChild(addImgBtn);

        tdImg.appendChild(renderThumbStrip({
          images: r.images,
          onOpen: (url) => window.open(url, "_blank"),
          onDelete: async (index) => {
            if (!confirm("Delete this item image?")) return;

            const itemObj = getListItems(state.lists[listId] || {})[r.key] || {};
            const imgs = ensureImagesArray(itemObj).slice();
            const [removed] = imgs.splice(index, 1);

            await dbUpdate(baseItemPath, { images: imgs });

            if (removed?.path) {
              try { await deleteObject(storageRef(storage, removed.path)); } catch (e) { console.warn(e); }
            }
          },
          onNoteBlur: async (index, noteVal) => {
            const itemObj = getListItems(state.lists[listId] || {})[r.key] || {};
            const imgs = ensureImagesArray(itemObj).slice();
            if (!imgs[index]) return;
            imgs[index].note = noteVal || "";
            await dbUpdate(baseItemPath, { images: imgs });
          }
        }));

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.className = "danger-btn";
        delBtn.addEventListener("click", async () => {
          if (!confirm(`Delete item "${r.key}" (and images)?`)) return;

          const itemObj = getListItems(state.lists[listId] || {})[r.key] || {};
          const paths = collectImagePaths(itemObj);

          await dbRemove(baseItemPath);

          for (const p of paths) {
            try { await deleteObject(storageRef(storage, p)); } catch (e) { console.warn(e); }
          }
        });
        tdActions.appendChild(delBtn);

        tr.appendChild(tdId);
        tr.appendChild(tdModel);
        tr.appendChild(tdType);
        tr.appendChild(tdLoc);
        tr.appendChild(tdStatus);
        tr.appendChild(tdIp);
        tr.appendChild(tdMac);
        tr.appendChild(tdImg);
        tr.appendChild(tdActions);

        activeListTableBody.appendChild(tr);
      });
    }

    // ✅ FIXED: do NOT set {} (empty). RTDB may treat it as "no node".
    async function createList() {
      if (!state.recordId) return alert("Select a project first.");
      const name = (newListName.value || "").trim();
      if (!name) return alert("Enter a list name.");

      const listId = sanitizeKey(name);
      if (!listId) return alert("That list name becomes an invalid key. Try letters/numbers.");

      // If list exists, just switch to it (no overwrite)
      if (state.lists && Object.prototype.hasOwnProperty.call(state.lists, listId)) {
        state.activeListId = listId;
        saveLastOpenState({ activePanel: "lists", activeListId: listId });
        newListName.value = "";
        return setActivePanel("lists");
      }

      const now = Date.now();

      await dbSet(`${RECORD_PATH(state.recordId)}/lists/${listId}`, {
        _name: name,
        createdAt: now
      });

      state.activeListId = listId;
      saveLastOpenState({ activePanel: "lists", activeListId: listId });
      newListName.value = "";
      setActivePanel("lists");
    }

    async function deleteActiveList() {
      if (!state.recordId) return alert("Select a project first.");
      if (!state.activeListId) return alert("No list selected.");

      const listId = state.activeListId;
      const listObj = state.lists[listId] || {};
      const display = listObj._name || listId;

      if (!confirm(`Delete list "${display}" and all items/images?`)) return;

      const items = getListItems(listObj);
      const paths = [];
      Object.values(items).forEach(item => paths.push(...collectImagePaths(item)));

      await dbRemove(`${RECORD_PATH(state.recordId)}/lists/${listId}`);

      for (const p of paths) {
        try { await deleteObject(storageRef(storage, p)); } catch (e) { console.warn(e); }
      }

      state.activeListId = "";
      saveLastOpenState({ activeListId: "", activePanel: "daily" });
      setActivePanel("daily");
    }

    async function addItemToActiveList() {
      if (!state.recordId) return alert("Select a project first.");
      if (!state.activeListId) return alert("Select or create a list first.");

      const listId = state.activeListId;
      const id = (itemInputs.id.value || "").trim();
      if (!id) return alert("ID is required.");

      const item = {
        id,
        model: itemInputs.model.value || "",
        type: itemInputs.type.value || "",
        location: itemInputs.location.value || "",
        status: itemInputs.status.value || "",
        ip: itemInputs.ip.value || "",
        mac: itemInputs.mac.value || "",
        notes: "",
        images: []
      };

      await dbSet(`${RECORD_PATH(state.recordId)}/lists/${listId}/${id}`, item);

      Object.values(itemInputs).forEach(el => el.value = "");
    }

    // ============================
    // Uploads
    // ============================
    imageUploadInput.addEventListener("change", async () => {
      const file = imageUploadInput.files?.[0];
      if (!file || !pendingUploadTarget || !state.recordId) return;

      const target = pendingUploadTarget;
      pendingUploadTarget = null;

      try {
        const resizedBlob = await resizeImageToJpeg(file, 2048, 0.9);

        let storagePath;
        let dbNodePath;

        if (target.kind === "daily") {
          storagePath = storageImagePath({ kind: "daily", dailyKey: target.dailyKey });
          dbNodePath = `${RECORD_PATH(state.recordId)}/tasks/${target.dailyKey}`;
        } else {
          storagePath = storageImagePath({ kind: "listItem", listId: target.listId, itemId: target.itemId });
          dbNodePath = `${RECORD_PATH(state.recordId)}/lists/${target.listId}/${target.itemId}`;
        }

        const sRef = storageRef(storage, storagePath);
        await uploadBytes(sRef, resizedBlob, { contentType: "image/jpeg" });
        const url = await getDownloadURL(sRef);

        const snap = await get(dbRef(dbNodePath));
        const current = snap.val() || {};
        const images = Array.isArray(current.images) ? current.images.slice() : [];
        images.push({ url, path: storagePath, note: "" });

        await dbUpdate(dbNodePath, { images });
      } catch (err) {
        console.error(err);
        alert("Image upload failed (check console).");
      } finally {
        imageUploadInput.value = "";
      }
    });

    // ============================
    // Record loading
    // ============================
    async function ensureMetaExists(recordId) {
      const metaRef = dbRef(`${RECORD_PATH(recordId)}/meta`);
      const snap = await get(metaRef);
      if (!snap.exists()) {
        await update(dbRef(RECORD_PATH(recordId)), { meta: { updatedAt: Date.now() } });
      }
    }

    async function loadRecordById(id) {
      if (!id) return;

      detachRecordListener();

      state.recordId = id;
      saveLastOpenState({ recordId: id });

      const rRef = dbRef(RECORD_PATH(id));
      const rCb = (snap) => {
        if (!snap.exists()) return;

        const data = snap.val() || {};
        state.customerName = data.customerName || "";
        state.projectFieldName = data.project || "";
        state.meta = data.meta || { updatedAt: 0 };
        state.links = Array.isArray(data.links) ? data.links : [];
        state.lists = data.lists || {};
        state.daily = data.tasks || {};

        const listIds = Object.keys(state.lists || {});
        if (state.activeListId && !state.lists[state.activeListId]) state.activeListId = "";
        if (!state.activeListId && listIds.length) state.activeListId = listIds[0];

        renderHeader();
        renderSidebarPills();
        renderAll();
      };

      state.listeners.recordRef = rRef;
      state.listeners.recordCb = rCb;
      onValue(rRef, rCb);

      await ensureMetaExists(id);
    }

    // ============================
    // Dropdown listener
    // ============================
    function startTasksDropdownListener() {
      detachDropdownListener();

      const dRef = dbRef(TASKS_ROOT());
      const dCb = (snap) => {
        projectDropdown.innerHTML = `<option value="">Select project</option>`;
        if (!snap.exists()) return;

        const rows = [];
        snap.forEach(child => {
          const id = child.key;
          const v = child.val() || {};
          const projectName = (v.project || "").trim();
          const customerName = (v.customerName || "").trim();
          const updatedAt = v.meta?.updatedAt || v.updatedAt || 0;
          rows.push({
            id,
            projectName: projectName || id,
            customerName: customerName || "—",
            updatedAt
          });
        });

        rows.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));

        for (const r of rows) {
          const opt = document.createElement("option");
          opt.value = r.id;
          opt.textContent = `${r.projectName} (${r.customerName})`;
          projectDropdown.appendChild(opt);
        }

        if (state.recordId) projectDropdown.value = state.recordId;
      };

      state.listeners.dropdownRef = dRef;
      state.listeners.dropdownCb = dCb;
      onValue(dRef, dCb);
    }

    // ============================
    // Project creation
    // ============================
    async function createNewProjectWithName(name) {
      const now = Date.now();
      const newId = String(now);

      await set(dbRef(RECORD_PATH(newId)), {
        project: name,
        customerName: "",
        meta: { updatedAt: now },
        tasks: {},
        lists: {},
        links: []
      });

      await loadRecordById(newId);

      projectDropdown.value = newId;
      projectNameInput.value = "";
      return newId;
    }

    // ============================
    // Render all
    // ============================
    function renderAll() {
      renderProjectLinks();

      if (!state.recordId) {
        dailyTasksTableBody.innerHTML = "";
        activeListTableBody.innerHTML = "";
        dailyTasksCountLabel.textContent = "";
        activeListCountLabel.textContent = "";
        return;
      }

      // Don’t clobber while typing
      const siteVal = state.customerName || "";
      if (document.activeElement !== siteNameInput && siteNameInput.value !== siteVal) {
        siteNameInput.value = siteVal;
      }

      if (state.activePanel === "daily") renderDailyTasks();
      if (state.activePanel === "lists") renderActiveList();
    }

    // ============================
    // Restore last-open state
    // ============================
    async function restoreLastOpenState() {
      const saved = loadLastOpenState();

      if (typeof saved.globalQuery === "string") {
        state.globalQuery = saved.globalQuery;
        globalSearchInput.value = saved.globalQuery;
      }

      if (saved.recordId) {
        await loadRecordById(saved.recordId);
      }

      if (saved.activePanel === "lists") {
        const listIds = Object.keys(state.lists || {});
        state.activeListId = (saved.activeListId && state.lists?.[saved.activeListId])
          ? saved.activeListId
          : (listIds[0] || "");
        setActivePanel("lists");
      } else {
        setActivePanel("daily");
      }
    }

    // ============================
    // Events
    // ============================
    setProjectBtn.addEventListener("click", async () => {
      const name = (projectNameInput.value || "").trim();
      if (!name) return alert("Enter a project name to create.");
      await createNewProjectWithName(name);
    });

    projectNameInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        setProjectBtn.click();
      }
    });

    projectDropdown.addEventListener("change", async () => {
      const id = projectDropdown.value;
      if (!id) return;
      await loadRecordById(id);
    });

    clearAppDataBtn.addEventListener("click", async () => {
      if (!state.recordId) return alert("No project selected.");
      if (!confirm("Clear app data for this record? (customerName, daily tasks, lists, links)")) return;

      await dbUpdate(RECORD_PATH(state.recordId), {
        customerName: "",
        meta: { ...state.meta, updatedAt: Date.now() },
        tasks: {},
        lists: {},
        links: []
      }, false);

      await touchRecord();

      state.activeListId = "";
      clearLastOpenState();
      setActivePanel("daily");
    });

    siteNameInput.addEventListener("blur", async () => {
      if (!state.recordId) return;
      const val = (siteNameInput.value || "").trim();
      await dbUpdate(RECORD_PATH(state.recordId), { customerName: val });
    });

    addDailyTaskBtn.addEventListener("click", addDailyTask);
    createListBtn.addEventListener("click", createList);
    deleteListBtn.addEventListener("click", deleteActiveList);
    addItemBtn.addEventListener("click", addItemToActiveList);

    const debouncedSearchRender = debounce(() => {
      saveLastOpenState({ globalQuery: state.globalQuery });
      renderAll();
    }, 120);

    globalSearchInput.addEventListener("input", () => {
      state.globalQuery = globalSearchInput.value || "";
      debouncedSearchRender();
    });

    projectLinksForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      if (!state.recordId) return alert("Select a project first.");

      const title = (projectLinkTitle.value || "").trim();
      const url = (projectLinkUrl.value || "").trim();
      if (!title || !url) return alert("Title and URL are required.");
      try { new URL(url); } catch { return alert("Invalid URL (include https://)"); }

      const next = Array.isArray(state.links) ? state.links.slice() : [];
      next.push({ title, url });

      projectLinkTitle.value = "";
      projectLinkUrl.value = "";

      await dbUpdate(RECORD_PATH(state.recordId), { links: next });
    });

    // ✅ Export / Import events
    exportCsvBtn.addEventListener("click", exportCsv);

    importCsvBtn.addEventListener("click", () => {
      if (!state.recordId) return alert("Select a project first.");
      csvImportInput.value = "";
      csvImportInput.click();
    });

    csvImportInput.addEventListener("change", async () => {
      const file = csvImportInput.files?.[0];
      if (!file) return;

      try {
        const text = await file.text();
        await importCsvText(text);
      } catch (e) {
        console.error(e);
        alert("CSV import failed (check console).");
      } finally {
        csvImportInput.value = "";
      }
    });

    // ============================
    // Init + Auth
    // ============================
    function initUIForBasePath() {
      dataPathLabel.textContent = DATABASE_BASE_PATH;
      startTasksDropdownListener();
      renderSidebarPills();
      setActivePanel("daily");
    }

    initUIForBasePath();

    onAuthStateChanged(auth, async (user) => {
      DATABASE_BASE_PATH = user ? `${user.uid}` : "public";

      // base path changed: detach listeners and reset record state
      detachRecordListener();
      detachDropdownListener();

      state.recordId = "";
      state.projectFieldName = "";
      state.customerName = "";
      state.links = [];
      state.lists = {};
      state.daily = {};
      state.activeListId = "";
      state.globalQuery = "";
      if (globalSearchInput) globalSearchInput.value = "";

      initUIForBasePath();
      await restoreLastOpenState();
    });
  </script>

</body>

</html>