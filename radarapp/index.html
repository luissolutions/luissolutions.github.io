<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Radar Sensor Tracker</title>
    <link rel="stylesheet" href="../assets/css/app-styles.css" />
    <link rel="stylesheet" href="./assets/css/radar-styles.css" />
    <script type="module" src="../apps/assets/js/microsoftAuth.js"></script>
    <script type="module" src="../apps/assets/js/login.js"></script>
    <script src="assets/js/sidebar.js"></script>
    <style>
        .hidden {
            display: none;
        }

        #gallery img {
            max-width: 150px;
            margin: 5px;
            border: 2px solid #ccc;
            border-radius: 10px;
        }

        #missingList li {
            color: red;
            font-weight: bold;
        }

        .radio-group {
            margin-bottom: 10px;
        }

        textarea {
            width: 90%;
        }

        .thumbnail {
            max-width: 150px;
            cursor: pointer;
            border-radius: 15px;
            transition: transform 0.2s;
            width: 100%;
        }

        .thumbnail:hover {
            transform: scale(1.1);
        }

        .thumbnailItem {
            position: relative;
            text-align: center;
            margin: 5px;
        }

        #gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
        }

        #modalContent {
            position: relative;
            background: #fff;
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        #modalImage {
            margin: 0 auto;
            max-width: 90vw;
            max-height: 80vh;
            display: block;
            margin-bottom: 10px;
        }

        #modalFileName {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        .image-container {
            position: relative;
            display: inline-block;
            margin: 5px;
        }

        .image-container img {
            max-width: 150px;
            border: 2px solid #ccc;
            border-radius: 10px;
            cursor: pointer;
        }

        .favorite-star {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
        }

        .favorite-star:hover {
            background-color: lightskyblue;
        }

        .favorite-star.favorited {
            color: gold;
        }

        #siteImageContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 0.5rem;
        }

        #siteImageWrapper {
            overflow: hidden;
            width: 98vw;
            height: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #siteImageDisplay {
            width: 100vw;
            height: auto;
            object-fit: contain;
            transform-origin: center center;
            transition: transform 0.3s ease;
        }

        #siteImageNav button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .notes-section {
            margin: 20px;
        }

        .ms {
            margin: 10px;
        }

        .deleteNoteButton {
            background-color: red;
            cursor: pointer;
        }

        .logins-section {
            display: none;
        }

        #login-section {
            display: flex;
            align-items: center;
        }

        #sensorNumber,
        #serialNumber,
        #projectName {
            font-size: 16px;
        }

        @media (max-width: 439px) {
            .thumbnail {
                max-width: 145px;
            }

            #gallery img {
                max-width: 130px;
            }
        }

        #fieldSelector {
            display: flex;
        }

        input:disabled,
        textarea:disabled,
        button:disabled {
            background-color: #eee;
            cursor: not-allowed;
            opacity: 0.6;
        }

        #fieldSelector input[type="checkbox"],
        #adminSection input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .compact-panel {
            display: none;
            position: relative;
        }

        #missingList li.missing-sensor {
            cursor: pointer;
        }

        #missingList li.missing-sensor:focus {
            outline: 2px solid #000;
            outline-offset: 2px;
        }

        .file-input {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0 0 0 0);
            white-space: nowrap;
            border: 0;
        }

        .file-btn {
            display: inline-block;
            padding: 10px 14px;
            border-radius: 4px;
            background: var(--buttonColor);
            color: whitesmoke;
            cursor: pointer;
            user-select: none;
            transition: transform .06s ease, background .15s ease;
            margin-bottom: 8px;
        }

        .file-btn:hover {
            background: var(--primaryColor);
            color: black;
        }

        .file-btn:active {
            transform: scale(0.98);
        }

        @media (max-width: 768px) {
            .file-btn {
                padding: 14px 18px;
                border-radius: 14px;
            }
        }

        @media (max-width: 480px) {
            .file-btn {
                padding: 16px 22px;
                border-radius: 16px;
            }
        }

        @media (max-width: 439px) {
            .file-btn {
                padding: 18px 24px;
            }
        }
    </style>
</head>

<body>

    <header>
        <h1>Radar Job Tracker</h1>
        <span id="logins-section" class="logins-section">
            <section id="login-section">
                <form id="login-form">
                    <label for="username">Email:</label>
                    <input type="email" id="username" required>
                    <br>
                    <label for="password">Password:</label>
                    <input type="password" id="password" required>
                    <br>
                    <button type="submit">Login</button>
                </form>
                <button id="logout" style="display: none;">Logout</button>
            </section>

            <div class="ms">
                <br>
                <button id="loginButton">Login to MS</button>
                <button id="logoutButton">Logout of MS</button>
                <p id="loginStatus">Login status...</p>
            </div>
        </span>

        <section id="adminSection" style="display: none;">
            <label>
                <input type="checkbox" id="adminToggle" checked />
                Admin Mode
            </label>
        </section>

    </header>

    <div id="authScreen">
        <h2>Enter Project Code to Continue</h2>
        <input type="text" id="accessCode" placeholder="Project ID" />
        <button id="submitCode">Enter</button>
        <button id="autoValidateBtn">Select Project</button>


        <section class="instructions">
            <h2>Instructions</h2>
            <ul>
                <li>Enter a new Project ID and total devices, then click ‚ÄúSave New Project‚Äù.</li>
                <li>Use the dropdown to switch between existing saved projects.</li>
                <li>Save project notes with a date and description.</li>
                <li>Select between Device Images or Deliverables view.</li>
                <li>Device uploads are resized and marked with the device number + serial.</li>
                <li>Deliverable uploads use the image name or markup as filename.</li>
                <li>Missing device images are shown below (2 required per device).</li>
                <li>Click an image to view, download, delete, or move it.</li>
                <li>Click ‚òÖ to favorite an image (favorites are shown first).</li>
            </ul>
        </section>
    </div>

    <main id="mainApp" class="hidden">

        <section id="fieldSelector">
            <button id="customizeToggle" class="compact-btn">‚öôÔ∏è Customize View</button>
            <div id="customizePanel" class="compact-panel">
                <label><input type="checkbox" class="section-toggle" data-target="siteImagesSection" checked> Site
                    Images</label><br>
                <label><input type="checkbox" class="section-toggle" data-target="notes-section" checked> Project
                    Notes</label><br>
                <label><input type="checkbox" class="section-toggle" data-target="sensor-meta" checked> Sensor
                    Details</label><br>
                <label><input type="checkbox" class="section-toggle" data-target="radio-group" checked> Image Mode
                    Toggle</label><br>
            </div>
        </section>

        <section>
            <label>Project ID: <input type="text" id="project" /></label> <br>
            <label>Total Devices: <input type="number" id="sensorCount" min="1" /></label>
            <button id="saveProject" style="display: none;">Save New Project</button>
            <br /><br />
            <label>Existing Projects:
                <select id="projectList">
                    <option value="">-- Choose a project --</option>
                </select>
            </label>
        </section>

        <section id="siteImagesSection">
            <h3>Site Images</h3>
            <input type="file" id="siteImageUploader" accept="image/*" capture="environment" class="file-input" />
            <label for="siteImageUploader" class="file-btn">üì∑ Take/Choose Picture</label>
            <button id="uploadSiteImage">Upload Site Image</button>

            <div id="siteImageNavTop" class="site-image-controls">
                <button class="prevSiteImage">‚óÄÔ∏é Previous</button>
                <button class="rotateSiteImage">‚Üª Rotate</button>
                <button class="nextSiteImage">Next ‚ñ∂Ô∏é</button>
            </div>

            <div id="siteImageContainer">
                <div id="siteImageWrapper">
                    <img id="siteImageDisplay" src="" alt="Site Image" />
                </div>

                <div id="siteImageNav" class="site-image-controls">
                    <button class="prevSiteImage">‚óÄÔ∏é Previous</button>
                    <button class="rotateSiteImage">‚Üª Rotate</button>
                    <button id="downloadSiteImage">Download</button>
                    <button class="nextSiteImage">Next ‚ñ∂Ô∏é</button>
                </div>

            </div>
        </section>

        <section class="notes-section">
            <h3>Project Notes:</h3>
            <div id="notesList" class="notes-section"></div>
            <label>Date: <input type="date" id="noteDate" /></label><br />
            <textarea id="noteText" rows="3" cols="50"></textarea><br />
            <button id="saveNote">Save Note</button>
        </section>

        <section class="sensor-meta">
            <h3>Device Details</h3>
            <label>Device #:
                <select id="sensorMetaNumberDropdown">
                    <option value="">Select a Device</option>
                </select>
            </label><br>
            <label>Serial #: <input type="text" id="sensorMetaSerial" /></label><br>
            <label>Measurement 1: <input type="text" id="sensorMetaM1" placeholder="Optional" /></label><br>
            <label>Measurement 2: <input type="text" id="sensorMetaM2" placeholder="Optional" /></label><br>
            <label>Measurement 3: <input type="text" id="sensorMetaM3" placeholder="Optional" /></label><br>
            <button id="saveSensorMeta">Save Sensor Info</button>
            <button id="exportCSV">Export Sensor Data</button>
        </section>
        <br>
        <section class="radio-group">
            <label><input type="radio" name="viewMode" value="sensors" checked /> Device Images</label>
            <label><input type="radio" name="viewMode" value="deliverables" /> Other Deliverables</label>
        </section>

        <section id="sensorUploadSection">
            <h3>Upload Device Image Below</h3>
            <input type="file" id="sensorImage" accept="image/*" capture="environment" class="file-input" />
            <label for="sensorImage" class="file-btn">üì∑ Take/Choose Picture</label>
            <br>
            <label>Device #:
                <select id="sensorNumberDropdown">
                    <option value="">Select a Device</option>
                </select>
            </label>
            <label>Serial: <input type="text" id="serialNumber" /></label><br />

            <label>
                <input type="checkbox" id="skipMarkupCheckbox" />
                No Markup
            </label>

            <button id="uploadImage">Upload</button>
        </section>

        <section id="deliverableUploadSection" style="display:none;">
            <h3>Upload Deliverable Image</h3>
            <input type="file" id="fileUploader" accept="image/*" capture="environment" class="file-input" />
            <label for="fileUploader" class="file-btn">üì∑ Take/Choose Picture</label>
            <br>
            <label>Name: <input type="text" id="imageNameInput" /></label> <br>
            <label>Markup: <input type="text" id="markupTextInput" /></label>
            <button id="uploadDeliverableImage">Upload Image</button>
        </section>

        <section>
            <h3>Missing Images</h3>
            <ul id="missingList"></ul>
        </section>

        <section>
            <h3>Gallery</h3>
            <label for="imageDropdown">Select an Image:</label>
            <select id="imageDropdown">
                <option value="">- Select an Image -</option>
            </select>
            <div id="gallery"></div>
        </section>

        <button id="uploadFolderToOneDrive">Upload to OneDrive</button>

        <div id="modal">
            <div id="modalContent">
                <img id="modalImage" src="" alt="Large View" />
                <p id="modalFileName"></p>
                <div class="modal-nav">
                    <button id="modalPrev">‚óÄ Previous</button>
                    <button id="modalNext">Next ‚ñ∂</button>
                </div>
                <button id="downloadButton">Download</button>
                <button class="clear-button" id="deleteButton">Delete</button>
                <button id="closeModalButton">Close</button>
            </div>
        </div>

    </main>

    <script type="module">
        import { auth, onAuthStateChanged, database, storage, ref as dbRef, set, update, get, storageRef, uploadBytes, getDownloadURL, listAll, deleteObject } from '../apps/assets/js/firebase-init.js';
        import { accessToken, isTokenExpired } from '../apps/assets/js/microsoftAuth.js';
        import { getIP, updateVisitCount } from '../assets/js/visitLogger.js';

        let currentProject = '';
        let expectedSensors = 0;
        let modalItems = [];
        let modalIndex = 0;
        let DATABASE_BASE_PATH = 'public';
        let isLoadingProject = false;
        let currentProjectName = '';

        onAuthStateChanged(auth, (user) => {
            DATABASE_BASE_PATH = user ? user.uid : 'public';
            populateProjects();
        });

        const ADMIN_PASSWORD = "telaidadmin";
        const sanitize = str => str.trim().replace(/\s+/g, '_');

        let validated = false;

        async function validateCode() {
            const input = document.getElementById('accessCode').value.trim().toLowerCase();
            const snapshot = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks`));
            if (!snapshot.exists()) return alert('No tasks found.');

            const tasks = snapshot.val();
            const matchEntry = Object.entries(tasks).find(([id, data]) => {
                return data.project?.trim().toLowerCase() === input;
            });

            if (matchEntry) {
                const [matchedID, matchedData] = matchEntry;
                localStorage.setItem('lastProject', matchedID);
                validated = true;

                document.getElementById('authScreen')?.remove();
                document.getElementById('mainApp')?.classList.remove('hidden');
                await populateProjects();
                document.getElementById('projectList').value = matchedID;
                await loadProject(matchedID);
            } else {
                if (!input) {
                    alert("Project name cannot be blank.");
                    return;
                }

                const shouldCreate = confirm(`Project "${input}" not found. Would you like to create it?`);
                if (!shouldCreate) return;

                const inputPassword = prompt("Enter password to create a new project:");
                if (inputPassword !== ADMIN_PASSWORD) {
                    alert("Incorrect password.");
                    return;
                }

                const newTimestamp = Date.now().toString();
                const taskRef = dbRef(database, `${DATABASE_BASE_PATH}/tasks/${newTimestamp}`);

                await update(taskRef, {
                    id: newTimestamp,
                    project: input,
                    sensorCount: 0
                });

                localStorage.setItem('lastProject', newTimestamp);
                validated = true;

                alert("New project created. Please enter the total sensors and save.");
                document.getElementById('authScreen')?.remove();
                document.getElementById('mainApp')?.classList.remove('hidden');
                await populateProjects();
                document.getElementById('projectList').value = newTimestamp;
                await loadProject(newTimestamp);
            }
        }

        document.getElementById('autoValidateBtn').addEventListener('click', async () => {
            const tasksSnapshot = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks`));
            if (!tasksSnapshot.exists()) {
                alert("No projects found.");
                return;
            }

            const tasks = tasksSnapshot.val();
            const taskEntries = Object.entries(tasks);
            if (taskEntries.length === 0) {
                alert("No projects available.");
                return;
            }

            let selectedID;

            const lastProjectID = localStorage.getItem('lastProject');
            const foundLast = taskEntries.find(([id]) => id === lastProjectID);
            if (lastProjectID && foundLast) {
                selectedID = lastProjectID;
            } else {
                // Randomly pick one
                const randomEntry = taskEntries[Math.floor(Math.random() * taskEntries.length)];
                selectedID = randomEntry[0];
            }

            validated = true;
            document.getElementById('authScreen')?.remove();
            document.getElementById('mainApp')?.classList.remove('hidden');
            localStorage.setItem('lastProject', selectedID);
            await populateProjects();
            document.getElementById('projectList').value = selectedID;
            await loadProject(selectedID);
        });

        document.getElementById('submitCode').addEventListener('click', validateCode);
        document.getElementById('accessCode').addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                validateCode();
            }
        });

        const resizeImage = (file, maxWidth) => new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => {
                const img = new Image();
                img.src = reader.result;
                img.onload = () => {
                    let [w, h] = [img.width, img.height];
                    if (w > maxWidth) h *= maxWidth / w, w = maxWidth;
                    const canvas = Object.assign(document.createElement('canvas'), { width: w, height: h });
                    canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                    canvas.toBlob(resolve, file.type);
                };
            };
            reader.readAsDataURL(file);
        });

        const addTextToImage = (blob, text) => new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => {
                const img = new Image();
                img.src = reader.result;
                img.onload = () => {
                    const canvas = Object.assign(document.createElement('canvas'), {
                        width: img.width,
                        height: img.height + 100
                    });
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    ctx.fillStyle = 'white';
                    ctx.font = '80px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(text, canvas.width / 2, canvas.height - 20);
                    canvas.toBlob(resolve, 'image/jpeg');
                };
            };
            reader.readAsDataURL(blob);
        });

        async function populateProjects() {
            const dropdown = document.getElementById('projectList');
            dropdown.innerHTML = '';
            dropdown.appendChild(new Option('-- Choose a project --', ''));

            const snap = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks`));
            if (!snap.exists()) return;

            const tasks = snap.val();

            // helper: best "freshness" timestamp for a task
            const bestTime = (task, id) => {
                const candidates = [
                    Number(task.updatedAt) || 0,
                    Number(task.createdAt) || 0,
                    Number(task.startTime) || 0,
                    Number(task.timestamp) || 0,
                    Number(id) || 0, // many of your IDs are Date.now()
                ];
                return Math.max(...candidates);
            };

            // Group by normalized project name, pick the freshest per group
            const groups = new Map(); // key: normalized project, value: {id, task}
            for (const [id, task] of Object.entries(tasks)) {
                const projectRaw = (task.project || '').trim();
                if (!projectRaw) continue; // skip truly unnamed

                const key = projectRaw.toLowerCase();
                const current = groups.get(key);

                if (!current) {
                    groups.set(key, { id, task });
                } else {
                    const newer =
                        bestTime(task, id) > bestTime(current.task, current.id)
                            ? { id, task }
                            : current;
                    groups.set(key, newer);
                }
            }

            // Turn into a list, sort alphabetically by project label
            const deduped = [...groups.values()].sort((a, b) => {
                const A = (a.task.project || '').toLowerCase();
                const B = (b.task.project || '').toLowerCase();
                return A.localeCompare(B);
            });

            // Build options (one per project)
            for (const { id, task } of deduped) {
                let label = task.project || `(Unnamed - ${id})`;
                if (task.customerName && task.customerName.trim() !== '') {
                    label += ` ‚Äî ${task.customerName}`;
                }
                dropdown.appendChild(new Option(label, id));
            }
        }

        async function loadProject(id) {
            if (isLoadingProject) return;
            isLoadingProject = true;

            try {
                console.log(`[loadProject] Start loading project: ${id}`);
                currentProject = id;
                localStorage.setItem('lastProject', id);

                const dataSnap = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks/${id}`));
                if (!dataSnap.exists()) {
                    throw new Error(`No task found for ID ${id}`);
                }

                const data = dataSnap.val();

                currentProjectName = data.project || '';
                expectedSensors = data.sensorCount || 0;

                document.getElementById('project').value = currentProjectName;
                document.getElementById('sensorCount').value = expectedSensors;

                console.log(`[loadProject] Sensor count: ${expectedSensors}`);

                await updateSiteImages();
                await loadNotes();
                populateSensorDropdown(expectedSensors);
                await updateGallery();

            } catch (err) {
                console.error(`[loadProject] Failed:`, err);
                alert('Failed to load project. Check console for details.');
            } finally {
                isLoadingProject = false;
            }
        }

        function populateSensorDropdown(count) {
            const dropdowns = [document.getElementById('sensorMetaNumberDropdown'), document.getElementById('sensorNumberDropdown')];
            dropdowns.forEach(dropdown => {
                dropdown.innerHTML = `<option value="">Select a Device</option>`;
                for (let i = 1; i <= count; i++) {
                    const padded = String(i).padStart(2, '0');
                    dropdown.innerHTML += `<option value="${i}">${padded}</option>`;
                }
            });
        }

        const getFavorites = () => JSON.parse(localStorage.getItem('favorites') || '{}');
        const toggleFavorite = path => {
            const favs = getFavorites();
            if (favs[path]) delete favs[path];
            else favs[path] = true;
            localStorage.setItem('favorites', JSON.stringify(favs));
        };

        async function updateGallery() {
            const safeProjectName = sanitize(currentProjectName || currentProject);
            const isSensor = document.querySelector('input[name="viewMode"]:checked').value === 'sensors';
            const base = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}/${isSensor ? 'sensors' : 'deliverables'}`;
            const snapshot = await listAll(storageRef(storage, base));

            const items = await Promise.all(snapshot.items.map(async item => {
                const url = await getDownloadURL(item);
                return { name: item.name, url, fullPath: item.fullPath };
            }));

            const favorites = JSON.parse(localStorage.getItem('favorites') || '{}');
            items.sort((a, b) => (favorites[b.fullPath] ? 1 : 0) - (favorites[a.fullPath] ? 1 : 0));

            modalItems = items;

            const gallery = document.getElementById('gallery');
            const dropdown = document.getElementById('imageDropdown');
            const missingList = document.getElementById('missingList');

            gallery.innerHTML = '';
            dropdown.innerHTML = '<option value="">-- Select an Image --</option>';
            missingList.innerHTML = '';

            items.forEach(item => {
                const container = document.createElement('div');
                container.className = 'image-container';

                const img = document.createElement('img');
                img.src = item.url;
                img.loading = 'lazy';
                img.alt = item.name;
                img.onclick = () => showModal(item.url, item.name, base);

                const star = document.createElement('span');
                star.className = 'favorite-star';
                star.textContent = favorites[item.fullPath] ? '‚òÖ' : '‚òÜ';
                if (favorites[item.fullPath]) star.classList.add('favorited');
                star.onclick = e => {
                    e.stopPropagation();
                    if (favorites[item.fullPath]) delete favorites[item.fullPath];
                    else favorites[item.fullPath] = true;
                    localStorage.setItem('favorites', JSON.stringify(favorites));
                    updateGallery();
                };

                container.append(img, star);
                gallery.appendChild(container);

                dropdown.appendChild(new Option(item.name, item.url));
            });

            if (isSensor) {
                const countMap = {};
                items.forEach(item => {
                    const m = item.name.match(/^[^_]+_(\d{2})-/);
                    if (m) {
                        const idx = parseInt(m[1], 10);
                        countMap[idx] = (countMap[idx] || 0) + 1;
                    }
                });

                for (let i = 1; i <= expectedSensors; i++) {
                    const padded = String(i).padStart(2, '0');
                    const have = countMap[i] || 0;
                    if (have < 2) {
                        const li = document.createElement('li');
                        li.textContent = `Sensor ${padded} - Missing ${2 - have} image(s)`;
                        li.dataset.sensor = String(i);
                        li.className = 'missing-sensor';
                        li.setAttribute('role', 'button');
                        li.setAttribute('tabindex', '0'); // keyboard focusable
                        missingList.appendChild(li);
                    }
                }

                // Click/keyboard: pick sensor, show the upload UI, and focus serial input
                const handlePickMissing = (sensorNum) => {
                    // Ensure "Device Images" mode is active
                    const sensorsRadio = document.querySelector('input[name="viewMode"][value="sensors"]');
                    if (sensorsRadio && !sensorsRadio.checked) {
                        sensorsRadio.checked = true;
                        // Toggle sections to match current code‚Äôs behavior
                        document.getElementById('sensorUploadSection').style.display = 'block';
                        document.getElementById('deliverableUploadSection').style.display = 'none';
                    }

                    // Select in both dropdowns (upload + meta)
                    const uploadDd = document.getElementById('sensorNumberDropdown');
                    const metaDd = document.getElementById('sensorMetaNumberDropdown');
                    if (uploadDd) uploadDd.value = sensorNum;
                    if (metaDd) metaDd.value = sensorNum;

                    // Scroll and focus for quick entry
                    const serialInput = document.getElementById('serialNumber');
                    document.getElementById('sensorUploadSection')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => serialInput?.focus(), 250);
                };

                // Event delegation so it works for all items we just added
                missingList.onclick = (e) => {
                    const li = e.target.closest('li[data-sensor]');
                    if (!li) return;
                    handlePickMissing(li.dataset.sensor);
                };

                // Keyboard: Enter/Space activates the item
                missingList.onkeydown = (e) => {
                    const li = e.target.closest('li[data-sensor]');
                    if (!li) return;
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handlePickMissing(li.dataset.sensor);
                    }
                };
            }
        }

        async function uploadSensor() {
            const uploadBtn = document.getElementById('uploadImage');
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';

            const numEl = document.getElementById('sensorNumberDropdown');
            const serialEl = document.getElementById('serialNumber');
            const fileEl = document.getElementById('sensorImage');
            const skipMarkupEl = document.getElementById('skipMarkupCheckbox');

            const num = numEl.value;
            const serial = sanitize(serialEl.value);
            const file = fileEl.files[0];
            const skipMarkup = skipMarkupEl.checked;

            if (!currentProject || !num || !serial || !file) {
                alert('Fill out all fields');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload';
                return;
            }

            const paddedNum = String(num).padStart(2, '0');
            const safeProjectName = sanitize(currentProjectName || currentProject);
            const folderPath = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}/sensors`;

            try {
                const files = await listAll(storageRef(storage, folderPath));
                const matchCount = files.items.filter(f => f.name.startsWith(`${safeProjectName}_${paddedNum}`)).length;

                if (matchCount >= 2) {
                    const proceed = confirm(`Sensor ${paddedNum} already has 2 uploads. Upload another?`);
                    if (!proceed) {
                        uploadBtn.disabled = false;
                        uploadBtn.textContent = 'Upload';
                        return;
                    }
                }

                let blob = await resizeImage(file, 2048);
                if (!skipMarkup) {
                    blob = await addTextToImage(blob, `${currentProjectName} ${paddedNum} - ${serial}`);
                }

                const desired = `${safeProjectName}_${paddedNum}-${serial}.jpg`;
                const uniqueName = await getUniqueFilename(folderPath, desired);

                await uploadBytes(storageRef(storage, `${folderPath}/${uniqueName}`), blob);

                const placeholderRef = storageRef(storage, `${folderPath}/.init.txt`);
                try {
                    await deleteObject(placeholderRef);
                    console.log('Sensor .init.txt deleted.');
                } catch (err) {
                    if (err.code !== 'storage/object-not-found') {
                        console.warn('Error deleting sensor placeholder:', err);
                    }
                }

                await updateGallery();
                alert(`Sensor image saved as ‚Äú${uniqueName}‚Äù!`);

                fileEl.value = '';
                numEl.value = '';
                serialEl.value = '';
                skipMarkupEl.checked = false;

            } catch (err) {
                console.error('Upload failed:', err);
                alert('Sensor upload failed. See console for details.');
            }

            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload';
        }

        async function uploadDeliverable() {
            const safeProjectName = sanitize(currentProjectName || currentProject);
            const uploadBtn = document.getElementById('uploadDeliverableImage');
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';

            const fileEl = document.getElementById('fileUploader');
            const nameEl = document.getElementById('imageNameInput');
            const markupEl = document.getElementById('markupTextInput');

            const file = fileEl.files[0];
            const rawName = nameEl.value.trim();
            const rawMarkup = markupEl.value.trim();

            const nameInput = sanitize(rawName);
            const markupInput = rawMarkup;

            if (!currentProject || !file || (!nameInput && !markupInput)) {
                alert('Please select a file and enter either a Name or Markup');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload Image';
                return;
            }

            try {
                const baseName = nameInput || sanitize(rawMarkup);
                let blob = await resizeImage(file, 2048);

                if (rawMarkup) {
                    blob = await addTextToImage(blob, rawMarkup);
                }

                const folder = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}/deliverables`;
                const desired = `${baseName}.jpg`;
                const uniqueName = await getUniqueFilename(folder, desired);

                await uploadBytes(storageRef(storage, `${folder}/${uniqueName}`), blob);

                const placeholderRef = storageRef(storage, `${folder}/.init.txt`);
                try {
                    await deleteObject(placeholderRef);
                    console.log('Sensor .init.txt deleted.');
                } catch (err) {
                    if (err.code !== 'storage/object-not-found') {
                        console.warn('Error deleting sensor placeholder:', err);
                    }
                }

                await updateGallery();
                alert(`Deliverable saved as ‚Äú${uniqueName}‚Äù!`);

                fileEl.value = '';
                nameEl.value = '';
                markupEl.value = '';
            } catch (err) {
                console.error('Upload failed:', err);
                alert('Deliverable upload failed. See console for details.');
            }

            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload Image';
        }

        async function saveNote() {
            const dateInput = document.getElementById('noteDate').value;
            const text = document.getElementById('noteText').value.trim();
            if (!currentProject || !dateInput || !text) return;

            const utcTimestamp = Date.now();
            await update(dbRef(database, `${DATABASE_BASE_PATH}/tasks/${currentProject}/comments`), {
                [utcTimestamp]: text
            });;
            loadNotes();
            alert('Note saved successfully!');
        }

        async function loadNotes() {
            const snapshot = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks/${currentProject}/comments`));
            const list = document.getElementById('notesList');
            list.innerHTML = '';

            if (snapshot.exists()) {
                const notes = snapshot.val();

                Object.keys(notes)
                    .sort((a, b) => parseInt(b) - parseInt(a))
                    .forEach(timestamp => {
                        const dateStr = new Date(parseInt(timestamp)).toLocaleString();
                        const formattedNote = notes[timestamp].replace(/\n/g, "<br>");
                        const div = document.createElement('div');
                        div.innerHTML = `
                            <strong>${dateStr}</strong><br>${formattedNote}
                            <button data-timestamp="${timestamp}" class="deleteNoteButton">üóë Delete</button>
                            <hr>
                        `;
                        list.appendChild(div);
                    });

                document.querySelectorAll('.deleteNoteButton').forEach(button => {
                    button.addEventListener('click', async () => {
                        const timestamp = button.dataset.timestamp;
                        const confirmDelete = confirm(`Delete note from ${new Date(parseInt(timestamp)).toLocaleString()}?`);
                        if (confirmDelete) {
                            await set(dbRef(database, `${DATABASE_BASE_PATH}/tasks/${currentProject}/comments/${timestamp}`), null);
                            loadNotes();
                        }
                    });
                });
            }
        }

        async function saveProject() {
            const projectName = sanitize(document.getElementById('project').value);
            const count = parseInt(document.getElementById('sensorCount').value);
            if (!projectName || isNaN(count)) return alert('Enter valid project ID and sensor count');

            const snapshot = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks`));

            let existingProjectId = null;

            if (snapshot.exists()) {
                const tasks = snapshot.val();
                for (const [id, task] of Object.entries(tasks)) {
                    if ((task.project || '').trim().toLowerCase() === projectName.toLowerCase()) {
                        existingProjectId = id;
                        break;
                    }
                }
            }

            const timestamp = existingProjectId || Date.now().toString();
            const taskRef = dbRef(database, `${DATABASE_BASE_PATH}/tasks/${timestamp}`);

            await update(taskRef, {
                id: timestamp,
                project: projectName,
                sensorCount: count
            });

            await populateProjects();
            document.getElementById('projectList').value = timestamp;
            await loadProject(timestamp);
            alert(`Project "${projectName}" ${existingProjectId ? 'updated' : 'saved'} successfully!`);

            const safeProjectName = sanitize(projectName);
            const basePath = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}`;
            const blob = createPlaceholderBlob();

            const uploadPlaceholder = async (folder, name = ".init.txt") => {
                const fullPath = `${basePath}/${folder}/${name}`;
                try {
                    await uploadBytes(storageRef(storage, fullPath), blob);
                } catch (err) {
                    console.warn(`Failed to upload dummy to ${folder}:`, err);
                }
            };

            await uploadPlaceholder('siteImages');
            await uploadPlaceholder('sensors');
            await uploadPlaceholder('deliverables');
        }

        function showModal(url, name, folderPath) {
            modalIndex = modalItems.findIndex(item => item.url === url);

            const modal = document.getElementById('modal');
            const img = document.getElementById('modalImage');
            const fn = document.getElementById('modalFileName');
            img.src = modalItems[modalIndex].url;
            fn.textContent = modalItems[modalIndex].name;
            modal.style.display = 'flex';

            document.getElementById('modalPrev').disabled = modalItems.length <= 1;
            document.getElementById('modalNext').disabled = modalItems.length <= 1;

            document.getElementById('downloadButton').onclick = () => window.open(url, '_blank');
            document.getElementById('closeModalButton').onclick = () => modal.style.display = 'none';
            modal.addEventListener('click', e => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }

        document.getElementById('deleteButton').onclick = async () => {
            const safeProjectName = sanitize(currentProjectName || currentProject);
            const item = modalItems[modalIndex];
            if (!(await confirmWithPassword("deleting this image"))) {
                alert("Incorrect password. Action cancelled.");
                return;
            }

            const isSensor = document.querySelector('input[name="viewMode"]:checked').value === 'sensors';
            const folder = isSensor ? 'sensors' : 'deliverables';
            const path = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}/${folder}/${item.name}`;

            try {
                await deleteObject(storageRef(storage, path));
                modal.style.display = 'none';
                updateGallery();
            } catch (err) {
                console.error("Failed to delete image:", err);
                alert("Failed to delete image. Check console for details.");
            }
        };

        document.getElementById('modalPrev').onclick = () => {
            if (modalItems.length < 2) return;
            modalIndex = (modalIndex - 1 + modalItems.length) % modalItems.length;
            const { url, name } = modalItems[modalIndex];
            document.getElementById('modalImage').src = url;
            document.getElementById('modalFileName').textContent = name;
            document.getElementById('downloadButton').onclick = () => window.open(url, '_blank');
        };

        document.getElementById('modalNext').onclick = () => {
            if (modalItems.length < 2) return;
            modalIndex = (modalIndex + 1) % modalItems.length;
            const { url, name } = modalItems[modalIndex];
            document.getElementById('modalImage').src = url;
            document.getElementById('modalFileName').textContent = name;
            document.getElementById('downloadButton').onclick = () => window.open(url, '_blank');
        };

        // Event bindings
        projectList.onchange = e => e.target.value && loadProject(e.target.value);
        document.getElementById('saveProject').onclick = saveProject;
        document.getElementById('uploadImage').onclick = uploadSensor;
        document.getElementById('uploadDeliverableImage').onclick = uploadDeliverable;
        document.getElementById('saveNote').onclick = saveNote;
        document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
            radio.addEventListener('change', () => {
                const isSensor = document.querySelector('input[name="viewMode"]:checked').value === 'sensors';
                document.getElementById('sensorUploadSection').style.display = isSensor ? 'block' : 'none';
                document.getElementById('deliverableUploadSection').style.display = isSensor ? 'none' : 'block';
                updateGallery();
            });
        });

        // Image dropdown opens modal
        document.getElementById('imageDropdown').addEventListener('change', function () {
            const selectedOption = this.options[this.selectedIndex];
            const url = selectedOption.value;
            const name = selectedOption.textContent;
            if (url) {
                const isSensor = document.querySelector('input[name="viewMode"]:checked').value === 'sensors';
                const folder = isSensor ? 'sensors' : 'deliverables';
                showModal(url, name, `${DATABASE_BASE_PATH}/tasks/${currentProject}/${folder}`);
            }
        });

        document.getElementById("sensorMetaNumberDropdown").addEventListener("change", async (e) => {
            const num = e.target.value;
            if (!num || !currentProject) return;

            const snap = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks/${currentProject}/sensorMeta/${num}`));
            if (snap.exists()) {
                const data = snap.val();
                document.getElementById("sensorMetaSerial").value = data.serial || '';
                document.getElementById("sensorMetaM1").value = data.m1 || '';
                document.getElementById("sensorMetaM2").value = data.m2 || '';
                document.getElementById("sensorMetaM3").value = data.m3 || '';
            } else {

                document.getElementById("sensorMetaSerial").value = '';
                document.getElementById("sensorMetaM1").value = '';
                document.getElementById("sensorMetaM2").value = '';
                document.getElementById("sensorMetaM3").value = '';
            }
        });

        document.getElementById("saveSensorMeta").onclick = async () => {
            const num = document.getElementById("sensorMetaNumberDropdown").value;
            const serial = document.getElementById("sensorMetaSerial").value.trim();
            const m1 = document.getElementById("sensorMetaM1").value.trim();
            const m2 = document.getElementById("sensorMetaM2").value.trim();
            const m3 = document.getElementById("sensorMetaM3").value.trim();

            if (!num || !serial) return alert("Sensor number and serial are required.");

            const sensorData = { serial, m1, m2, m3 };
            await set(dbRef(database, `${DATABASE_BASE_PATH}/tasks/${currentProject}/sensorMeta/${num}`), sensorData);
            alert("Sensor info saved!");
        };

        document.getElementById("sensorNumberDropdown").addEventListener("change", async (e) => {
            const num = e.target.value;
            const serialEl = document.getElementById("serialNumber");

            if (!num || !currentProject) {
                serialEl.value = '';
                return;
            }

            const snap = await get(dbRef(database, `${DATABASE_BASE_PATH}/tasks/${currentProject}/sensorMeta/${num}`));
            if (snap.exists()) {
                const data = snap.val();
                serialEl.value = data.serial || '';
            } else {
                serialEl.value = '';
            }
        });

        // Site images section
        let siteImages = [];
        let currentSiteIndex = 0;
        let siteImageRotation = 0;

        function getSiteIndex() {
            return parseInt(localStorage.getItem(`${currentProject}_siteIdx`) || '0', 10);
        }
        function saveSiteIndex(idx) {
            localStorage.setItem(`${currentProject}_siteIdx`, idx);
        }

        async function updateSiteImages() {
            siteImages = [];
            const safeProjectName = sanitize(currentProjectName || currentProject);
            if (!currentProject) return;

            const base = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}/siteImages`;
            const isImageName = (n) => /\.(png|jpe?g|webp|gif|bmp|tiff?)$/i.test(n);

            try {
                const snap = await listAll(storageRef(storage, base));
                const imageItems = snap.items.filter(item => isImageName(item.name));
                imageItems.sort((a, b) => a.name.localeCompare(b.name));

                siteImages = await Promise.all(
                    imageItems.map(async item => ({ name: item.name, url: await getDownloadURL(item) }))
                );
                console.log('[siteImages] found:', siteImages.map(x => x.name));
            } catch (e) {
                console.warn('[siteImages] list error:', e);
                siteImages = [];
            }

            currentSiteIndex = Math.min(getSiteIndex(), siteImages.length - 1);
            if (currentSiteIndex < 0) currentSiteIndex = 0;
            renderSiteImage();
        }

        function renderSiteImage() {
            const img = document.getElementById('siteImageDisplay');
            const wrapper = document.getElementById('siteImageWrapper');
            const prevBtns = document.querySelectorAll('.prevSiteImage');
            const nextBtns = document.querySelectorAll('.nextSiteImage');
            const rotBtns = document.querySelectorAll('.rotateSiteImage');

            if (!siteImages.length) {
                wrapper.style.height = 'auto';
                prevBtns.forEach(btn => btn.disabled = true);
                nextBtns.forEach(btn => btn.disabled = true);
                rotBtns.forEach(btn => btn.disabled = true);
                img.src = '';
                img.alt = '';
                img.style.opacity = 1;
                return;
            }

            const multi = siteImages.length > 1;
            prevBtns.forEach(btn => btn.disabled = !multi);
            nextBtns.forEach(btn => btn.disabled = !multi);
            rotBtns.forEach(btn => btn.disabled = false);

            const { url, name } = siteImages[currentSiteIndex];
            img.alt = name;
            siteImageRotation = 0;
            img.style.transform = 'rotate(0deg)';

            img.style.opacity = 0.01;
            img.src = `${url}${url.includes('?') ? '&' : '?'}t=${Date.now()}`;

            let safetyTimer = setTimeout(() => {
                console.warn('[siteImages] load timeout; advancing‚Ä¶', name);
                tryNextImage();
            }, 2000);

            img.onload = () => {
                clearTimeout(safetyTimer);
                img.style.opacity = 1;
                requestAnimationFrame(() => {
                    wrapper.style.height = `${img.clientHeight}px`;
                });
            };

            img.onerror = () => {
                clearTimeout(safetyTimer);
                console.warn('[siteImages] decode error; advancing‚Ä¶', name);
                tryNextImage();
            };

            function tryNextImage() {
                if (siteImages.length <= 1) {
                    img.style.opacity = 1;
                    wrapper.style.height = 'auto';
                    return;
                }
                currentSiteIndex = (currentSiteIndex + 1) % siteImages.length;
                saveSiteIndex(currentSiteIndex);
                renderSiteImage();
            }
        }

        function rotateSiteImage() {
            if (!siteImages.length) return;

            const img = document.getElementById('siteImageDisplay');
            const wrapper = document.getElementById('siteImageWrapper');

            siteImageRotation = (siteImageRotation + 90) % 360;
            img.style.transform = `rotate(${siteImageRotation}deg)`;

            const dispW = wrapper.clientWidth;
            const dispH = img.clientHeight;
            const Œ∏ = siteImageRotation * Math.PI / 180;
            const cos = Math.abs(Math.cos(Œ∏));
            const sin = Math.abs(Math.sin(Œ∏));
            const newH = dispW * sin + dispH * cos;

            wrapper.style.height = `${newH}px`;
        }

        function nextSiteImage() {
            if (!siteImages.length) return;
            currentSiteIndex = (currentSiteIndex + 1) % siteImages.length;
            saveSiteIndex(currentSiteIndex);
            renderSiteImage();
        }
        function prevSiteImage() {
            if (!siteImages.length) return;
            currentSiteIndex = (currentSiteIndex - 1 + siteImages.length) % siteImages.length;
            saveSiteIndex(currentSiteIndex);
            renderSiteImage();
        }

        async function uploadSiteImage() {
            const safeProjectName = sanitize(currentProjectName || currentProject);
            if (!currentProject) return alert('Select a project first');
            const file = document.getElementById('siteImageUploader').files[0];
            if (!file) return alert('Pick an image!');

            const blob = await resizeImage(file, 2048);
            const folder = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}/siteImages`;
            const uniqueName = await getUniqueFilename(folder, sanitize(file.name));
            const path = `${folder}/${uniqueName}`;

            await uploadBytes(storageRef(storage, path), blob);

            const placeholderRef = storageRef(storage, `${folder}/.init.txt`);
            try {
                await deleteObject(placeholderRef);
                console.log('Placeholder .init.txt deleted.');
            } catch (err) {
                if (err.code !== 'storage/object-not-found') {
                    console.warn('Error deleting placeholder:', err);
                }
            }

            await updateSiteImages();
            alert(`Uploaded as ‚Äú${uniqueName}‚Äù`);
        }

        document.getElementById('uploadSiteImage').onclick = uploadSiteImage;
        document.querySelectorAll('.nextSiteImage').forEach(btn => btn.onclick = nextSiteImage);
        document.querySelectorAll('.prevSiteImage').forEach(btn => btn.onclick = prevSiteImage);
        document.querySelectorAll('.rotateSiteImage').forEach(btn => btn.onclick = rotateSiteImage);

        async function getUniqueFilename(folderPath, filename) {
            const idx = filename.lastIndexOf('.');
            const base = idx >= 0 ? filename.slice(0, idx) : filename;
            const ext = idx >= 0 ? filename.slice(idx) : '';
            let name = base;
            let suffix = 1;

            while (true) {
                const path = `${folderPath}/${name}${ext}`;
                try {
                    await getDownloadURL(storageRef(storage, path));
                    name = `${base}_${suffix++}`;
                } catch (e) {
                    if (e.code === 'storage/object-not-found') {
                        return name + ext;
                    }
                    throw e;
                }
            }
        }

        // OneDrive upload code
        document.getElementById("uploadFolderToOneDrive").addEventListener("click", async () => {
            const uploadBtn = document.getElementById("uploadFolderToOneDrive");

            if (!currentProject) return alert("Select or load a project first.");
            if (!accessToken) return alert("You must be logged into Microsoft first.");
            if (isTokenExpired(accessToken)) {
                alert("Session expired. Please log in again.");
                logoutMicrosoft();
                return;
            }

            uploadBtn.disabled = true;
            uploadBtn.style.opacity = "0.5";
            uploadBtn.textContent = "Uploading...";

            const isSensor = document.querySelector('input[name="viewMode"]:checked').value === 'sensors';
            const folderType = isSensor ? 'sensors' : 'deliverables';

            const safeProjectName = sanitize(currentProjectName || currentProject);
            const firebaseFolder = `${DATABASE_BASE_PATH}/tasks/images/${safeProjectName}/${folderType}`;
            const oneDriveFolder = `JobPhotos/${safeProjectName}/${folderType}`;

            try {
                const folderRef = storageRef(storage, firebaseFolder);
                const folderSnapshot = await listAll(folderRef);

                await ensureOneDriveFolder("JobPhotos");
                await ensureOneDriveFolder(`JobPhotos/${safeProjectName}`);
                await ensureOneDriveFolder(oneDriveFolder);

                for (const item of folderSnapshot.items) {
                    const blob = await getBlob(item);
                    const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/${oneDriveFolder}/${item.name}:/content`;
                    const res = await fetch(uploadUrl, {
                        method: "PUT",
                        headers: {
                            Authorization: `Bearer ${accessToken}`
                        },
                        body: blob
                    });
                    if (!res.ok) {
                        console.error(`Failed to upload ${item.name}:`, await res.text());
                    }
                }

                // ‚úÖ Upload sensor CSV if in deliverables mode
                if (!isSensor) {
                    const refPath = `${DATABASE_BASE_PATH}/tasks/${currentProject}/sensorMeta`;
                    const snapshot = await get(dbRef(database, refPath));

                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        const headers = ["Sensor #", "Serial", "Measurement 1", "Measurement 2", "Measurement 3"];
                        const rows = [headers];

                        Object.entries(data).forEach(([sensorNum, meta]) => {
                            rows.push([
                                normalizeText(sensorNum),
                                normalizeText(meta.serial),
                                normalizeText(meta.m1),
                                normalizeText(meta.m2),
                                normalizeText(meta.m3)
                            ]);
                        });

                        const csvContent = rows.map(row => row.join(",")).join("\n");
                        const blob = new Blob([csvContent], { type: "text/csv" });
                        const filename = `${sanitize(currentProjectName || currentProject)}_RedlineData.csv`;
                        const csvUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/${oneDriveFolder}/${filename}:/content`;

                        const csvRes = await fetch(csvUrl, {
                            method: "PUT",
                            headers: {
                                Authorization: `Bearer ${accessToken}`
                            },
                            body: blob
                        });

                        if (!csvRes.ok) {
                            console.error(`Failed to upload CSV:`, await csvRes.text());
                        } else {
                            console.log("Sensor CSV uploaded successfully.");
                        }
                    }
                }

                alert(`Uploaded all images${!isSensor ? ' and CSV' : ''} to OneDrive folder: ${oneDriveFolder}`);
            } catch (err) {
                console.error("Upload error:", err);
                alert("Upload failed. See console for details.");
            }

            uploadBtn.disabled = false;
            uploadBtn.style.opacity = "1";
            uploadBtn.textContent = "Upload to OneDrive";
        });

        async function getBlob(storageItem) {
            const url = await getDownloadURL(storageItem);
            const res = await fetch(url);
            return await res.blob();
        }

        async function ensureOneDriveFolder(path) {
            const parts = path.split('/');
            let currentPath = '';
            for (const part of parts) {
                currentPath += (currentPath ? '/' : '') + part;
                const checkUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/${currentPath}:/`;
                const res = await fetch(checkUrl, { headers: { Authorization: `Bearer ${accessToken}` } });

                if (res.status === 404) {
                    const parent = currentPath.substring(0, currentPath.lastIndexOf('/'));
                    const createUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/${parent ? parent : ''}:/children`;
                    const createRes = await fetch(createUrl, {
                        method: "POST",
                        headers: {
                            Authorization: `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            name: part,
                            folder: {},
                            "@microsoft.graph.conflictBehavior": "rename"
                        })
                    });

                    if (!createRes.ok) {
                        throw new Error(`Failed to create folder "${part}": ${await createRes.text()}`);
                    }
                }
            }
        }

        async function confirmWithPassword(actionDescription = "this action") {
            const input = prompt(`Enter password to confirm ${actionDescription}:`);
            return input === ADMIN_PASSWORD;
        }

        document.addEventListener("DOMContentLoaded", async () => {
            const ip = await getIP();
            updateVisitCount(ip);
        });

        let clickCount = 0;
        let clickTimer = null;

        document.getElementById('siteImageDisplay').addEventListener('click', () => {
            clickCount++;

            if (clickCount === 3) {
                rotateSiteImage();
                clearTimeout(clickTimer);
                clickCount = 0;
            }

            if (!clickTimer) {
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                    clickTimer = null;
                }, 400);
            }
        });

        document.querySelector("h1").addEventListener("dblclick", () => {
            const loginSection = document.getElementById("logins-section");
            const adminSection = document.getElementById("adminSection");

            if (loginSection) {
                loginSection.style.display = (loginSection.style.display === "none" || loginSection.style.display === "") ? "flex" : "none";
            }

            if (adminSection) {
                adminSection.style.display = (adminSection.style.display === "none" || adminSection.style.display === "") ? "block" : "none";
            }
        });

        document.getElementById('downloadSiteImage').addEventListener('click', () => {
            if (!siteImages.length) return alert('No site image to download.');

            const index = currentSiteIndex;
            const currentImage = siteImages[index];
            if (!currentImage) return alert('Image not found.');

            const link = document.createElement('a');
            link.href = `${currentImage.url}?t=${Date.now()}`;
            link.download = currentImage.name;
            link.click();
        });

        function createPlaceholderBlob(content = "This is a placeholder file.") {
            return new Blob([content], { type: "text/plain" });
        }

        function normalizeText(text) {
            return (text || "")
                .replace(/[‚Äò‚Äô‚Äõ`¬¥]/g, "'")
                .replace(/[‚Äú‚Äù¬´¬ª]/g, '"')
                .replace(/[‚Äì‚Äî‚àí]/g, '-')
                .replace(/[‚Ä≤‚Ä≥]/g, match => match === '‚Ä≤' ? "'" : '"')
                .replace(/,+/g, " ")
                .replace(/"/g, '')
                .normalize('NFKD')
                .replace(/[^\x00-\x7F]/g, '');
        }

        document.getElementById("exportCSV").addEventListener("click", async () => {
            if (!currentProject) {
                alert("No project selected.");
                return;
            }

            const refPath = `${DATABASE_BASE_PATH}/tasks/${currentProject}/sensorMeta`;
            const snapshot = await get(dbRef(database, refPath));

            if (!snapshot.exists()) {
                alert("No sensor data found.");
                return;
            }

            const data = snapshot.val();
            const headers = ["Sensor #", "Serial", "Measurement 1", "Measurement 2", "Measurement 3"];
            const rows = [headers];

            Object.entries(data).forEach(([sensorNum, meta]) => {
                rows.push([
                    normalizeText(sensorNum),
                    normalizeText(meta.serial),
                    normalizeText(meta.m1),
                    normalizeText(meta.m2),
                    normalizeText(meta.m3)
                ]);
            });

            const csvContent = rows.map(row => row.join(",")).join("\n");
            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = `${sanitize(currentProjectName || currentProject)}_sensorData.csv`;
            a.click();

            URL.revokeObjectURL(url);
        });

        document.querySelectorAll('.section-toggle').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const targetClass = checkbox.dataset.target;
                const elements = document.getElementsByClassName(targetClass);
                for (let el of elements) {
                    el.style.display = checkbox.checked ? '' : 'none';
                }

                // For single-ID targets like siteImagesSection
                const single = document.getElementById(targetClass);
                if (single) {
                    single.style.display = checkbox.checked ? '' : 'none';
                }
            });
        });

        // Save to localStorage
        document.querySelectorAll('.section-toggle').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                localStorage.setItem(`toggle_${checkbox.dataset.target}`, checkbox.checked);
            });
        });

        // Restore on load
        window.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.section-toggle').forEach(checkbox => {
                const saved = localStorage.getItem(`toggle_${checkbox.dataset.target}`);
                if (saved !== null) {
                    checkbox.checked = saved === 'true';
                    checkbox.dispatchEvent(new Event('change')); // apply it
                }
            });
        });

        function updateUploadPermissions() {
            const isAdmin = document.getElementById('adminToggle').checked;

            // Upload buttons
            document.getElementById('uploadDeliverableImage').disabled = !isAdmin;
            document.getElementById('uploadSiteImage').disabled = !isAdmin;
            document.getElementById('uploadFolderToOneDrive').disabled = !isAdmin;

            // Save buttons
            document.getElementById('saveNote').disabled = !isAdmin;
            document.getElementById('saveSensorMeta').disabled = !isAdmin;
            document.getElementById('saveProject').style.display = isAdmin ? 'inline-block' : 'none';

            // Input fields
            document.getElementById('noteDate').disabled = !isAdmin;
            document.getElementById('noteText').disabled = !isAdmin;
            document.getElementById('skipMarkupCheckbox').disabled = !isAdmin;
            document.getElementById('fileUploader').disabled = !isAdmin;
            document.getElementById('imageNameInput').disabled = !isAdmin;
            document.getElementById('markupTextInput').disabled = !isAdmin;
            document.getElementById('sensorCount').disabled = !isAdmin;

            // ‚úÖ Hide or show fieldSelector
            document.getElementById('fieldSelector').style.display = isAdmin ? 'block' : 'none';
        }

        document.getElementById('adminToggle').addEventListener('change', () => {
            const isAdmin = document.getElementById('adminToggle').checked;
            localStorage.setItem('adminMode', isAdmin ? 'true' : 'false');
            updateUploadPermissions();
        });

        window.addEventListener('DOMContentLoaded', () => {
            const saved = localStorage.getItem('adminMode');
            if (saved) {
                document.getElementById('adminToggle').checked = saved === 'true';
            }
            updateUploadPermissions();
        });

        document.getElementById('customizeToggle').addEventListener('click', () => {
            const panel = document.getElementById('customizePanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        });

    </script>
</body>

</html>