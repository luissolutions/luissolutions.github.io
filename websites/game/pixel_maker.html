<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Sprite Studio</title>

  <style>
    body {
      margin: 0;
      padding: 16px;
      background: #141a33;
      color: #fff;
      font-family: monospace;
    }

    .panel {
      margin-bottom: 12px
    }

    canvas {
      image-rendering: pixelated;
      border: 2px solid #444;
      display: block;
    }
  </style>
</head>

<body>

  <h2>Pixel Sprite Studio</h2>

  <div class="panel">
    Width <input id="w" type="number" value="32">
    Height <input id="h" type="number" value="32">

    Scale
    <select id="scale">
      <option value="2">2x</option>
      <option value="4">4x</option>
      <option value="8">8x</option>
      <option value="12">12x</option>
      <option value="16">16x</option>
      <option value="24" selected>24x</option>
      <option value="32">32x</option>
    </select>

    Grid Size
    <input id="gridSize" type="number" value="1" min="1" style="width:60px;">
    <button id="applySize">Apply Size</button>
  </div>

  <div class="panel">
    <button id="undoBtn">Undo</button>
    Color <input id="color" type="color" value="#d4af37">
    <label>
      <input id="noDoubles" type="checkbox">
      Clean Lines
    </label>
  </div>

  <div class="panel">
    <input id="importFile" type="file" accept="image/png,image/jpeg,image/webp">
    <button id="importBtn">Import to Paint</button>
    <button id="importBgBtn">Import as Background</button>
  </div>

  <div class="panel">
    <button id="exportPng">Export PNG (1x)</button>
    <select id="exportScale">
      <option value="2">2x</option>
      <option value="4" selected>4x</option>
      <option value="8">8x</option>
    </select>
    <button id="exportScaled">Export Scaled</button>
  </div>

  <div style="position:relative; display:inline-block;">
    <canvas id="bgLayer"></canvas>
    <canvas id="paintLayer" style="position:absolute; left:0; top:0; z-index:1;"></canvas>
    <canvas id="gridLayer" style="position:absolute; left:0; top:0; pointer-events:none; z-index:2;"></canvas>
  </div>

  <script>
    (() => {

      const $ = id => document.getElementById(id);

      const bgCanvas = $("bgLayer");
      const paintCanvas = $("paintLayer");
      const gridCanvas = $("gridLayer");

      const bgCtx = bgCanvas.getContext("2d");
      const ctx = paintCanvas.getContext("2d", { willReadFrequently: true });
      const gridCtx = gridCanvas.getContext("2d");

      bgCtx.imageSmoothingEnabled = false;
      ctx.imageSmoothingEnabled = false;
      gridCtx.imageSmoothingEnabled = false;

      let drawColor = $("color").value;
      let scale = Number($("scale").value);
      let isDown = false;
      let lastPoint = null;
      let history = [];

      let images = [];
      let activeImage = null;

      let dragging = false;
      let stretching = false;

      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let stretchStartX = 0;
      let stretchStartY = 0;
      let startWidth = 0;
      let startHeight = 0;

      /* ===================== Undo ===================== */

      function saveState() {
        history.push(ctx.getImageData(0, 0, paintCanvas.width, paintCanvas.height));
        if (history.length > 50) history.shift();
      }

      function undo() {
        if (!history.length) return;
        ctx.putImageData(history.pop(), 0, 0);
      }

      $("undoBtn").onclick = undo;

      /* ===================== Size & Scale ===================== */

      function setSize(w, h) {
        bgCanvas.width = w;
        bgCanvas.height = h;
        paintCanvas.width = w;
        paintCanvas.height = h;
        history = [];
        updateScale();
        redrawAll();
      }

      function updateScale() {
        scale = Number($("scale").value);
        const pixelWidth = bgCanvas.width * scale;
        const pixelHeight = bgCanvas.height * scale;

        bgCanvas.style.width = pixelWidth + "px";
        bgCanvas.style.height = pixelHeight + "px";
        paintCanvas.style.width = pixelWidth + "px";
        paintCanvas.style.height = pixelHeight + "px";

        const dpr = window.devicePixelRatio || 1;
        gridCanvas.width = pixelWidth * dpr;
        gridCanvas.height = pixelHeight * dpr;
        gridCanvas.style.width = pixelWidth + "px";
        gridCanvas.style.height = pixelHeight + "px";

        gridCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        drawGrid();
      }

      function drawGrid() {
        const pixelWidth = bgCanvas.width * scale;
        const pixelHeight = bgCanvas.height * scale;
        gridCtx.clearRect(0, 0, pixelWidth, pixelHeight);

        const step = (Number($("gridSize").value) || 1) * scale;
        gridCtx.strokeStyle = "rgba(255,255,255,.25)";
        gridCtx.beginPath();

        for (let x = 0; x <= pixelWidth; x += step) {
          gridCtx.moveTo(x + 0.5, 0);
          gridCtx.lineTo(x + 0.5, pixelHeight);
        }

        for (let y = 0; y <= pixelHeight; y += step) {
          gridCtx.moveTo(0, y + 0.5);
          gridCtx.lineTo(pixelWidth, y + 0.5);
        }

        gridCtx.stroke();
      }

      /* ===================== Drawing ===================== */

      function getMousePos(e) {
        const rect = paintCanvas.getBoundingClientRect();
        return {
          x: Math.floor((e.clientX - rect.left) / rect.width * paintCanvas.width),
          y: Math.floor((e.clientY - rect.top) / rect.height * paintCanvas.height)
        };
      }

      function setPixel(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, 1, 1);
      }

      function erasePixel(x, y) {
        ctx.clearRect(x, y, 1, 1);
      }

      /* ===================== Images ===================== */

      async function importImage(file, layer) {
        const img = new Image();
        const url = URL.createObjectURL(file);
        img.src = url;
        await img.decode().catch(() => { });
        URL.revokeObjectURL(url);

        const newImage = {
          img,
          x: 0,
          y: 0,
          width: bgCanvas.width,
          height: bgCanvas.height,
          layer
        };

        images.push(newImage);
        activeImage = newImage;
        redrawAll();
      }

      function redrawAll() {

        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        ctx.clearRect(0, 0, paintCanvas.width, paintCanvas.height);

        for (const image of images) {
          const target = image.layer === "background" ? bgCtx : ctx;
          target.drawImage(image.img, image.x, image.y, image.width, image.height);
        }
      }

      /* ===================== Mouse ===================== */

      paintCanvas.addEventListener("contextmenu", e => e.preventDefault());

      paintCanvas.addEventListener("mousedown", e => {

        const { x, y } = getMousePos(e);

        if ((e.shiftKey || e.altKey) && images.length) {

          activeImage = images[images.length - 1];

          if (e.shiftKey) {
            dragging = true;
            dragOffsetX = x - activeImage.x;
            dragOffsetY = y - activeImage.y;
          }

          if (e.altKey) {
            stretching = true;
            stretchStartX = x;
            stretchStartY = y;
            startWidth = activeImage.width;
            startHeight = activeImage.height;
          }
          return;
        }

        saveState();
        isDown = true;

        if (e.button === 0) setPixel(x, y, drawColor);
        if (e.button === 2) erasePixel(x, y);

        lastPoint = { x, y };
      });

      paintCanvas.addEventListener("mousemove", e => {

        const { x, y } = getMousePos(e);

        if (dragging && activeImage) {
          activeImage.x = x - dragOffsetX;
          activeImage.y = y - dragOffsetY;
          redrawAll();
          return;
        }

        if (stretching && activeImage) {
          activeImage.width = Math.max(1, startWidth + (x - stretchStartX));
          activeImage.height = Math.max(1, startHeight + (y - stretchStartY));
          redrawAll();
          return;
        }

        if (!isDown) return;

        if (lastPoint) {
          if (e.buttons === 2) erasePixel(x, y);
          else setPixel(x, y, drawColor);
        }

        lastPoint = { x, y };
      });

      window.addEventListener("mouseup", () => {
        isDown = false;
        dragging = false;
        stretching = false;
      });

      /* ===================== UI ===================== */

      $("color").oninput = e => drawColor = e.target.value;
      $("scale").onchange = updateScale;
      $("applySize").onclick = () => setSize(Number($("w").value), Number($("h").value));
      $("importBtn").onclick = () => { const f = $("importFile").files[0]; if (f) importImage(f, "paint"); };
      $("importBgBtn").onclick = () => { const f = $("importFile").files[0]; if (f) importImage(f, "background"); };
      $("exportPng").onclick = () => exportMerged(1);
      $("exportScaled").onclick = () => exportMerged(Number($("exportScale").value));
      $("gridSize").oninput = drawGrid;

      function exportMerged(scaleOut = 1) {
        const out = document.createElement("canvas");
        out.width = bgCanvas.width * scaleOut;
        out.height = bgCanvas.height * scaleOut;
        const octx = out.getContext("2d");
        octx.imageSmoothingEnabled = false;

        octx.drawImage(bgCanvas, 0, 0, out.width, out.height);
        octx.drawImage(paintCanvas, 0, 0, out.width, out.height);

        const a = document.createElement("a");
        a.href = out.toDataURL("image/png");
        a.download = "export.png";
        a.click();
      }

      setSize(32, 32);

    })();
  </script>
</body>

</html>